<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="Product/Architecture/HLD/hld.html"><strong aria-hidden="true">1.</strong> Hld</a></li><li class="chapter-item "><a href="Product/Architecture/adrs/adr-template.html"><strong aria-hidden="true">2.</strong> Adr Template</a></li><li class="chapter-item "><a href="Product/Architecture/rfcs/rfc-template.html"><strong aria-hidden="true">3.</strong> Rfc Template</a></li><li class="chapter-item "><a href="Product/Scrum/acceptance_criteria_template.html"><strong aria-hidden="true">4.</strong> Acceptance Criteria Template</a></li><li class="chapter-item "><a href="Product/Scrum/sprint_goal_template.html"><strong aria-hidden="true">5.</strong> Sprint Goal Template</a></li><li class="chapter-item "><a href="Product/Scrum/user_story_template.html"><strong aria-hidden="true">6.</strong> User Story Template</a></li><li class="chapter-item "><a href="architecture/Explanation/12_software_architecture_styles-software_engineers_should_know.html"><strong aria-hidden="true">7.</strong> Software Architecture Styles Software Engineers Should Know</a></li><li class="chapter-item "><a href="architecture/Explanation/best-practices-when-documenting-your-code-for-software-engineers.html"><strong aria-hidden="true">8.</strong> Best Practices When Documenting Your Code for Software Engineers</a></li><li class="chapter-item "><a href="architecture/Explanation/what_is_solution_architecture.html"><strong aria-hidden="true">9.</strong> What Is Solution Architecture</a></li><li class="chapter-item "><a href="architecture/HowTo/api-doc.html"><strong aria-hidden="true">10.</strong> Api Doc</a></li><li class="chapter-item "><a href="architecture/Reference/10-architecture-patterns-to-know.html"><strong aria-hidden="true">11.</strong> Architecture Patterns to Know</a></li><li class="chapter-item "><a href="architecture/Reference/12_software_architecture_styles-software_engineers_should_know.html"><strong aria-hidden="true">12.</strong> Software Architecture Styles Software Engineers Should Know</a></li><li class="chapter-item "><a href="architecture/Reference/23-fundamental-principles-in-sw-arch.html"><strong aria-hidden="true">13.</strong> Fundamental Principles in Sw Arch</a></li><li class="chapter-item "><a href="architecture/Reference/7-architecture-design-patterns.html"><strong aria-hidden="true">14.</strong> Architecture Design Patterns</a></li><li class="chapter-item "><a href="architecture/Reference/Git-branching.html"><strong aria-hidden="true">15.</strong> Git Branching</a></li><li class="chapter-item "><a href="architecture/Reference/The-important-architecturla-patterns-you-need-to-know.html"><strong aria-hidden="true">16.</strong> The Important Architecturla Patterns You Need to Know</a></li><li class="chapter-item "><a href="architecture/Reference/best-practices-when-documenting-your-code-for-software-engineers.html"><strong aria-hidden="true">17.</strong> Best Practices When Documenting Your Code for Software Engineers</a></li><li class="chapter-item "><a href="architecture/Reference/codeImplementation.html"><strong aria-hidden="true">18.</strong> codeImplementation</a></li><li class="chapter-item "><a href="architecture/Reference/codeReview.html"><strong aria-hidden="true">19.</strong> codeReview</a></li><li class="chapter-item "><a href="architecture/Reference/debugging.html"><strong aria-hidden="true">20.</strong> Debugging</a></li><li class="chapter-item "><a href="architecture/Reference/defects.html"><strong aria-hidden="true">21.</strong> Defects</a></li><li class="chapter-item "><a href="architecture/Reference/dod.html"><strong aria-hidden="true">22.</strong> Dod</a></li><li class="chapter-item "><a href="architecture/Reference/dor.html"><strong aria-hidden="true">23.</strong> Dor</a></li><li class="chapter-item "><a href="architecture/Reference/git_branching_strategy.html"><strong aria-hidden="true">24.</strong> Git Branching Strategy</a></li><li class="chapter-item "><a href="architecture/Reference/habits_of_great_software_engineers.html"><strong aria-hidden="true">25.</strong> Habits of Great Software Engineers</a></li><li class="chapter-item "><a href="architecture/Reference/microservices-checklist.html"><strong aria-hidden="true">26.</strong> Microservices Checklist</a></li><li class="chapter-item "><a href="architecture/Reference/naming-conventions.html"><strong aria-hidden="true">27.</strong> Naming Conventions</a></li><li class="chapter-item "><a href="architecture/Reference/pragmatic.html"><strong aria-hidden="true">28.</strong> Pragmatic</a></li><li class="chapter-item "><a href="architecture/Reference/throughput_and_latency.html"><strong aria-hidden="true">29.</strong> Throughput and Latency</a></li><li class="chapter-item "><a href="architecture/Reference/uid.html"><strong aria-hidden="true">30.</strong> Uid</a></li><li class="chapter-item "><a href="architecture/Reference/uid_comparison.html"><strong aria-hidden="true">31.</strong> Uid Comparison</a></li><li class="chapter-item "><a href="architecture/Reference/what-is-MACH.html"><strong aria-hidden="true">32.</strong> What Is MACH</a></li><li class="chapter-item "><a href="architecture/Reference/what-is-the-C4-model.html"><strong aria-hidden="true">33.</strong> What Is the C4 Model</a></li><li class="chapter-item "><a href="architecture/Reference/what_is_solution_architecture.html"><strong aria-hidden="true">34.</strong> What Is Solution Architecture</a></li><li class="chapter-item "><a href="architecture/adr/decision_record_template.html"><strong aria-hidden="true">35.</strong> Decision Record Template</a></li><li class="chapter-item "><a href="architecture/architectural_principles/index.html"><strong aria-hidden="true">36.</strong> Readme</a></li><li class="chapter-item "><a href="architecture/architectural_principles/SOLID.html"><strong aria-hidden="true">37.</strong> Solid</a></li><li class="chapter-item "><a href="architecture/architectural_principles/design-docs.html"><strong aria-hidden="true">38.</strong> Design Docs</a></li><li class="chapter-item "><a href="architecture/architectural_principles/john_lewis_principles.html"><strong aria-hidden="true">39.</strong> John Lewis Principles</a></li><li class="chapter-item "><a href="architecture/architecture_decision_framework.html"><strong aria-hidden="true">40.</strong> Architecture Decision Framework</a></li><li class="chapter-item "><a href="architecture/scaling_the_practice_of_architecture.html"><strong aria-hidden="true">41.</strong> Scaling the Practice of Architecture</a></li><li class="chapter-item "><a href="architecture/structurizr/adrs/0001-record-architecture-decisions.html"><strong aria-hidden="true">42.</strong> Record Architecture Decisions</a></li><li class="chapter-item "><a href="architecture/structurizr/docs/0001-design.html"><strong aria-hidden="true">43.</strong> Design</a></li><li class="chapter-item "><a href="checklists/architectureChecklist.html"><strong aria-hidden="true">44.</strong> architectureChecklist</a></li><li class="chapter-item "><a href="checklists/designChecklist.html"><strong aria-hidden="true">45.</strong> designChecklist</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hld"><a class="header" href="#hld">HLD</a></h1>
<h2 id="what-is-a-hld"><a class="header" href="#what-is-a-hld">What is a HLD?</a></h2>
<p><img src="Product%5CArchitecture%5CHLD/image-4.png" alt="Alt text" /></p>
<p>HLD is the big picture of the solution. The purpose of HLD is to provide a common understanding of the system’s architecture among all stakeholders. This helps to ensure that everyone is on the same page and that the system is developed in a consistent manner. HLD also helps to identify potential risks and challenges early on, so that they can be addressed before they become major problems</p>
<h2 id="next-is-how-how-to-write-a-good-hld"><a class="header" href="#next-is-how-how-to-write-a-good-hld">Next is “HOW”. How to write a good HLD?</a></h2>
<p>The key to writing a good HLD is to write it in the form a story, a story so good that the reader is engaged with its plot, the backstories of the characters and is on the edge of his/her seat with every plot twist(Okey we don’t have to go as far as adding plot twists). The idea is to keep the keep the design simple to understand, easy to follow and clear about assumptions and tradeoffs. So naturally the first step is knowing your audience. A good HLD should be able to communicate your thoughts to your expected audience.</p>
<p>Hence a general pattern to follow is</p>
<ul>
<li><strong>Context</strong> — Scope out and clearly define the objective and context of problem you are solving.</li>
<li><strong>Design Overview</strong>—State the requirements of the solution with additional context like assumptions, back of the envelope calculation of number of users, size of data, etc.</li>
<li><strong>Detailed Design</strong> — This contains your actual design of the solution.</li>
<li><strong>Alternatives considered</strong> — This helps you convey comparison between tradeoffs. This is good place to focus of potential bottlenecks with each alternative.</li>
<li><strong>Quality Attributes</strong> — Shed light on property of the system like security, Reliability, Data Integrity, Privacy, Scalability, Latency, etc.</li>
<li><strong>Operations</strong> — Plan for maintenance of code like the monitoring, alerting and logging strategy.</li>
</ul>
<p>Find below a template which you can refer and follow. Based on your audience, not all sections will apply to your HLD. Use your judgement to delete a section and introduce new ones. Have fun!</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<h3 id="objective"><a class="header" href="#objective">Objective</a></h3>
<p>In one of two sentences, describe at high level what you are solving using this design. This section should not describe the problem (use “Background”) or propose a solution(use “Design”), not should it got into implementation details like stating list of requirements and features.</p>
<h3 id="background"><a class="header" href="#background">Background</a></h3>
<p>Provide context for an unfamiliar reader to understand the proposal. In a crisp way cover what the problem is, why it is important to solve the problem and the historical context as appropriate. If the background requires a large write up or the reason to for solving the problem becomes verbose, separate docs like PRDs should be created first and linked here. Note: this is background, do not write about your design or ideas to solve the problem here.</p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>This contains high level overview of your design. Should be understandable by a non-engineer not working on the project. Diagrams can be especially useful to quickly convey the shape of the solution. This is going to be the trailer of your story, so keep it clean and concise.</p>
<h3 id="functional-requirements"><a class="header" href="#functional-requirements">Functional Requirements</a></h3>
<p>Describe in brief the various aspects of the problem space like<br />
1. What will the users do<br />
2. Where are users based out of geographically<br />
3. Which platforms, like mobile/web/physical would the users be using.</p>
<h3 id="capacity-estimates"><a class="header" href="#capacity-estimates">Capacity Estimates</a></h3>
<p>Calculate approximates for the key data points. You can use below calculation for reference.<br />
<strong>Active Users</strong> — 2 Billion(B) Daily Active Users(DAU), 3B Monthly Active Users(MAU) — Approximate FB traffic estimate<br />
<strong>Read vs Write</strong> — 100:1<br />
<strong>Queries Per Second</strong> —<br />
Reads — (2B DAU)*(100Read)/(24*60*60) — 2.4M req/sec<br />
Writes — (2B DAU)*(1Write)/(24*60*60) — 24k req/sec<br />
<strong>Storage</strong> — (Assuming for 5 years)<br />
No of objects — (2B DAU)*(5Y*12M*30D) — 3.6 Trillion(T)<br />
Each Object Size — ~ 500 bytes<br />
Total Object size — 3.6T*500 bytes — 1.8 PB<br />
<strong>Throughput</strong> —<br />
Reads — (2.4M QPS)*(500bytes) — 1200 MB/s<br />
Writes — (24K QPS)*(500bytes) — 12 MB/s<br />
Cache — Following 80–20 rule. 20 % users would use 80% of objs) — (1200 MB/s)*(60m*60s)*(0.2) — 864 GB per hour<br />
<strong>Number of Instances required</strong> —<br />
Application Services —<br />
Assuming 100 MB/s per instance as bottleneck— (1200MBps/100MBps)=12<br />
Database —<br />
Assuming 10 TB per instance as bottleneck— 1.8PB/10TB= 180<br />
Assuming 50 MBps disk throughput per instance as bottleneck — 1200MB/s/50 MB/s= 24<br />
Caching — Assuming each instance offers 32 GB — 864/64 = 14</p>
<h3 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h3>
<p>List out key interaction points between user and your system. Typically this has your API details like request and response parameters at a high level.</p>
<h3 id="data-model"><a class="header" href="#data-model">Data Model</a></h3>
<p>This describes key entities of your solution. This space usually helps you to decide till which granularity do you want to break down your entities</p>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed Design</a></h2>
<h3 id="details"><a class="header" href="#details">Details</a></h3>
<p>Get into the detail of the design. Diagrams are best way to express the thought process here. You can start by drawing out the components( which has one or more Data Models identified in earlier section) and connecting them to each other(This is usually called “<a href="https://en.wikipedia.org/wiki/Component_diagram">Component Diagram</a>” and shows high level overview of how components are placed and interact with each others and users of the system).</p>
<p>Optionally, based on complexity of the proposal, you can have multiple types of diagrams like the <a href="https://en.wikipedia.org/wiki/Sequence_diagram">Sequence Diagram</a> (Good for representing a solution with cross-section of multiple use-cases across components and actors), <a href="https://en.wikipedia.org/wiki/Activity_diagram">Activity Diagram</a>(Helpful in representing how multiple components can be clubbed together), <a href="https://en.wikipedia.org/wiki/Deployment_diagram">Deployment Diagram</a>(If you want to get to lower level details), etc. Please choose diagrams which best explain your solution as every problem statement, and every solution is different.</p>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>Discuss your dependencies on other components and services. The fall-back plan when they’re unavailable for a period of time? Which services<br />
must be running for your job to start up?<br />
Are you introducing any cycles, such as blocking on a service that can’t run if your jobs aren’t already up?</p>
<p><img src="Product%5CArchitecture%5CHLD/image-3.png" alt="Alt text" /></p>
<h3 id="migrations"><a class="header" href="#migrations">Migrations</a></h3>
<p>Describe any data or system migrations which might be needed. Incomplete migrations hurt a system in the long run; they add<br />
enormous complexity, hurt reliability, and make programming unpleasant. If existing systems must be turned down to achieve the proposed design, describe how that transition will happen. “How do we get there from here?” is difficult, but often overlooked.</p>
<h3 id="technical-debt"><a class="header" href="#technical-debt">Technical debt</a></h3>
<p>Things to consider</p>
<ol>
<li>Is there known technical debt incurred by implementing this design?</li>
<li>Is there a risk associated with technical debt (e.g., deprecation of underlying technologies) incurred by implementing this design?</li>
<li>How will technical debt identified during the execution of this design be tracked and followed up with?</li>
<li>Are there libraries or code paths that would be deprecated? If so, what is the plan to migrate the usage to the new piece.</li>
<li>Are there libraries or code paths that would be obsolete? When will they be deleted?</li>
<li>Are there any servers that could be turned down? If so, please document the turndown process.</li>
</ol>
<p><img src="Product%5CArchitecture%5CHLD/image-2.png" alt="Alt text" /></p>
<h3 id="potential-patents"><a class="header" href="#potential-patents">Potential patents</a></h3>
<p>Are there potentially patentable inventions in the project?<br />
The work may be patentable if the design:<br />
● Provides for something not otherwise commercially available.<br />
● Does something better/faster/cheaper than what currently exists.<br />
● Addresses an unresolved need.</p>
<h2 id="alternatives-considered"><a class="header" href="#alternatives-considered">Alternatives considered</a></h2>
<p>Clearly list the other potential approaches to meeting the objective that you considered and why the current proposal was ultimately selected. In the rare cases where requirements or system constraints only allow for one possible high-level approach, that should be highlighted here and alternatives to specific details should still be discussed in-line in the detailed design section.<br />
An effective strategy is to compare dimensions of the solution space and how they vary across alternatives, such as latency, data staleness, cpu cost, engineering investment, etc. A color-coded table explaining favorability in that dimension and how important it is from green through yellow, orange and red quickly conveys the rationale to a reader, though this is just<br />
one possible approach to explain the trade-offs. For example:</p>
<p><img src="Product%5CArchitecture%5CHLD/image-1.png" alt="Alt text" /></p>
<h2 id="quality-attributes"><a class="header" href="#quality-attributes">Quality attributes</a></h2>
<h3 id="security"><a class="header" href="#security">Security</a></h3>
<p>Think about potential attacks on your system and describe the counter-measures you have in-place to prevent or mitigate each<br />
attack. For each attack describe the worst case impact it would have. Also, list any known vulnerabilities or potentially insecure dependencies. If<br />
somehow your application doesn’t have security considerations, explicitly state so and why.</p>
<p>Please consider attacks from a variety of sources, including both external and internal risks. When evaluating insider risk, include both insider risk from your co-employees as well as insider risk for customers (e.g. for enterprise products, employees of an enterprise; for consumer products,<br />
family members or friends of customers)</p>
<h3 id="reliability"><a class="header" href="#reliability">Reliability</a></h3>
<p>Discuss handling of local data loss, transient errors (e.g., temporary outages) and how they affect your system. Bear in mind that reliability issues with your dependencies can often cause reliability issues for your system.</p>
<p>What do you use that inherently provides reliability and redundancy for data? What do you use that requires data to be backed up? How is the data backed up? How is it restored? What happens between the time data is lost and the time it’s restored? In the case of a partial loss, can you keep serving and can you restore only missing portions of your backups to your serving datastore?</p>
<p>What are the costs of replicating your data?</p>
<h3 id="data-integrity"><a class="header" href="#data-integrity">Data integrity</a></h3>
<p>Discuss how you will detect, provision for and recover from data corruption and loss.</p>
<p>How will you find out about data corruption or loss in your datastores? What sources of data loss are detected? (User error, application bug, storage platform bug, site/replica disaster.)</p>
<p>How long will it take to notice each of these types of losses? What is your plan to recover from each of these types of losses?</p>
<h3 id="privacy"><a class="header" href="#privacy">Privacy</a></h3>
<p>Does your solution cover privacy standards in place? Is the customer PII protected by sufficient firewalls and encryptions? Are your private keys sufficiently protected?</p>
<h3 id="scalability"><a class="header" href="#scalability">Scalability</a></h3>
<p>How does your system scale? Consider both data size increase (if applicable) and traffic increase (if applicable).</p>
<p>Please consider the current machine situation: adding more machines might take much longer than you think or might not happen during the lifetime of your project. What initial resources will you need? Plan early and carefully. Also, general machine utilization is a concern, using<br />
more resources than you need will block expansion of your service.</p>
<h3 id="latency"><a class="header" href="#latency">Latency</a></h3>
<p>This section can be skipped if you are not designing a server on a human facing path. What latency do you need/expect? In particular, make sure you understand the bottlenecks of the pieces you’re reusing. All services should define latency targets.</p>
<h3 id="testability"><a class="header" href="#testability">Testability</a></h3>
<p>Specify the test plan. What are the sub-units of your system that will be independently testable?</p>
<p>How do you plan to test them? For example,</p>
<ul>
<li>Build a test harness around it that simulates its environment</li>
<li><em>Generate random/carefully controlled input data</em></li>
<li>Compare with golden results/maintain state in the test harness</li>
</ul>
<p>Are you tests run automatically by the CI/CD pipelines</p>
<p>What load can your server handle, and how will you verify that value?</p>
<p>If there are changes envisaged in your future work, would your tests verify the base functionality? If some of your tests cannot be easily automated, how will you document the needed special procedures?</p>
<p>Consider the external systems your system depends on</p>
<ul>
<li>How fast will your unit test cycle run?</li>
<li>What test infrastructure (e.g. test doubles) from external systems will you use?</li>
<li>Does the external system have a test instance for integration testing?</li>
<li>Do you need any tests that run outside of the standard unit test cycle (e.g. presubmit, postsubmit, or release)?<br />
Consider future systems that will depend on yours. What test facilities (e.g. test doubles, local instances for exploratory integration tests) will you provide so that they can run integration tests?</li>
</ul>
<p><img src="Product%5CArchitecture%5CHLD/image.png" alt="Alt text" /></p>
<p>Why you should have a good test!</p>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<h3 id="slas"><a class="header" href="#slas">SLAs</a></h3>
<p>If your application makes any service level guarantees, what mechanisms are in place for auditing, monitoring, etc.? And how can you guarantee the stated level of reliability?</p>
<h3 id="monitoring--alerting"><a class="header" href="#monitoring--alerting">Monitoring &amp; alerting</a></h3>
<p>Is there a mechanism for monitoring and alerting for the running system. Is there an oncall and escalation metrics?</p>
<h3 id="logging-plan"><a class="header" href="#logging-plan">Logging plan</a></h3>
<p>All systems must log information at various levels for the log analysis system to collect and analyze. Log information allows us to understand system user behavior and system related business metrics. In this section, describe the information that you are going to log.</p>
<h3 id="rollback-strategy"><a class="header" href="#rollback-strategy">Rollback strategy</a></h3>
<p>In order to improve incident management response, which will result in reduced time to mitigate issues, teams should document and test their ability to rollback major change surfaces. This includes, but is not limited to:</p>
<ul>
<li>Documenting the overall rollback strategy;</li>
<li>Identifying surface areas which are not able to be rolled back and defining a fix-forward strategy.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-template"><a class="header" href="#rfc-template">RFC Template</a></h1>
<p><strong>Feature Name:</strong> (fill me in with a unique identity, myawesomefeature)</p>
<p><strong>Type:</strong> (feature, enhancement)</p>
<p><strong>Start Date:</strong> (fill me in with today's date, YYYY-MM-DD)</p>
<p><strong>Author:</strong> (your names)</p>
<p><strong>Related components:</strong> (if any)</p>
<p><strong>JIRA issues:</strong> (list of SL- numbers)</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>One paragraph explanation of the feature.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Why are we doing this? What use cases does it support? What is the expected outcome?</p>
<h2 id="detailed-design-1"><a class="header" href="#detailed-design-1">Detailed design</a></h2>
<p>This is the bulk of the RFC. Explain the design in enough detail for somebody familiar with the network to understand, and for somebody familiar with the code practices to implement. This should get into specifics and corner-cases, and include examples of how the feature is used.</p>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>I Why should we not do this?</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>What other designs have been considered? What is the impact of not doing this?</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<p>What parts of the design are still to be done?</p>
<div style="break-before: page; page-break-before: always;"></div><p><a href="https://cucumber.io/docs/gherkin/reference/">Gherkin Reference</a></p>
<p><strong>Feature</strong>: Some terse yet descriptive text of what is desired
In order to realize a named business value
As an explicit system actor
I want to gain some beneficial outcome which furthers the goal</p>
<p><strong>Scenario</strong>: Some determinable business situation
<em>Given</em> some precondition
<em>And</em> some other precondition
<em>When</em> some action by the actor
<em>And</em> some other action
<em>And</em> yet another action
<em>Then</em> some testable outcome is achieved
<em>And</em> something else we can check happens too</p>
<p><strong>Scenario</strong>: A different situation
...</p>
<div style="break-before: page; page-break-before: always;"></div><p>Our focus is on <strong>Outcome</strong></p>
<p>We believe it delivers <strong>Impact</strong> to <strong>Customer</strong></p>
<p>This will be confirmed when <strong>Event happens</strong></p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>As a (who wants to accomplish something)</li>
<li>I want to (what they want to accomplish)</li>
<li>So that (why they want to accomplish that thing)</li>
</ul>
<p>An example:</p>
<ul>
<li>As a bank customer</li>
<li>I want to withdraw money from an ATM</li>
<li>So that I’m not constrained by opening hours or lines at the teller’s</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-software-architecture-styles-software-engineers-should-know"><a class="header" href="#12-software-architecture-styles-software-engineers-should-know">12 Software Architecture Styles Software Engineers Should Know</a></h1>
<p>A brief introduction to Microservice, SOA, Event-Driven, MicroKernel, Stream-Based, and more.</p>
<h1 id="what-is-software-architecture"><a class="header" href="#what-is-software-architecture">What is Software Architecture?</a></h1>
<p><strong><em>Software architecture</em></strong> is the process of defining the high-level structure and organization of a software system. It involves identifying and selecting the right components, deciding how they should interact with each other, and determining how they should be organized to achieve specific goals. The goal of software architecture is to create a system that is maintainable, scalable, and secure, and that can meet the needs of users and organizations over time.</p>
<h1 id="why-do-we-need-software-architecture"><a class="header" href="#why-do-we-need-software-architecture">Why do we need Software Architecture?</a></h1>
<p>A robust architecture provides a solid foundation for building software that meets the needs of users and stakeholders. It ensures that the system meets its functional and non-functional requirements, such as performance, security, and reliability. With a well-designed architecture, developers can build software that is easy to modify and extend, making it easier to adapt to changing business needs.</p>
<p>Software architecture is also essential for managing complexity. As software systems become more complex, it becomes challenging to understand how different components interact with each other. A well-designed architecture provides a high-level view of the system, making it easier to understand its structure and operation. This, in turn, helps developers to identify potential issues and make informed decisions about how to modify the system.</p>
<h1 id="how-do-we-document-architecture-we-use-4c-model"><a class="header" href="#how-do-we-document-architecture-we-use-4c-model"><strong>How do we Document Architecture? We use 4C Model.</strong></a></h1>
<h2 id="context-level"><a class="header" href="#context-level">Context Level</a></h2>
<p>At the highest level, the Context level, we describe the system’s external environment, such as users, other systems, regulations, etc. This level provides a high-level overview of the system’s purpose and its relationship to the external world. It helps to identify the stakeholders who will interact with the system and the factors that will influence its design and development.</p>
<h2 id="containers-level"><a class="header" href="#containers-level">Containers level</a></h2>
<p>The next level is the Containers level, which describes the runtime environment of the system, such as servers, databases, or message queues. This level helps to identify the major technology choices and deployment decisions. It provides an understanding of the physical infrastructure that will support the system and the tools and resources that will be required to deploy and maintain it.</p>
<h2 id="components-level"><a class="header" href="#components-level">Components level</a></h2>
<p>The third level is the Components level, which describes the major functional building blocks of the system. This level helps to identify the modules, classes, or functions that make up the system. It provides an understanding of the system’s functionality and the relationships between its different components.</p>
<h2 id="code-level"><a class="header" href="#code-level">Code level</a></h2>
<p>Finally, the Code level is the lowest level, which describes the actual code and how it implements the components. This level provides a detailed understanding of how the system works and how its different components interact with each other. It is essential for developers who will be working with the code to have a clear understanding of how it is structured and how it works.</p>
<p>Using the C4 model, software architects can create diagrams and written documentation that describe each of these levels, providing a comprehensive view of the system’s architecture. This approach helps to identify potential issues and trade-offs, as well as facilitating scalability, maintainability, and adaptability. By documenting the architecture in this way, developers and stakeholders can have a clear and easy-to-understand view of the system, making it easier to modify and extend as business needs change.</p>
<h1 id="here-are-the-12-software-architecture-styles-software-engineer-should-know"><a class="header" href="#here-are-the-12-software-architecture-styles-software-engineer-should-know">Here are the 12 Software Architecture Styles Software Engineer Should Know</a></h1>
<h2 id="1-client-server"><a class="header" href="#1-client-server">1. Client Server</a></h2>
<p>The client-server architecture is a model in which the client, a user or an application, sends a request to the server, which in turn responds with the requested data or service. The client and server can be on the same machine or on different machines connected through a network.</p>
<p>The client is responsible for initiating communication with the server and sending a request. The server, on the other hand, listens for incoming requests from clients, processes them, and returns a response.</p>
<blockquote>
<p><strong><em>Advantages of Client-Server Architecture</em></strong></p>
<p><strong><em>Scalability:</em></strong> Client-server architecture is highly scalable, as it allows multiple clients to connect to the same server and share resources.</p>
<p><strong><em>Security:</em></strong> Client-server architecture provides better security than other network models, as the server can control access to resources and data.</p>
<p><strong><em>Reliability:</em></strong> Client-server architecture is highly reliable, as the server can provide backup and recovery services in case of failures.</p>
</blockquote>
<h2 id="2-layering"><a class="header" href="#2-layering">2. Layering</a></h2>
<p>It’s a common way to design complex software systems, and it involves breaking down the system into layers, where each layer is responsible for a specific set of functions. This approach helps to organize code and makes it easier to maintain and modify the system over time.</p>
<blockquote>
<p><strong><em>A typical layering architecture consists of three main layers: presentation, business logic, and data access.</em></strong></p>
<p><strong>Presentation Layer:</strong> The presentation layer is responsible for displaying information to the user and gathering input. This layer includes the user interface and any other components that interact directly with the user. The user interface is what the user sees and interacts with, such as buttons, text boxes, and menus. The presentation layer also includes any logic related to the user interface, such as event handlers and validation.</p>
<p><strong>Business Logic Layer:</strong> The business logic layer is responsible for implementing the business rules of the application. This layer contains the code that processes and manipulates data, as well as any other application logic. The business logic layer is where the magic happens, so to speak. It’s where the software performs calculations, makes decisions, and carries out tasks. This layer is where the software really earns its keep.</p>
<p><strong>Data Access Layer:</strong> The data access layer is responsible for interacting with the database or other external data sources. This layer contains the code that reads and writes data to and from the database. The data access layer is where the software retrieves data from the database, makes changes to the data, and saves the changes back to the database. This layer is critical to the functioning of the software, as it enables the software to store and retrieve data.</p>
</blockquote>
<h2 id="3-pipe-and-filter"><a class="header" href="#3-pipe-and-filter">3. Pipe and Filter</a></h2>
<p>Pipe and Filter Architecture is a design pattern that allows software systems to process data by separating the processing tasks into multiple independent components. This architecture is particularly useful for systems that need to handle large amounts of data, as it can help to improve performance, scalability, and maintainability.</p>
<p>The Pipe and Filter Architecture is based on the idea of a pipeline, where data flows through a series of processing steps, each of which performs a specific task. Each processing step is implemented as a separate component, or filter, that accepts data as input, performs some operation on the data, and produces output data. The output data is then passed on to the next filter in the pipeline.</p>
<p>The filters in the pipeline are independent of each other, which means that they can be developed, tested, and deployed separately. This makes it easy to add new filters to the pipeline or modify existing ones without affecting the rest of the system.</p>
<blockquote>
<p><strong><em>Benefits</em></strong></p>
<p><strong>Scalability:</strong> The architecture can be scaled horizontally by adding more filters to the pipeline, which allows the system to handle larger amounts of data.</p>
<p><strong>Performance:</strong> The architecture can be optimized for performance by parallelizing the processing of data across multiple filters.</p>
<p><strong>Maintainability:</strong> The architecture promotes modularity and separation of concerns, which makes it easier to maintain and update the system over time.</p>
</blockquote>
<h2 id="4-master-slave"><a class="header" href="#4-master-slave">4. Master-Slave</a></h2>
<p>Master-Slave architecture is a design pattern used in distributed systems, where one node (the master) controls one or more nodes (the slaves) to perform specific tasks. The master node is responsible for distributing the workload across the slaves and for coordinating their activities. The slave nodes do not have the same level of control as the master node and only perform tasks that are assigned to them by the master.</p>
<blockquote>
<p><strong><em>Benefits</em></strong></p>
<p>One of the most significant advantages is that it allows for the efficient distribution of workload across multiple nodes. This helps to reduce the load on any one node and ensures that the system can handle large amounts of data and traffic.</p>
<p>Another advantage of using a master-slave architecture is that it provides fault tolerance. If one of the slave nodes fails, the master node can redistribute its workload to the other slave nodes. This ensures that the system can continue to function even if one or more nodes fail.</p>
</blockquote>
<h2 id="5-microkernel"><a class="header" href="#5-microkernel">5. MicroKernel</a></h2>
<p>MicroKernel architecture is a software design pattern that allows developers to build more modular and flexible systems. It separates the core system functionality from additional features, which are implemented in separate modules. The core functionality of the system is implemented in the MicroKernel, a minimalistic core system that provides only the most essential services required to run the system. It is plug and play concept.</p>
<blockquote>
<p><strong>Example:</strong></p>
<p>Let’s consider the example of an e-commerce website. The MicroKernel would provide essential services such as handling user authentication, managing user sessions, and processing payments. Additional features, such as product recommendations, user reviews, and social media integration, would be implemented in separate modules.</p>
<p>If the website wants to add a new feature, such as a loyalty program, it can be developed and added as a separate module without affecting the core functionality of the system. This modularity makes it easier to add new features or remove existing ones without affecting the core system functionality.</p>
<p>Furthermore, if the website wants to customize its system to meet the specific needs of different users, it can choose the modules it needs for each user. For example, a user who frequently buys electronics can be provided with a module that recommends electronic products. On the other hand, a user who frequently buys cosmetics can be provided with a module that recommends cosmetic products.</p>
<p>Finally, if the website wants to scale its system to handle more users or changes in hardware, it can easily add or remove modules as needed. This scalability makes it easier to adapt the system to changes in user requirements or changes in the underlying hardware.</p>
</blockquote>
<h2 id="6-ddd-domain-driven-design"><a class="header" href="#6-ddd-domain-driven-design">6. DDD (Domain Driven Design)</a></h2>
<p>At its core, DDD is a way of thinking about software architecture that emphasizes the domain or problem space of a project. This means that developers focus on the business logic of the software, rather than just the technical implementation.</p>
<p>In practice, this means that developers start by understanding the domain they are working in and break it down into smaller, more manageable parts. They then use this understanding to create a domain model, which is a representation of the different entities within the domain and how they interact with one another.</p>
<p>Once the domain model is created, developers can use it to guide the rest of the architecture of the software. This includes creating bounded contexts, which are areas of the software that are defined by a specific language and context, and aggregates, which are collections of related entities that are treated as a single unit.</p>
<h2 id="7-component-based"><a class="header" href="#7-component-based">7. Component Based</a></h2>
<p>In software engineering, component-based architecture (CBA) is an approach to software design and development that emphasizes the use of reusable software components. The idea behind CBA is that software development can be made more efficient and effective by breaking down complex systems into smaller, more manageable components.</p>
<blockquote>
<p><strong>What is a component?</strong></p>
<p>A software component is a modular, self-contained unit of software that can be reused across different systems. A component typically has a well-defined interface, which specifies how other components can interact with it. This interface includes information about the component’s inputs, outputs, and behavior.</p>
<p>Components can be classified into different types based on their functionality, such as user interface components, data access components, and business logic components. Each type of component has a specific role in the software system and can interact with other components through their interfaces.</p>
</blockquote>
<h2 id="8-soa"><a class="header" href="#8-soa">8. SOA</a></h2>
<p>SOA is an architectural style that aims to create modular, reusable services that can be easily integrated with other services to create a larger system. In this approach, services expose their functionality through interfaces, which can be accessed by other services or applications.</p>
<p>At its core, SOA is about building software by breaking it down into smaller pieces, or modules, that can be reused across different applications. This modular approach allows developers to focus on building specific pieces of functionality and then integrating them with other pieces to create a larger system.</p>
<blockquote>
<p><strong><em>Core Components of SOA</em></strong></p>
<p><strong>Service Provider:</strong> The service provider is responsible for creating and exposing services to the outside world. These services can be used by other services, applications, or end-users. For example, a payment processing service provider might create and expose a service that allows other applications to process payments.</p>
<p><strong>Service Registry:</strong> The service registry is a directory of available services that can be accessed by other services or applications. The service registry provides information about the service, such as its name, location, and interface. For example, if an application needs to process payments, it can use the service registry to find the payment processing service and access its interface.</p>
<p><strong>Service Requestor:</strong> The service requestor is responsible for consuming the services exposed by the service provider. This can be done by using the service registry to find the appropriate service and then invoking its interface. For example, an application might use the service registry to find the payment processing service and then use its interface to process payments.</p>
</blockquote>
<h2 id="9-monolithic"><a class="header" href="#9-monolithic">9. Monolithic</a></h2>
<p>Monolithic architecture is a software design pattern that has been around for decades. It’s a way of structuring an application as a single, cohesive unit, rather than splitting it up into individual, smaller components.</p>
<p>In a monolithic architecture, the entire application is built as a single, self-contained unit. All of the code and dependencies are packaged together, so the application can be deployed and run on a single server.</p>
<p>This makes it easy to develop and deploy the application, since everything is in one place. It also makes it easier to scale the application horizontally, by adding more servers.</p>
<blockquote>
<p><strong><em>Advantages of Monolithic Architecture</em></strong></p>
<p>One of the biggest advantages of monolithic architecture is its simplicity. Since everything is contained in a single unit, there are fewer moving parts to worry about. This makes it easier to develop, test, and deploy the application.</p>
<p>Another advantage is that it’s easier to maintain and debug a monolithic application. Since everything is in one place, it’s easier to track down issues and fix them.</p>
<p><strong><em>Disadvantages of Monolithic Architecture</em></strong></p>
<p>One of the biggest disadvantages of monolithic architecture is that it can be difficult to scale the application vertically. Since everything is running on a single server, there’s a limit to how much traffic the application can handle.</p>
<p>Another disadvantage is that it can be difficult to adopt new technologies and languages in a monolithic application. Since everything is packaged together, it can be hard to update individual components without breaking the entire application.</p>
</blockquote>
<h2 id="10-microservice"><a class="header" href="#10-microservice">10. Microservice</a></h2>
<p>Microservice architecture is a style of software architecture that structures an application as a collection of small, independent services that communicate with each other over a network. Each service is focused on a specific business capability and can be developed, deployed, and scaled independently of other services in the system.</p>
<p>The main idea behind microservice architecture is to break down a large, monolithic application into smaller, more manageable services. This approach brings several benefits, such as improved scalability, increased flexibility, and quicker time-to-market for new features. With a microservice architecture, each service can be scaled independently, making it easier to handle traffic spikes or changes in demand. Developers can also modify or add new services without affecting other parts of the system, which speeds up the development process.</p>
<blockquote>
<p><strong><em>Challenges of Microservice Architecture</em></strong></p>
<p>Despite the benefits of microservice architecture, it also introduces additional complexity. One of the biggest challenges is managing inter-service communication. Services need to be able to discover each other and communicate effectively, which can be difficult to do at scale. Load balancing and fault tolerance are also more complex in a microservice architecture.</p>
<p>Another challenge is ensuring that each service has its own data store. In a monolithic application, all data is typically stored in a single database. With microservices, each service should have its own data store to ensure that changes to one service do not affect other services in the system. This can lead to increased complexity in data management and synchronization.</p>
<p><strong><em>Best Practices for Microservice Architecture</em></strong></p>
<p>To ensure the success of a microservice-based system, developers should follow best practices for designing and implementing microservices. Some of these best practices include:</p>
<p>1. Design services that are loosely coupled and highly cohesive, with clear boundaries and well-defined interfaces.</p>
<p>2. Use containerization technology, such as Docker, to package and deploy each service as a separate container. This allows for easy scaling and deployment of individual services as needed.</p>
<p>3. Implement effective monitoring and management tools to ensure that the system is running smoothly and to detect and address issues quickly.</p>
<p>4. Use a service mesh, such as Istio, to manage inter-service communication and load balancing.</p>
<p>5. Implement a continuous integration and deployment (CI/CD) pipeline to automate the testing and deployment of microservices.</p>
</blockquote>
<h2 id="11-event-driven"><a class="header" href="#11-event-driven">11. Event Driven</a></h2>
<p>Event Driven Architecture (EDA) is an approach to designing software systems that enables rapid and efficient communication between different components or services. In this paradigm, different software components communicate with each other using events, rather than through direct requests or responses.</p>
<p>In EDA, events are generated by different components of a software system, such as a user interface or a backend service. These events are then broadcast to other components of the system, which can subscribe to them and act on them as needed.</p>
<p>For example, consider a simple e-commerce application. When a new order is placed, the order processing service can generate an “order created” event, which is then broadcast to other services such as inventory management, shipping, and billing. Each of these services can then process the event and make updates to their respective systems.</p>
<blockquote>
<p><strong><em>Benefits of EDA</em></strong></p>
<p>One of the key benefits of EDA is its ability to decouple different components of a software system. When different components communicate through events rather than direct requests, they become less dependent on each other. This makes it easier to change or update individual components of the system without affecting the rest of the system.</p>
<p>Another benefit of EDA is its scalability. Because events are broadcast to multiple components of the system, it is possible to process large volumes of data and transactions in parallel. This makes it easier to handle high traffic and spikes in demand.</p>
<p><strong><em>Challenges of EDA</em></strong></p>
<p>While EDA has many benefits, it also has some challenges. One of the main challenges is managing the complexity of event-driven systems. Because events can be generated and consumed by many different components, it can be difficult to track and debug issues that arise.</p>
<p>Another challenge is ensuring that events are processed in the correct order. Because events can be generated and processed asynchronously, it is possible for events to be processed out of order. This can cause issues such as data inconsistencies or incorrect calculations.</p>
</blockquote>
<h2 id="12-stream-based"><a class="header" href="#12-stream-based">12. Stream Based</a></h2>
<p>As software development becomes more complex and demands greater scalability, traditional architectures are becoming less and less effective. Stream-based architecture is emerging as a promising alternative that enables developers to build systems that can handle massive amounts of data in real-time.</p>
<p>At its core, stream-based architecture is based on the principles of event-driven programming. Instead of processing data in batches, stream-based systems process data as it is generated in real-time. This allows developers to build systems that can respond to changes in data with minimal latency.</p>
<blockquote>
<p><strong><em>Benefit of Stream-Based Architecture</em></strong></p>
<p>One of the key benefits of stream-based architecture is its scalability. Because data is processed in real-time, stream-based systems can handle massive amounts of data without the need for complex batch processing pipelines. This makes it possible to build systems that can process millions of events per second, making it ideal for use cases like sensor data processing, financial trading, and online advertising.</p>
<p>Another benefit of stream-based architecture is its flexibility. Because data is processed in real-time, it is possible to build systems that can respond to changes in data with minimal latency. This makes it possible to build complex, event-driven systems that can adapt to changing business requirements. For example, in an e-commerce platform, stream-based architecture can be used to track user activity in real-time and respond with personalized recommendations and promotions based on the user’s browsing and purchasing history.</p>
<p>Furthermore, stream-based architecture can provide significant cost savings. Traditional batch processing pipelines require expensive hardware and complex software infrastructure to manage the data processing. On the other hand, stream-based systems can be built on inexpensive commodity hardware, making it much easier to scale and maintain.</p>
<p>Finally, stream-based architecture is highly fault-tolerant. Because data is processed in real-time, it is possible to build systems that can automatically recover from failures without the need for manual intervention. This makes it possible to build systems that can operate at scale with high levels of reliability, reducing the risk of data loss or system downtime.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices-when-documenting-your-code-for-software-engineers"><a class="header" href="#best-practices-when-documenting-your-code-for-software-engineers">Best Practices When Documenting Your Code for Software Engineers</a></h1>
<p>It’s all about clear, asynchronous communication</p>
<p><img src="architecture%5CExplanation/image.png" alt="Alt text" /></p>
<p>As a software engineer, it is very important to acquire the skill of writing high-quality documentation. Due to the recent increase in remote work, it has become even more important to be better at asynchronous communication. Remote company GitLab does an excellent job of <a href="https://about.gitlab.com/company/culture/all-remote/asynchronous/">defining asynchronous communication</a>:</p>
<blockquote>
<p>“Asynchronous communication is the art of communicating and moving projects forward without the need for additional stakeholders to be available at the same time your communique is sent.”</p>
</blockquote>
<p>High-quality documentation is an easier way to achieve effective asynchronous communication. In this article, I am going to talk about some interesting tips that I have found very useful in my personal experience.</p>
<h2 id="google-tech-writing-course"><a class="header" href="#google-tech-writing-course">Google Tech Writing Course</a></h2>
<p>Google offers a free tech writing course for software engineers. It starts with the fundamentals of tech writing. There are two courses and the content is as shown below:</p>
<p><img src="architecture%5CExplanation/image-1.png" alt="Alt text" /></p>
<p>TOC — Google Tech Writing One</p>
<p><img src="architecture%5CExplanation/image-2.png" alt="Alt text" /></p>
<p>TOC — Google Tech Writing Two</p>
<p>Being good at tech writing does not happen overnight. It takes practice. I personally prefer visiting this course each month to remind myself of the best practices.</p>
<h2 id="using-the-divio-documentation-framework"><a class="header" href="#using-the-divio-documentation-framework">Using the Divio Documentation Framework</a></h2>
<p>Amongst all other documentation frameworks, I personally like <a href="https://www.divio.com/">Divio</a> the best. The documentation systems suggested there are easy and universally applicable.</p>
<p>The framework suggests classifying documentation in the following types:</p>
<ul>
<li>Tutorials — Learning-oriented</li>
<li>How-To Guides — Problem-solving-oriented</li>
<li>Explanation — Understanding-oriented</li>
<li>Reference — Information-oriented</li>
</ul>
<p>The scheme is <a href="https://documentation.divio.com/adoption/#adoption">widely adopted</a> by a lot of famous open source projects and enterprises.</p>
<p>Here is a great video explaining the details of the framework:</p>
<h2 id="use-markdown-based-systems-for-documentation"><a class="header" href="#use-markdown-based-systems-for-documentation">Use Markdown-Based Systems for Documentation</a></h2>
<p>In a typical enterprise, there are various ways you can maintain your documentation. Some people prefer creating MS Word/Excel documents and uploading those in SharePoint or OneDrives. The biggest problem with such documents is that they are not searchable using your internal search engine. Hence I personally prefer using Markdown-based documentation systems. Creating and maintaining documentation is easy and the documentation is searchable.</p>
<p>If you are not familiar with Markdown, you can easily master it. Check out this free recommended <a href="https://guides.github.com/features/mastering-markdown/">course</a> from GitHub.</p>
<h2 id="using-mermaid-js-for-diagrams"><a class="header" href="#using-mermaid-js-for-diagrams">Using Mermaid JS for Diagrams</a></h2>
<p>According to <a href="http://mermaid-js.github.io/mermaid/">Mermaid</a> itself, it “is a Javascript-based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams.” If you are using GitLab or Azure DevOps, Mermaid is natively supported. If you are using GitHub or Atlassian products, then there are plug-ins available.</p>
<p>With Mermaid, creating and updating diagrams is very easy and you don’t need to have any UML tools like Visio/draw.io installed on every developer’s workstation.</p>
<p>Here are some sample diagrams created with Mermaid</p>
<p><img src="architecture%5CExplanation/image-3.png" alt="Alt text" /></p>
<p>Sample Sequence Diagram using Mermaid</p>
<p><img src="architecture%5CExplanation/image-4.png" alt="Alt text" /></p>
<p>Sample Class Diagram using Mermaid</p>
<p>You can try out creating diagrams using the <a href="https://mermaid-js.github.io/mermaid-live-editor/">Mermaid Live Editor</a> as well.</p>
<h2 id="use-templates"><a class="header" href="#use-templates">Use Templates</a></h2>
<p>There are numerous templates available on various sites like Confluence that can be used for specific types of documents. For example:</p>
<ul>
<li><a href="https://www.atlassian.com/software/confluence/templates/software-architecture-review">Software Architecture Review Template</a></li>
<li><a href="https://github.com/deshpandetanmay/lightweight-architecture-decision-records/blob/master/doc/adr/0001-use-elasticsearch-for-search-api.md">Architecture Decision Record Template</a></li>
<li><a href="https://www.atlassian.com/software/confluence/templates/incident-postmortem">Incident Postmortem Template</a></li>
<li><a href="https://www.atlassian.com/software/confluence/templates/devops-runbook">DevOps Runbook</a></li>
<li><a href="https://www.atlassian.com/software/confluence/templates/decision">Decision Template</a></li>
<li><a href="https://www.atlassian.com/software/confluence/templates/writing-guidelines">Writing Guidelines</a></li>
<li><a href="https://www.atlassian.com/software/confluence/templates/okrs">OKR Template</a></li>
<li>Etc.</li>
</ul>
<h2 id="refer-to-style-guides"><a class="header" href="#refer-to-style-guides">Refer to Style Guides</a></h2>
<p>If your team does not have a style guide already, refer to what the Googles and Microsofts of the world do:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/style-guide/">Microsoft Style Guide</a></li>
<li><a href="https://developers.google.com/style">Google Developer Documentation Style Guide</a></li>
</ul>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://developers.google.com/tech-writing">Google Tech Writing Course</a></li>
<li><a href="https://documentation.divio.com/">Divio Documentation Framework</a></li>
<li><a href="https://mermaid-js.github.io/mermaid/#/">Mermaid</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-solution-architecture"><a class="header" href="#what-is-solution-architecture">What is Solution Architecture</a></h1>
<p>An informal introduction to Solution Architecture</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>The term Solution Architecture refers to a high-level blueprint of a solution that was developed to solve one or more business problems within an enterprise using a technological approach. Building a proper solution architecture requires</p>
<ul>
<li>A good understanding of the business problem or problems (domain knowledge)</li>
<li>Comprehensive knowledge of the technologies used in the enterprise world (technical knowledge)</li>
<li>Experience in building similar solutions in the past (experience)</li>
</ul>
<p>A good solution architecture can be used to perform critical tasks such as</p>
<ul>
<li>Designing and implementing innovative solutions for the consumers of the business</li>
<li>Maintain excellent user experience with higher degrees of service availability</li>
<li>Perform calculations on return on investment (ROI) and total cost of ownership (TCO)</li>
</ul>
<p>Solution architecture tries to compact a gigantic set of details into a set of diagrams so that different stakeholders understand what is actually going on inside the enterprise software systems. It is helpful for highly technical people such as software developers, software architects, and CTOs as well we moderately technical people such as project managers, business analysts, and citizen developers.</p>
<h2 id="types-of-architectures-in-solution-architecture"><a class="header" href="#types-of-architectures-in-solution-architecture">Types of architectures in solution architecture</a></h2>
<p>The first step in solving any problem is understanding the business requirements of the client. To include all the critical information related to the business use case, we can come up with something called a “business architecture” which contains different types of applications, users, and their interactions at a very high level. We sometimes call this architecture “Level 0” architecture.</p>
<h3 id="business-architecture-level-0-architecture"><a class="header" href="#business-architecture-level-0-architecture">Business architecture (Level-0 architecture)</a></h3>
<p>The idea of business architecture is to come up with a possible solution to a real-world problem or problems and depict that in the form of a diagram or a document using the systems, applications, and users that are considered in the scenario with minimum technical details. This component is mainly useful for business executives and other non-technical stakeholders so that they can understand what technical solution is going to be built using this architecture. Given below is a “business architecture” diagram that we came up with for a mobile banking application.</p>
<p><img src="architecture%5CExplanation/image-7.png" alt="Alt text" /></p>
<p>Figure: The business architecture of a mobile banking application</p>
<p>The preceding figure depicts the various components associated with the solution in which we are building a mobile banking application for a given bank. It showcases the components such as gateway, integration, and security component as high-level building blocks to design a solution for this problem.</p>
<p>The next step in designing the solution architecture is to use this and design a technical architecture with the finer details about products and tools.</p>
<h3 id="technical-architecture-level-1-architecture"><a class="header" href="#technical-architecture-level-1-architecture">Technical architecture (Level-1 architecture)</a></h3>
<p>This is the type of diagram that includes details of specific vendors, products, and tools required to build a real-world software system using the business architecture blueprint. Coming up with a technical architecture requires the proper analysis of vendors and tools as well as the current and future business requirements and TCO/ROI calculations. The below diagram depicts a simplified version of a technical architecture for the business architecture we discussed before.</p>
<p><img src="architecture%5CExplanation/image-6.png" alt="Alt text" /></p>
<p>Figure: Technical architecture of a mobile banking solution</p>
<p>In this diagram, we have mentioned the specific vendors that we are going to use to fulfill the certain functionalities that we identified during the business architecture design phase. As an example, the diagram depicts that we are going to use the WSO2 API Manager solution as the API gateway which exposes the services to the mobile application. Similarly, it shows that we are going to use Mulesoft and Auth0 for respective functionalities. In addition to that, we can also depict information about which cloud platforms and container technologies we are going to use if we decided to go with a container-based solution.</p>
<p>Once the product vendors and tools are identified, the next step is to go further down into the actual deployment details and showcase the infrastructure level details that can be used by the developers as well as the operations teams to build the actual infrastructure for the solution.</p>
<h3 id="deployment-architecture-level-2-architecture"><a class="header" href="#deployment-architecture-level-2-architecture">Deployment architecture (Level-2 architecture)</a></h3>
<p>This architecture diagram showcases how the technical architecture looks like in a real computing infrastructure such as a data center or a cloud platform. It contains details on network-level segmentation, the number of replicas (instances), traffic routing components such as load balancers or firewalls, and many other details related to the actual deployment of the solution. The figure below depicts a simplified version of a deployment architecture that we can come up with for the mobile banking solution that we discussed before.</p>
<p><img src="architecture%5CExplanation/image-5.png" alt="Alt text" /></p>
<p>Figure: Deployment architecture for mobile banking solution</p>
<p>The preceding figure depicts the product versions, the number of replicas, and the deployment model of each component along with the traffic routing components (load balancers).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-docs-from-an-open-api-spec"><a class="header" href="#create-docs-from-an-open-api-spec">Create docs from an Open API Spec</a></h1>
<h2 id="widdershins"><a class="header" href="#widdershins">Widdershins</a></h2>
<h3 id="install"><a class="header" href="#install">Install</a></h3>
<pre><code class="language-shell">npm install -g widdershins
</code></pre>
<h3 id="config"><a class="header" href="#config">config</a></h3>
<p>save in config.json</p>
<pre><code class="language-shell">{
  &quot;language_tabs&quot;: [
    {
      &quot;python&quot;: &quot;Python&quot;
    },
    {
      &quot;http&quot;: &quot;HTTP&quot;
    },
    {
      &quot;shell&quot;: &quot;Shell&quot;
    }
  ],
  &quot;language_clients&quot;: [
    {
      &quot;shell&quot;: &quot;curl&quot;
    }
  ],
  &quot;httpsnippet&quot;:&quot;true&quot;,
  &quot;resolve&quot;:&quot;true&quot;,
  &quot;headings&quot;:&quot;4&quot;
}
</code></pre>
<h3 id="run"><a class="header" href="#run">run</a></h3>
<h4 id="create-html"><a class="header" href="#create-html">create html</a></h4>
<pre><code class="language-shell">widdershins --environment config.json --html &lt;api_spec&gt;.yaml -o index.html
</code></pre>
<h4 id="create-respec"><a class="header" href="#create-respec">create respec</a></h4>
<pre><code class="language-shell">widdershins --environment config.json --respec &lt;api_spec&gt;.yaml -o index.html
</code></pre>
<h4 id="create-markdown"><a class="header" href="#create-markdown">create markdown</a></h4>
<pre><code class="language-shell">widdershins --environment config.json &lt;api_spec&gt;.yaml -o index.md
</code></pre>
<h2 id="reslate-to-create-html"><a class="header" href="#reslate-to-create-html">reslate to create html</a></h2>
<h3 id="get-reslate"><a class="header" href="#get-reslate">Get reslate</a></h3>
<blockquote>
<p><strong><em>NOTE:</em></strong> You may wish to create a fork of this repo</p>
</blockquote>
<pre><code class="language-shell"> git clone git@github.com:Mermade/reslate.git
</code></pre>
<h3 id="copy-your-markdown-file"><a class="header" href="#copy-your-markdown-file">Copy your markdown file</a></h3>
<p>Copy markdown file to source/index.md</p>
<h3 id="change-logo"><a class="header" href="#change-logo">change logo</a></h3>
<p>change _site\slate\img\logo.png</p>
<h3 id="change-css-if-required"><a class="header" href="#change-css-if-required">change css if required</a></h3>
<p>modify _site\slate\css\screen.css</p>
<h3 id="install-1"><a class="header" href="#install-1">install</a></h3>
<pre><code class="language-shell">npm i
</code></pre>
<h3 id="access-content"><a class="header" href="#access-content">Access content</a></h3>
<pre><code class="language-shell">npm run serve
</code></pre>
<p>browse to http://localhost:4567</p>
<h2 id="pandoc"><a class="header" href="#pandoc">pandoc</a></h2>
<h3 id="install-pandoc"><a class="header" href="#install-pandoc">install pandoc</a></h3>
<pre><code class="language-shell">apt install pandoc
</code></pre>
<h3 id="run-pandoc"><a class="header" href="#run-pandoc">run pandoc</a></h3>
<blockquote>
<p><strong><em>NOTE:</em></strong> When creating pdf's pandoc doesnt wrap code blocks</p>
</blockquote>
<h4 id="docx"><a class="header" href="#docx">docx</a></h4>
<pre><code class="language-shell"> pandoc -o &lt;output&gt;.docx -f markdown -t docx &lt;input&gt;.md
</code></pre>
<h4 id="pdf"><a class="header" href="#pdf">pdf</a></h4>
<pre><code class="language-shell"> pandoc &lt;input&gt;.md -o &lt;output&gt;.pdf -V geometry:margin=1in
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-design-patterns-every-software-architect-and-software-engineer-must-know"><a class="header" href="#10-design-patterns-every-software-architect-and-software-engineer-must-know">10 Design Patterns every Software Architect and Software Engineer must know</a></h1>
<p>Any business exists to solve a real human problem. It could be to increase speed, reduce cost, improve convenience, add pleasure to life or make the knowledge available at the fingertips. Technology often used to solve these business problems. But then why the design patterns are important? Typical challenges with IT system are Availability, Scalability, Resiliency, Data Management, Performance and Security. Before going into design patterns it is important to get clarity of these words.</p>
<p><strong>Availability:</strong> Availability is the percentage of time system is up in a defined timeframe. A system can be down because of multiple reasons like software errors, network issues, load issues, DDos (Distributed Denial of Service) attacks and infrastructure hardware issues. Availability is measured as a percentage as below.</p>
<p><img src="architecture%5CReference/image-30.png" alt="Alt text" /></p>
<p><strong>Scalability</strong>: In 2014, Flipkart - an Indian online retailer went on to <a href="https://www.livemint.com/Industry/t5UDgJyzPcvF7vK7j7M62O/Flipkart-apologizes-to-customers-for-mega-sale-glitches.html">apologise</a> to customers as big billion sale could not cope up with customer demands because of scalability issues. Scalability is a factor of computing resources, data storage needs, messaging infrastructure and cost. There are two ways to sort out scalability issues. The first one is vertical scaling where you would keep on increasing the capacity of the resources the second one is horizontal scalability where you add more nodes. There are pros and cons with either of these approaches. Typically, vertical scaling is faster, but has limitation beyond a certain point of time and horizontal scaling takes more time and offers close to infinity scaling.</p>
<blockquote>
<p>Scalability is how the system resources can cope up with unpredictable customer demands.</p>
</blockquote>
<p><strong>Resiliency:</strong> You went on to buy a watch on an e-commerce site. You did not like the design and you want to look for more options. You selected few dropdown boxes with design, color, price filters and clicked on search button. Now you would expect to see picture of the watch, price data, some specifications like Band Material Type, Watch Movement, Colour, Delivery Date. What if delivery date microservice was down that time? As an architect, you have multiple options now. Do not show that field at all, show a static message that “We are calculating the accurate delivery date, please be patient”, or you pick up a date range and show to the customer.</p>
<blockquote>
<p>Resiliency is the ability of a system to gracefully handle the failures and recover from failures as soon as it can.</p>
</blockquote>
<p><strong>Data Management:</strong> Data management plays a crucial role in scalability, availability, security and resiliency. Architectural decisions related to data management depends on what type of application you are building. Is it write heavy (more user transactions), read-heavy (reports), meant to do analytics (forecasting, customer segmentation), time series (log processing) or Datawarehouse (data analytics). Few other factors that would influence are data consistency, data availability, data storage and archival strategy.</p>
<p><strong>Performance:</strong> Scalability and performance are interrelated. If there are more users compared to what the system can handle, it is natural that the system would encounter performance issues. How to deal with this? Either you increase the resources or reduce the number of users. Of course, the second choice is not ideal because you would end up losing the business. In fact, we will sort out these performance issues when you sort out scalability issues. I just want to remind you, scalability can’t solve all the performance issues but can solve some issues. For example, if the performance issues are the result of badly written DB query, scaling the resources without fine-tuning the query will prove to be a disastrous decision.</p>
<p><strong>Security:</strong> Building secure systems gives an assurance to users that their data is in safe hands. Data integrity and data durability are equally important. It is very similar to when you put your money in the bank. If you deposited one million dollars in the bank, you do not want to lose that money (Safe), you would want the bank to always say you deposited one million -no mistakes here (Integrity) and even after 10 years you go to the bank, you will still have that one million dollars money (Durability).</p>
<p>As you now got the basics right, let's look at important patterns one by one. No design pattern is a magic pill for all the issues. One needs to choose depending on the use case.</p>
<blockquote>
<p><strong>Scalability and Performance</strong></p>
</blockquote>
<ol>
<li><strong>CQRS:</strong> Command Query Responsibility Segregation is first introduced by <a href="https://twitter.com/gregyoung">Greg Young</a>. As the name suggests it is about segregating the write and read responsibilities. Write and read can happen from a single database or multiple databases. But the data model is different. CQRS easily fits into event sourcing architecture. Consume the events as and when they occur and write into “Write DB”. For display or reporting purposes read from the “Read DB”. To make this even more exciting, you may use normalized RDBMS for write and denormalized NoSQL DB for “Read”. Commands are typically queued for asynchronous process and a query can never modify a DB. One very good benefit is you can independently scale the DBs</li>
</ol>
<p><img src="architecture%5CReference/image-31.png" alt="Alt text" /></p>
<p>CQRS — Command Query Responsibility Segregation</p>
<blockquote>
<p><strong>Data Management, Security</strong></p>
</blockquote>
<p>2. <strong>Anti Corruption Layer pattern</strong>: This pattern was initially described by <a href="https://twitter.com/ericevans0">Eric Evans</a> in Domain-Driven Design (DDD). Let me introduce this with a story. Martin and Sheela work in a retail chain. Martin works in the customer order team and Sheela works in Loyalty Card team. From the DDD perspective, Martin and Sheela belong to two different domains and typically they do not interact with each other. One day Sheela wanted to make a change in her system. The change is to know the location of the customer so that she can offer additional loyalty points based on the location. However, she doesn't know Martin. Even if she knows, Martin may not agree to her change as he has to change his API. However, she knows that Srinivas is Martin’s manager. She approaches Srinivas to make the change. In this case, Srinivas is an Anti-Corruption Layer. This pattern is typically used when you have legacy systems and modern applications and you are in the journey to migrate. This layer contains all the logic that is required to translate the requests from modern systems. The biggest challenge in introducing this layer is, it will add one more hop for the user and adds to latency. A decision must be taken between speed vs. data.</p>
<p><img src="architecture%5CReference/image-32.png" alt="Alt text" /></p>
<p>Anti Corruption Layer</p>
<blockquote>
<p><strong>Resiliency, Fault Tolerance</strong></p>
</blockquote>
<p>3. <strong>Circuit Breaker Pattern:</strong> When you travel in flight, there is an oxygen mask and a life west, which is rarely paid attention to other than the air hostess who demonstrates passionately. The reason is very evident. These are used only when there is a failure. Your basic assumption is your flight will not fail, it is not required for you to use and so you will not pay attention. But this is not true for IT systems.</p>
<blockquote>
<p>“Everything fails all the time” — Werner Vogels, AWS CTO</p>
</blockquote>
<p>I am sure you heard about many famous websites being <a href="https://www.isitdownrightnow.com/">down</a> because of various reasons. In a distributed environment anything can fail at any time.</p>
<blockquote>
<p>As an architect, you can’t prevent failures. You can only design to handle the failures.</p>
</blockquote>
<p>Circuit breaker pattern prevents an application from performing an operation that is almost certain to fail. Let me explain this. Your system is suddenly experiencing load and there are more API requests than it can handle. For instance, service typical response time threshold is 5 second and now requests are taking more than that and your service starts sending 500 responses back. Keeping aside the bad experience to the user, your system might completely give up if there is more load beyond a certain point. Now it is time to stop more requests.</p>
<p>Let's compare this with how an electrical circuit breaker works. Did you ever encounter this? You just switched on a plug and your electricity is suddenly gone. Now you may need to go to your switchboard either in the basement or in your main hall and ON the switch that went off. This is where the circuit breaker is in action in the real world. What is this doing? As the load is high, the electricity was stopped to prevent further damage.</p>
<p>Lets now come back to our world. The circuit breaker pattern has three states. Closed, Open and Half Opened. In the closed state, everything is normal and your system works as it is intended. When there is an issue, the circuit breaker opens and data flow cuts off. This means that intended requested are not served to users. Half Open tries to test the waters after some wait time, to see if the problem still exists. If it is successful, state gets changed to closed so that system comes back to normal. If it is not successful, it will go back to open state.</p>
<p><img src="architecture%5CReference/image-33.png" alt="Alt text" /></p>
<p><strong>Circuit Breaker — Closed State</strong></p>
<p><img src="architecture%5CReference/image-34.png" alt="Alt text" /></p>
<p><strong>Circuit Breaker — Open State</strong></p>
<blockquote>
<p><strong>Scalability, Resiliency and Performance</strong></p>
</blockquote>
<p>4. <strong>Event Sourcing</strong>: This pattern became popular in recent days as data became new oil. This pattern suggests that, do not just store the state of an action but an entire history. Let’s say you are building a banking application. A customer will have multiple debits and credits in a period of time. Let's say the customer starts with $1000. On Day 1, she credits $50, on Day 2, she debits $100, on Day 3 she credits $150. At the end of day3, she will have $1100. However, in the case of Event Sourcing, you store all the transactions without losing a single action. When you have this data you can use for multiple purposes. While you can definitely tell what is her bank balance at any point of time by doing a quick calculation on the fly, you can also understand her banking patterns which otherwise not possible.</p>
<p><img src="architecture%5CReference/image-35.png" alt="Alt text" /></p>
<p>Event Sourcing</p>
<p>Let's look at one more example. You are building a movie ticket booking system. For a popular movie, you will see a lot of rush from the audience, which will cause scalability issues. Customer may book, cancel or hold the seats. Let's say the theatre has 200 seats. You need to constantly calculate available seats to make the number visible to the next customer. This is where event sourcing will be handy. Instead of calculating the available seats as a CRUD operation, you will go through all the events and finally arrive to a number.</p>
<blockquote>
<p><strong>Scalability, Resiliency, Fault Tolerance and Performance</strong></p>
</blockquote>
<p><strong>5. Publisher-Subscriber pattern</strong></p>
<p>This is popularly called as Pub/Sub pattern. In a cloud based system, modules of one system need to communicate with modules of same or another system asynchronously. Let me give an example. You are building a leave management system. Whenever an employee applies for a leave, you need to inform, Timesheet module, Scheduling module and Payroll module at the same time. This can be done with an async call. These modules just consume data. They will not validate the data. However, when an employee applies for leave, balance verification must be a sync call (typically a REST Api call), as an employee must not apply for leave when there are no balances (well, goes with HR policies of the organization)</p>
<p>One more example here. Imagine that you are a news sourcing company and you gather the news from various input mechanisms. Your end-users are newspapers and publishing companies. Then you capture the news on the ground and publish to your customers. If your customer is a sports magazine, they will only consume sports-related news or if your customer is a finance website, they will only use finance related to data. Your responsibility is to capture what is happening in the world without losing a single event. It is up to the customers to decide what they want to consume. You can also create <a href="https://en.wikipedia.org/wiki/Materialized_view#:~:text=In%20computing%2C%20a%20materialized%20view,summary%20using%20an%20aggregate%20function.">materialized views</a> for further consumption.</p>
<p><img src="architecture%5CReference/image-36.png" alt="Alt text" /></p>
<p>Pub Sub Pattern</p>
<p>Message brokers as mentioned in the picture best used for asynchronous communication. Whenever there is a need for resilient and fault-tolerant applications, Pub-Sub pattern comes handy. There are plenty of options for Message broker, <a href="https://kafka.apache.org/">Apache Kafka</a>, <a href="http://activemq.apache.org/">Apache Active MQ</a>, <a href="https://aws.amazon.com/kinesis/">AWS Kinesis</a>, <a href="https://www.ibm.com/in-en/products/mq">IBM MQ</a>. Apache Kafka is most popular, known for high performance and zero loss of data.</p>
<blockquote>
<p><strong>Scalability, Data Management and Performance</strong></p>
</blockquote>
<p><strong>6. Sharding Pattern:</strong> If you invest in stock market, it is a well-proven strategy that you will not put all your money in one single stock. You will create a portfolio of stocks and invest. With this approach, if one stock price goes down you still will have other stocks making some profits.</p>
<blockquote>
<p>Don't put all your eggs in a single basket.</p>
</blockquote>
<p>Sharding takes a similar approach. In this pattern, you will divide data into multiple partitions or shards. This massively improves the scalability. This pattern comes under horizontal scalability, not vertical scalability. What will happen if the data is stored in a single data store? Same as single stock in the above example. If the datastore goes down, your users will not be able to access the data causing lot of pain. Beyond a certain point, you will encounter storage issues, computing power, network and bandwidth issues. If you are servicing users in different locations, having one data store will add to latency issues.</p>
<p><img src="architecture%5CReference/image-37.png" alt="Alt text" /></p>
<p>Sharding improves the scalability, performance and fault tolerance. There are multiple ways to come up with sharding strategy. The strategy goes with your use case.</p>
<p><strong>Range-based Sharding:</strong> Suppose if you are storing customer data, you may look at storing based in pin code or zip code range. The disadvantage with this model is your customer data may not be equally distributed</p>
<p><strong>Vertical Sharding:</strong> If you are building an e-commerce application, you might store customer demographic details in one shard and customer buying transactions in another shard. This gives an opportunity for you to scale as you needed.</p>
<p><strong>Hash-based Sharding:</strong> This is a widely used strategy. If you have 5 shards to store customer data. You take for example customer unique id and apply modulo 5.</p>
<p>Some fun maths for you now.</p>
<blockquote>
<p>How to calculate Modulo 5 of any number. It is simple. Let’s say the number is 23. Divide this number by 5. You will get 4.6. Now take 4 and multiply by 5. You get 20. Now do 23–20, you will get 3. Thus, the answer to “What is 23 mod 5?” is <strong>3</strong>.</p>
</blockquote>
<p>Hash-based sharding will have challenges in long run. What if you would like to add one more shard after an year. You need to change the sharding logic and the capacity in the data store goes for a toss. The solution is <a href="https://en.wikipedia.org/wiki/Consistent_hashing">consistent hashing</a>.</p>
<blockquote>
<p><strong>Data Management</strong></p>
</blockquote>
<p><strong>7. Strangler Pattern:</strong> Wikipedia meaning of <a href="https://en.wiktionary.org/wiki/strangler">Strangler</a> is an epiphyte whose aerial roots eventually strangle the tree on which it grows. Today pretty much every organization is moving from monolithic to micros services. This journey is not going to be easy in any means. When you migrate to a new system from a legacy system, you systematically move the functionality to the new system instead of a big bang approach. If you are migrating a legacy monolithic application to cloud microservices application, this pattern comes handy. Eventually, when the migration is over, the user directly interacts with modern applications. In this pattern, the small functionalities (or micro services) that are built and getting migrated, eventually kills the main system. Find more details on this pattern from <a href="https://martinfowler.com/bliki/StranglerFigApplication.html">Martin Fowler’s</a> blog.</p>
<p><img src="architecture%5CReference/image-38.png" alt="Alt text" /></p>
<p>Strangler Pattern</p>
<blockquote>
<p><strong>Data Management, Security</strong></p>
</blockquote>
<p><strong>8. Saga Pattern:</strong> This is the best pattern to manage data consistency in a distributed system. Before the internet and WhatsApp, people used to travel to relatives and friends home personally and give marriage invitations. This is seen as inviting with respect. Anyways, keeping this aside, what if the marriage cancels by any chance? You do not want your relatives and friends to come on that day. The best way is you again travel to each person’s place and tell them that marriage got cancelled. (Not a positive example. But that's life). This is exactly Saga pattern. The first paper on Saga pattern was published in <a href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">1987</a>.</p>
<p>There are two ways to implement sagas pattern. Event/Choreography design and Command/Orchestration Sequencing Logic. Choreography design is very complicated. Lets look at Command/Orchestration Sequencing Logic. I will now take the example of flight booking application. This is the sequence when you book a flight.</p>
<ol>
<li>Select a seat (Seat Service)</li>
<li>Select Meal (Meal Service)</li>
<li>Pay for booking (Payment Service)</li>
<li>Available seats now get updated to deduct one seat (Booking Service)</li>
</ol>
<p><img src="architecture%5CReference/image-39.png" alt="Alt text" /></p>
<p>Saga Orchestrator</p>
<p>Let's look at the sequence of events:</p>
<ol>
<li><em>Booking Service</em> saves a available seat for user and asks Booking Saga Orchestrator (BSO) to start a Book seat transaction.</li>
<li><em>BSO</em> sends a “<strong><em>Do Payment”</em></strong> command to <em>Payment Service</em>, and it replies with a <strong><em>Payment Succesful</em></strong> message</li>
<li><em>BSO</em> sends a <strong><em>Confirm a seat</em></strong> command to Seat Service, and it replies with a <strong><em>Seat Confirmed</em></strong> message</li>
<li><em>BSO</em> sends a <strong><em>Book a meal</em></strong> command to Meal Service, and it replies with a <strong><em>Meal Confirmed</em></strong> message.</li>
</ol>
<p>Let's say payment service fails. You do not want to offer a free seat and a free meal for your customer. Now BSO sends a command to roll back the seat booking and meal booking. A very good and detailed explanation of Saga Pattern can be found <a href="https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/">here</a></p>
<blockquote>
<p><strong>Availablity, Resiliency</strong></p>
</blockquote>
<p><strong>9. Throttling Pattern:</strong> If you ever visited any famous <a href="https://www.tirumala.org/">Indian temples</a> on a good day, there will be 50K to 100K devotees. The Darshan time (time in front of God) lasts for just few seconds but they spend in the queue anywhere between 4 to 8 hours. Temple administration usually controls the crowd by putting them in small compartments with some seating facility. Lets says there are 20 compartments and one final queue before “darshan”. Around 200 people will fit in one compartment. As the time progresses, people move from compartment 1 to compartment 2 and so on until they hit the final queue. This is called Throttling.</p>
<p>When it comes to IT applications, most of the times load is predictable until unless there are some black swan events. E-commerce site gets more load during festive season or when there is a sale. For a banking system there may be more load during the time when the salary is getting credited. For a time capturing system, there will be peak load during morning, afternoon and evening time. One option to handle these peak loads is to auto scale the resources. Second option is to put a limit on the number of transaction that the system can process and start throttling the remaining transactions. With this, the SLAs are met and system continues to function as it is intended.</p>
<p><img src="architecture%5CReference/image-40.png" alt="Alt text" /></p>
<p>Throttling</p>
<blockquote>
<p><strong>Availablity, Performance</strong></p>
</blockquote>
<p><strong>10. Static content hosting pattern:</strong> On a typical website, the content that doesn't change is called static content. It is generally created using HTML, CSS and Javascript. Javascript is not mandatory, can also be done with just HTML and CSS(or <a href="https://en.wikipedia.org/wiki/Sass_(stylesheet_language)">Sass</a>). The dynamic website will have a logic to run on the web server and usually does CRUD operations on data which is not possible to be served by the static website. Dynamic websites depend on server-side processing, including server-side scripts such as PHP, JSP, or ASP.NET or Node.js. For example, you would like to know the price of a product before buying, you would like to pay your electricity bill, you want to post happy birthday on your friend’s timeline, or even complicated, you would like to implement your options strategy of a stock. All these require a dynamic website. With the emergence of AWS, Azure and Google cloud platform static hosting doesn’t need your own server to run. For example, you can host your static website on <a href="https://aws.amazon.com/s3/">Amazon S3</a> (Simple Storage Service) without a need to spin off a new server. in addition, you can speed up your site by using <a href="https://aws.amazon.com/cloudfront/">Cloudfront</a> which will store the files at the edge location close to users.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-software-architecture-styles-software-engineers-should-know-1"><a class="header" href="#12-software-architecture-styles-software-engineers-should-know-1">12 Software Architecture Styles Software Engineers Should Know</a></h1>
<p>A brief introduction to Microservice, SOA, Event-Driven, MicroKernel, Stream-Based, and more.</p>
<h1 id="what-is-software-architecture-1"><a class="header" href="#what-is-software-architecture-1">What is Software Architecture?</a></h1>
<p><strong><em>Software architecture</em></strong> is the process of defining the high-level structure and organization of a software system. It involves identifying and selecting the right components, deciding how they should interact with each other, and determining how they should be organized to achieve specific goals. The goal of software architecture is to create a system that is maintainable, scalable, and secure, and that can meet the needs of users and organizations over time.</p>
<h1 id="why-do-we-need-software-architecture-1"><a class="header" href="#why-do-we-need-software-architecture-1">Why do we need Software Architecture?</a></h1>
<p>A robust architecture provides a solid foundation for building software that meets the needs of users and stakeholders. It ensures that the system meets its functional and non-functional requirements, such as performance, security, and reliability. With a well-designed architecture, developers can build software that is easy to modify and extend, making it easier to adapt to changing business needs.</p>
<p>Software architecture is also essential for managing complexity. As software systems become more complex, it becomes challenging to understand how different components interact with each other. A well-designed architecture provides a high-level view of the system, making it easier to understand its structure and operation. This, in turn, helps developers to identify potential issues and make informed decisions about how to modify the system.</p>
<h1 id="how-do-we-document-architecture-we-use-4c-model-1"><a class="header" href="#how-do-we-document-architecture-we-use-4c-model-1"><strong>How do we Document Architecture? We use 4C Model.</strong></a></h1>
<h2 id="context-level-1"><a class="header" href="#context-level-1">Context Level</a></h2>
<p>At the highest level, the Context level, we describe the system’s external environment, such as users, other systems, regulations, etc. This level provides a high-level overview of the system’s purpose and its relationship to the external world. It helps to identify the stakeholders who will interact with the system and the factors that will influence its design and development.</p>
<h2 id="containers-level-1"><a class="header" href="#containers-level-1">Containers level</a></h2>
<p>The next level is the Containers level, which describes the runtime environment of the system, such as servers, databases, or message queues. This level helps to identify the major technology choices and deployment decisions. It provides an understanding of the physical infrastructure that will support the system and the tools and resources that will be required to deploy and maintain it.</p>
<h2 id="components-level-1"><a class="header" href="#components-level-1">Components level</a></h2>
<p>The third level is the Components level, which describes the major functional building blocks of the system. This level helps to identify the modules, classes, or functions that make up the system. It provides an understanding of the system’s functionality and the relationships between its different components.</p>
<h2 id="code-level-1"><a class="header" href="#code-level-1">Code level</a></h2>
<p>Finally, the Code level is the lowest level, which describes the actual code and how it implements the components. This level provides a detailed understanding of how the system works and how its different components interact with each other. It is essential for developers who will be working with the code to have a clear understanding of how it is structured and how it works.</p>
<p>Using the C4 model, software architects can create diagrams and written documentation that describe each of these levels, providing a comprehensive view of the system’s architecture. This approach helps to identify potential issues and trade-offs, as well as facilitating scalability, maintainability, and adaptability. By documenting the architecture in this way, developers and stakeholders can have a clear and easy-to-understand view of the system, making it easier to modify and extend as business needs change.</p>
<h1 id="here-are-the-12-software-architecture-styles-software-engineer-should-know-1"><a class="header" href="#here-are-the-12-software-architecture-styles-software-engineer-should-know-1">Here are the 12 Software Architecture Styles Software Engineer Should Know</a></h1>
<h2 id="1-client-server-1"><a class="header" href="#1-client-server-1">1. Client Server</a></h2>
<p>The client-server architecture is a model in which the client, a user or an application, sends a request to the server, which in turn responds with the requested data or service. The client and server can be on the same machine or on different machines connected through a network.</p>
<p>The client is responsible for initiating communication with the server and sending a request. The server, on the other hand, listens for incoming requests from clients, processes them, and returns a response.</p>
<blockquote>
<p><strong><em>Advantages of Client-Server Architecture</em></strong></p>
<p><strong><em>Scalability:</em></strong> Client-server architecture is highly scalable, as it allows multiple clients to connect to the same server and share resources.</p>
<p><strong><em>Security:</em></strong> Client-server architecture provides better security than other network models, as the server can control access to resources and data.</p>
<p><strong><em>Reliability:</em></strong> Client-server architecture is highly reliable, as the server can provide backup and recovery services in case of failures.</p>
</blockquote>
<h2 id="2-layering-1"><a class="header" href="#2-layering-1">2. Layering</a></h2>
<p>It’s a common way to design complex software systems, and it involves breaking down the system into layers, where each layer is responsible for a specific set of functions. This approach helps to organize code and makes it easier to maintain and modify the system over time.</p>
<blockquote>
<p><strong><em>A typical layering architecture consists of three main layers: presentation, business logic, and data access.</em></strong></p>
<p><strong>Presentation Layer:</strong> The presentation layer is responsible for displaying information to the user and gathering input. This layer includes the user interface and any other components that interact directly with the user. The user interface is what the user sees and interacts with, such as buttons, text boxes, and menus. The presentation layer also includes any logic related to the user interface, such as event handlers and validation.</p>
<p><strong>Business Logic Layer:</strong> The business logic layer is responsible for implementing the business rules of the application. This layer contains the code that processes and manipulates data, as well as any other application logic. The business logic layer is where the magic happens, so to speak. It’s where the software performs calculations, makes decisions, and carries out tasks. This layer is where the software really earns its keep.</p>
<p><strong>Data Access Layer:</strong> The data access layer is responsible for interacting with the database or other external data sources. This layer contains the code that reads and writes data to and from the database. The data access layer is where the software retrieves data from the database, makes changes to the data, and saves the changes back to the database. This layer is critical to the functioning of the software, as it enables the software to store and retrieve data.</p>
</blockquote>
<h2 id="3-pipe-and-filter-1"><a class="header" href="#3-pipe-and-filter-1">3. Pipe and Filter</a></h2>
<p>Pipe and Filter Architecture is a design pattern that allows software systems to process data by separating the processing tasks into multiple independent components. This architecture is particularly useful for systems that need to handle large amounts of data, as it can help to improve performance, scalability, and maintainability.</p>
<p>The Pipe and Filter Architecture is based on the idea of a pipeline, where data flows through a series of processing steps, each of which performs a specific task. Each processing step is implemented as a separate component, or filter, that accepts data as input, performs some operation on the data, and produces output data. The output data is then passed on to the next filter in the pipeline.</p>
<p>The filters in the pipeline are independent of each other, which means that they can be developed, tested, and deployed separately. This makes it easy to add new filters to the pipeline or modify existing ones without affecting the rest of the system.</p>
<blockquote>
<p><strong><em>Benefits</em></strong></p>
<p><strong>Scalability:</strong> The architecture can be scaled horizontally by adding more filters to the pipeline, which allows the system to handle larger amounts of data.</p>
<p><strong>Performance:</strong> The architecture can be optimized for performance by parallelizing the processing of data across multiple filters.</p>
<p><strong>Maintainability:</strong> The architecture promotes modularity and separation of concerns, which makes it easier to maintain and update the system over time.</p>
</blockquote>
<h2 id="4-master-slave-1"><a class="header" href="#4-master-slave-1">4. Master-Slave</a></h2>
<p>Master-Slave architecture is a design pattern used in distributed systems, where one node (the master) controls one or more nodes (the slaves) to perform specific tasks. The master node is responsible for distributing the workload across the slaves and for coordinating their activities. The slave nodes do not have the same level of control as the master node and only perform tasks that are assigned to them by the master.</p>
<blockquote>
<p><strong><em>Benefits</em></strong></p>
<p>One of the most significant advantages is that it allows for the efficient distribution of workload across multiple nodes. This helps to reduce the load on any one node and ensures that the system can handle large amounts of data and traffic.</p>
<p>Another advantage of using a master-slave architecture is that it provides fault tolerance. If one of the slave nodes fails, the master node can redistribute its workload to the other slave nodes. This ensures that the system can continue to function even if one or more nodes fail.</p>
</blockquote>
<h2 id="5-microkernel-1"><a class="header" href="#5-microkernel-1">5. MicroKernel</a></h2>
<p>MicroKernel architecture is a software design pattern that allows developers to build more modular and flexible systems. It separates the core system functionality from additional features, which are implemented in separate modules. The core functionality of the system is implemented in the MicroKernel, a minimalistic core system that provides only the most essential services required to run the system. It is plug and play concept.</p>
<blockquote>
<p><strong>Example:</strong></p>
<p>Let’s consider the example of an e-commerce website. The MicroKernel would provide essential services such as handling user authentication, managing user sessions, and processing payments. Additional features, such as product recommendations, user reviews, and social media integration, would be implemented in separate modules.</p>
<p>If the website wants to add a new feature, such as a loyalty program, it can be developed and added as a separate module without affecting the core functionality of the system. This modularity makes it easier to add new features or remove existing ones without affecting the core system functionality.</p>
<p>Furthermore, if the website wants to customize its system to meet the specific needs of different users, it can choose the modules it needs for each user. For example, a user who frequently buys electronics can be provided with a module that recommends electronic products. On the other hand, a user who frequently buys cosmetics can be provided with a module that recommends cosmetic products.</p>
<p>Finally, if the website wants to scale its system to handle more users or changes in hardware, it can easily add or remove modules as needed. This scalability makes it easier to adapt the system to changes in user requirements or changes in the underlying hardware.</p>
</blockquote>
<h2 id="6-ddd-domain-driven-design-1"><a class="header" href="#6-ddd-domain-driven-design-1">6. DDD (Domain Driven Design)</a></h2>
<p>At its core, DDD is a way of thinking about software architecture that emphasizes the domain or problem space of a project. This means that developers focus on the business logic of the software, rather than just the technical implementation.</p>
<p>In practice, this means that developers start by understanding the domain they are working in and break it down into smaller, more manageable parts. They then use this understanding to create a domain model, which is a representation of the different entities within the domain and how they interact with one another.</p>
<p>Once the domain model is created, developers can use it to guide the rest of the architecture of the software. This includes creating bounded contexts, which are areas of the software that are defined by a specific language and context, and aggregates, which are collections of related entities that are treated as a single unit.</p>
<h2 id="7-component-based-1"><a class="header" href="#7-component-based-1">7. Component Based</a></h2>
<p>In software engineering, component-based architecture (CBA) is an approach to software design and development that emphasizes the use of reusable software components. The idea behind CBA is that software development can be made more efficient and effective by breaking down complex systems into smaller, more manageable components.</p>
<blockquote>
<p><strong>What is a component?</strong></p>
<p>A software component is a modular, self-contained unit of software that can be reused across different systems. A component typically has a well-defined interface, which specifies how other components can interact with it. This interface includes information about the component’s inputs, outputs, and behavior.</p>
<p>Components can be classified into different types based on their functionality, such as user interface components, data access components, and business logic components. Each type of component has a specific role in the software system and can interact with other components through their interfaces.</p>
</blockquote>
<h2 id="8-soa-1"><a class="header" href="#8-soa-1">8. SOA</a></h2>
<p>SOA is an architectural style that aims to create modular, reusable services that can be easily integrated with other services to create a larger system. In this approach, services expose their functionality through interfaces, which can be accessed by other services or applications.</p>
<p>At its core, SOA is about building software by breaking it down into smaller pieces, or modules, that can be reused across different applications. This modular approach allows developers to focus on building specific pieces of functionality and then integrating them with other pieces to create a larger system.</p>
<blockquote>
<p><strong><em>Core Components of SOA</em></strong></p>
<p><strong>Service Provider:</strong> The service provider is responsible for creating and exposing services to the outside world. These services can be used by other services, applications, or end-users. For example, a payment processing service provider might create and expose a service that allows other applications to process payments.</p>
<p><strong>Service Registry:</strong> The service registry is a directory of available services that can be accessed by other services or applications. The service registry provides information about the service, such as its name, location, and interface. For example, if an application needs to process payments, it can use the service registry to find the payment processing service and access its interface.</p>
<p><strong>Service Requestor:</strong> The service requestor is responsible for consuming the services exposed by the service provider. This can be done by using the service registry to find the appropriate service and then invoking its interface. For example, an application might use the service registry to find the payment processing service and then use its interface to process payments.</p>
</blockquote>
<h2 id="9-monolithic-1"><a class="header" href="#9-monolithic-1">9. Monolithic</a></h2>
<p>Monolithic architecture is a software design pattern that has been around for decades. It’s a way of structuring an application as a single, cohesive unit, rather than splitting it up into individual, smaller components.</p>
<p>In a monolithic architecture, the entire application is built as a single, self-contained unit. All of the code and dependencies are packaged together, so the application can be deployed and run on a single server.</p>
<p>This makes it easy to develop and deploy the application, since everything is in one place. It also makes it easier to scale the application horizontally, by adding more servers.</p>
<blockquote>
<p><strong><em>Advantages of Monolithic Architecture</em></strong></p>
<p>One of the biggest advantages of monolithic architecture is its simplicity. Since everything is contained in a single unit, there are fewer moving parts to worry about. This makes it easier to develop, test, and deploy the application.</p>
<p>Another advantage is that it’s easier to maintain and debug a monolithic application. Since everything is in one place, it’s easier to track down issues and fix them.</p>
<p><strong><em>Disadvantages of Monolithic Architecture</em></strong></p>
<p>One of the biggest disadvantages of monolithic architecture is that it can be difficult to scale the application vertically. Since everything is running on a single server, there’s a limit to how much traffic the application can handle.</p>
<p>Another disadvantage is that it can be difficult to adopt new technologies and languages in a monolithic application. Since everything is packaged together, it can be hard to update individual components without breaking the entire application.</p>
</blockquote>
<h2 id="10-microservice-1"><a class="header" href="#10-microservice-1">10. Microservice</a></h2>
<p>Microservice architecture is a style of software architecture that structures an application as a collection of small, independent services that communicate with each other over a network. Each service is focused on a specific business capability and can be developed, deployed, and scaled independently of other services in the system.</p>
<p>The main idea behind microservice architecture is to break down a large, monolithic application into smaller, more manageable services. This approach brings several benefits, such as improved scalability, increased flexibility, and quicker time-to-market for new features. With a microservice architecture, each service can be scaled independently, making it easier to handle traffic spikes or changes in demand. Developers can also modify or add new services without affecting other parts of the system, which speeds up the development process.</p>
<blockquote>
<p><strong><em>Challenges of Microservice Architecture</em></strong></p>
<p>Despite the benefits of microservice architecture, it also introduces additional complexity. One of the biggest challenges is managing inter-service communication. Services need to be able to discover each other and communicate effectively, which can be difficult to do at scale. Load balancing and fault tolerance are also more complex in a microservice architecture.</p>
<p>Another challenge is ensuring that each service has its own data store. In a monolithic application, all data is typically stored in a single database. With microservices, each service should have its own data store to ensure that changes to one service do not affect other services in the system. This can lead to increased complexity in data management and synchronization.</p>
<p><strong><em>Best Practices for Microservice Architecture</em></strong></p>
<p>To ensure the success of a microservice-based system, developers should follow best practices for designing and implementing microservices. Some of these best practices include:</p>
<p>1. Design services that are loosely coupled and highly cohesive, with clear boundaries and well-defined interfaces.</p>
<p>2. Use containerization technology, such as Docker, to package and deploy each service as a separate container. This allows for easy scaling and deployment of individual services as needed.</p>
<p>3. Implement effective monitoring and management tools to ensure that the system is running smoothly and to detect and address issues quickly.</p>
<p>4. Use a service mesh, such as Istio, to manage inter-service communication and load balancing.</p>
<p>5. Implement a continuous integration and deployment (CI/CD) pipeline to automate the testing and deployment of microservices.</p>
</blockquote>
<h2 id="11-event-driven-1"><a class="header" href="#11-event-driven-1">11. Event Driven</a></h2>
<p>Event Driven Architecture (EDA) is an approach to designing software systems that enables rapid and efficient communication between different components or services. In this paradigm, different software components communicate with each other using events, rather than through direct requests or responses.</p>
<p>In EDA, events are generated by different components of a software system, such as a user interface or a backend service. These events are then broadcast to other components of the system, which can subscribe to them and act on them as needed.</p>
<p>For example, consider a simple e-commerce application. When a new order is placed, the order processing service can generate an “order created” event, which is then broadcast to other services such as inventory management, shipping, and billing. Each of these services can then process the event and make updates to their respective systems.</p>
<blockquote>
<p><strong><em>Benefits of EDA</em></strong></p>
<p>One of the key benefits of EDA is its ability to decouple different components of a software system. When different components communicate through events rather than direct requests, they become less dependent on each other. This makes it easier to change or update individual components of the system without affecting the rest of the system.</p>
<p>Another benefit of EDA is its scalability. Because events are broadcast to multiple components of the system, it is possible to process large volumes of data and transactions in parallel. This makes it easier to handle high traffic and spikes in demand.</p>
<p><strong><em>Challenges of EDA</em></strong></p>
<p>While EDA has many benefits, it also has some challenges. One of the main challenges is managing the complexity of event-driven systems. Because events can be generated and consumed by many different components, it can be difficult to track and debug issues that arise.</p>
<p>Another challenge is ensuring that events are processed in the correct order. Because events can be generated and processed asynchronously, it is possible for events to be processed out of order. This can cause issues such as data inconsistencies or incorrect calculations.</p>
</blockquote>
<h2 id="12-stream-based-1"><a class="header" href="#12-stream-based-1">12. Stream Based</a></h2>
<p>As software development becomes more complex and demands greater scalability, traditional architectures are becoming less and less effective. Stream-based architecture is emerging as a promising alternative that enables developers to build systems that can handle massive amounts of data in real-time.</p>
<p>At its core, stream-based architecture is based on the principles of event-driven programming. Instead of processing data in batches, stream-based systems process data as it is generated in real-time. This allows developers to build systems that can respond to changes in data with minimal latency.</p>
<blockquote>
<p><strong><em>Benefit of Stream-Based Architecture</em></strong></p>
<p>One of the key benefits of stream-based architecture is its scalability. Because data is processed in real-time, stream-based systems can handle massive amounts of data without the need for complex batch processing pipelines. This makes it possible to build systems that can process millions of events per second, making it ideal for use cases like sensor data processing, financial trading, and online advertising.</p>
<p>Another benefit of stream-based architecture is its flexibility. Because data is processed in real-time, it is possible to build systems that can respond to changes in data with minimal latency. This makes it possible to build complex, event-driven systems that can adapt to changing business requirements. For example, in an e-commerce platform, stream-based architecture can be used to track user activity in real-time and respond with personalized recommendations and promotions based on the user’s browsing and purchasing history.</p>
<p>Furthermore, stream-based architecture can provide significant cost savings. Traditional batch processing pipelines require expensive hardware and complex software infrastructure to manage the data processing. On the other hand, stream-based systems can be built on inexpensive commodity hardware, making it much easier to scale and maintain.</p>
<p>Finally, stream-based architecture is highly fault-tolerant. Because data is processed in real-time, it is possible to build systems that can automatically recover from failures without the need for manual intervention. This makes it possible to build systems that can operate at scale with high levels of reliability, reducing the risk of data loss or system downtime.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23-fundamental-principles-in-software-architecture"><a class="header" href="#23-fundamental-principles-in-software-architecture">23 Fundamental Principles in Software Architecture</a></h1>
<p><img src="architecture%5CReference/image-53.png" alt="Alt text" /></p>
<p>Software Architecture bases on set of basic principles that is actual for every kind of software system. Experienced Software Architects are aware of them and able to spot the right places in their software products to implement specific principle. Let us have a quick overview over some basic principles that Software Architects deals with on daily basis:</p>
<p><strong><em>1.Dependency Inversion…</em></strong> This principle states that direction of dependency should be towards abstraction not implementation. If compile-time dependency flows in direction of run-time execution this makes directed dependency. With Dependency Inversion we invert the direction of dependency control.</p>
<p><strong><em>2.Separation of Concerns…</em></strong> This principle states that a software system should be separated by the kind of work it does. For Example: It is noteworthy to separate the software system into different pieces by business logic, infrastructure or user interface. By splitting the system into different parts based on different activity areas makes it easier to develop/test/deploy. SoC is a driving force behind Software Architecture Patterns like Domain Driven Design, Hexagonal Architecture, Clean Architecture.</p>
<p><strong><em>3.Inversion of Control…</em></strong></p>
<p>This principle is similar to Dependency Inversion Principle but in broader context. IoC inverts the flow of control which is managed by different third party frameworks such as Spring Framework. Unlike traditional Java EE programs where Beans are initialized procedurally by the engineer that developed it, Spring takes control of Configuration Beans, which means inverting the control.</p>
<p><strong><em>4.Dependency Injection…</em></strong></p>
<p>This Principle states that for example in java terms: dependency should be injected through constructor in run-time. Action Interface is injected in Human class through its HumanAction Implementation, that decides in run-time which specific action to implement. This technique gives some flexibility of dependencies:</p>
<pre><code class="language-java">package az.alizeynalli.di;

public interface Action {
    void do();
}

public class HumanAction implements Action {
 
    @Override
    public void do() {
        System.out.print(&quot;run&quot;);
    }
}

public class Human  {
     
    Action action;
     
    public Human(Action action) {
        this.action = action;
    }
 
    @Override
    public void do() {        
        actoin.do();        
    }
}

    public static void main(String[] args) {
        Human human = new Human(new HumanAction);
        human.do();
    }
</code></pre>
<p><strong><em>5.Single Responsibility…</em></strong></p>
<p>This principle’s main idea is to limit each building block of a software system by one and only responsibility. No matter what is the scope of a building block, be it plugin, package, class, function even a variable. Each of these building blocks should have only one responsibility. </p>
<p><strong><em>6.Don’t Repeat Yourself (DRY)…</em></strong></p>
<p>This principle aims to eliminate redundancy in code by avoiding duplicate code. If there is existing functionality for some behaviour this should be repeatedly used, instead of having same code snippet in multiple instances.</p>
<blockquote>
<p>Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.</p>
</blockquote>
<p><strong><em>7.Open-Closed…</em></strong></p>
<blockquote>
<p><em>A Software artifact should be open for extension but closed for modification.</em></p>
</blockquote>
<p>This simple description of the principle was firstly introduced by Bertrand Meyer. Software system that needs modification each time for any additional functionality is just a big mess. On the other hand, this kind of chaotic program is welcoming occasional bugs every time modification is made. Preferably, every new functionality should be maximum of new code and minimum of change in old code, in ideal world: zero changes in old code.</p>
<p><strong><em>8.Persistence Ignorance…</em></strong></p>
<p>PI bases on the idea that code should be unaffected by whichever database or persistence technology is chosen. Business Logic should be free of any technology chosen to be applied. If tomorrow, there is better alternative persistence technology which is more effective and for better price, changing this part of software system should not affect upper abstraction layers.</p>
<p><strong><em>9.YAGNI…</em></strong></p>
<p>You ain’t gonna need it. This principle tries to avoid premature optimization of a software system. Often developers overengineer some things in a software system with the vision that some time in future it will be helpful. But this time often never comes.</p>
<p><strong><em>10.Boy Scout Rule…</em></strong></p>
<blockquote>
<p>Always leave the campground cleaner than you found it.</p>
</blockquote>
<p>The main idea here is to always keep refactoring code as you encounter anti-patterns while developing further. This leads to better code quality over time.</p>
<p><strong><em>11.Liskov-Subsititution…</em></strong></p>
<blockquote>
<p><em>If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behaviour of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</em></p>
</blockquote>
<p>This definition from Barbara Liskov might sound pretty confusing but in essence, it is a simple and easy to understand principle. If we restate the above given definition, the principle’s motto is: when using inheritance, hierarchy of inheritance should be from functional and business logic aspect consistent. The subtypes should be mutually substitutable and not alter behavior of parent class. As a simple example we can take <em>“infamous square/rectangle”</em> problem. Where square should not be subtype of rectangle, because definition of height and length of these two geometric forms are different (square’s height and weight are equal whereas for rectangle they will vary).</p>
<p><strong><em>12.Encapsulation…</em></strong></p>
<p>Different building blocks of a Software System should make use of Encapsulation by restricting access to its components from outside world. This achieved by setting components private in a class scope or setting access restrictions in plugin scope (in terms of java) so hiding information.</p>
<p><strong><em>13.Loose Coupling…</em></strong></p>
<p>One of the most important principles in Software Architecture is Loose Coupling which means simply put loose dependencies. This principle states that software systems should be loosely dependent on each other. If one part of software systems changes, this should influence other parts minimally. Loose Coupling is possible through Dependency Inversion, Asynchronous Messaging Middleware, Event Sourcing etc. </p>
<p><strong><em>14. Cohesion…</em></strong></p>
<blockquote>
<p>Cohesion refers to the degree to which the elements inside a module belong together. In one sense, it is a measure of the strength of relationship between the methods and data of a class and some unifying purpose or concept served by that class.</p>
</blockquote>
<p>It is a best practice to have highly cohesive classes, which motivates single responsibility principle, loose coupling etc.</p>
<p><strong><em>15. Interface Segregation…</em></strong></p>
<blockquote>
<p><strong><em>Interface-Segregation Principle</em></strong> <em>states that no client should be forced to depend on methods it does not use.</em></p>
</blockquote>
<p>We should make it clear that, this principle is applicable mostly to statically-typed programming languages like Java, C etc. In dynamically typed languages like Python or Ruby this principle does not make a big sense.</p>
<p>We can imagine a situation that our Income and Expense Use Cases are dependent on a functionality that holds business logic for both cases. So Income Use Case has an abundant dependency on a functionality that is used for Expense Use Case and Expense Use Case has the same issue in respect to Income Use Case. Following is the Violation of ISP based on above discussion:</p>
<pre><code class="language-java">package az.alizeynalli.cashflow.core.service;

public interface ConverterService {
    Income convertIncome(Income income);
    Expense convertExpense(Expense expense);
}

@Component
public class ExpenseConverterServiceImpl implements ConverterService {

    @Override
    public Income convertIncome(Income income) {
        throw new UnsupportedOperationException();
    }

    @Override
    public Expense convertExpense(Expense expense) {
        // convert expense here
        return expense;
    }
}

@Component
public class IncomeConverterServiceImpl implements ConverterService {

    @Override
    public Income convertIncome(Income income) {
        // convert income here
        return income;
    }

    @Override
    public Expense convertExpense(Expense expense) {
        
        throw new UnsupportedOperationException();
    }
}
</code></pre>
<p><strong><em>16. Bounded Context…</em></strong></p>
<blockquote>
<p>Bounded contexts are a central pattern in Domain-Driven Design. They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules. Each conceptual module then represents a context that is separated from other contexts (hence, bounded), and can evolve independently. Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store. </p>
</blockquote>
<p><strong><em>17.Stable Dependencies…</em></strong></p>
<p>This principle states that different building blocks of a software system should only depend on artifacts that reliable, stable. This principle makes more sense in docker image terms, where you import different dependencies from docker hub without even knowing how reliable/stable are they.</p>
<p><strong><em>18. Polymorphism…</em></strong></p>
<p>This actually belongs to 4 Pillars of Object Oriented Programming and motivates usage of interfaces (in java terms!) which can be provisioned in multiple forms. Polymorphism means: entity with multiple forms.</p>
<p><strong><em>19. Modularization…</em></strong></p>
<p>Modularization is the process of dividing a software system into multiple independent modules where each module works independently. This principle is another form of single responsibility separation of concerns principles applied to the static structure of a software system.</p>
<p><strong><em>20. Abstraction…</em></strong></p>
<p>This also belongs to 4 Pillars of Object Oriented Programming and states:</p>
<blockquote>
<p>The process of removing physical, spatial, or temporal details or attributes in the study of objects or systems to focus attention on details of greater importance; it is similar in nature to the process of generalization;</p>
</blockquote>
<p><strong><em>21. Keep It Simple, Stupid (KISS)…</em></strong></p>
<p>As it is understandable from the above statement this principle motivates software engineers to keep the code simple and stupid(understandable) to avoid potential future misunderstandings from other peer engineers.</p>
<p><strong><em>22. Incremental/Iterative Approach…</em></strong></p>
<p>This principle is basics of Agile Software Development Manifesto, that bases on the idea that software system should be developed on incremental and iterative manner. That means with every iteration software system is incremented and gone live.</p>
<p><strong><em>23. Least Knowledge…</em></strong></p>
<p>Or information envying is another term to encapsulation or information hiding principles which states that different parts of software system should only have knowledge that they need.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-architecture-design-patterns--you-wish-you-knew-before-interview"><a class="header" href="#7-architecture-design-patterns--you-wish-you-knew-before-interview">7 Architecture Design Patterns — You wish you knew before interview</a></h1>
<p><img src="architecture%5CReference/image-52.png" alt="Alt text" /></p>
<p>If you landed on this blog, I believe you know what modern architecture design patterns are. But for some of our less experienced friends here, think of architecture design patterns as the way you design your application(s) such that they scale and don’t need your resignation for that.</p>
<blockquote>
<p>Architecture Design Patterns, in a nutshell, are design patterns for High Level Design.</p>
</blockquote>
<p>Modern problems demand modern solutions. For applications to cater to enterprises or even an internet-level audience, they need to be scalable, available, secure, and resilient. Without a doubt, all major league companies are looking for developers who can grasp and solve these difficulties.</p>
<p>The question now is: how do developers solve these problems? One way is to follow good architectural design patterns. Here I present you 7 deadly Sins:-</p>
<h1 id="circuit-breaker-pattern"><a class="header" href="#circuit-breaker-pattern">Circuit Breaker Pattern</a></h1>
<p>Michael Nygard’s book, <a href="https://pragprog.com/titles/mnee2/">Release It!</a>, popularized the Circuit Breaker pattern, which can prevent an application from continually attempting to execute an action that is likely to fail, allowing it to proceed without waiting for the problem to be corrected or spending CPU cycles while determining the fault’s duration.</p>
<p>The Circuit Breaker pattern also allows an application to determine whether or not the issue has been remedied. If the problem appears to be resolved, the program can attempt to perform the operation.</p>
<blockquote>
<p>The Circuit Breaker pattern serves a distinct purpose than the Retry pattern. The Retry pattern allows an application to retry an operation in the hope that it will succeed the next time.</p>
</blockquote>
<p>The Circuit Breaker design prohibits an application from doing a risky activity. An application can use the Retry pattern to trigger an action through a circuit breaker to combine these two patterns. The retry logic, on the other hand, should be alert to any exceptions supplied by the circuit breaker and should cease repeat attempts if the circuit breaker indicates that a fault is not temporary.</p>
<p><img src="architecture%5CReference/image-51.png" alt="Alt text" /></p>
<h1 id="event-sourcing-pattern"><a class="header" href="#event-sourcing-pattern">Event Sourcing Pattern</a></h1>
<p>Most apps operate with data, and the common method is for the program to keep the data in its present state by updating it when users interact with it. In the classic create, read, update, and delete (CRUD) architecture, for example, a typical data operation is to receive data from the store, make some changes to it, and then update the current state of the data with the new values— often by utilizing transactions that lock the data.</p>
<p>The Event Sourcing design defines a method for handling data activities that are triggered by a series of events, each of which is recorded in an append-only store. Application code delivers a series of events to the event store, where they are persisted, that must describe each action that has occurred on the data. Each event describes a collection of data changes (for example, <em>&quot;AddedItemToOrder&quot;</em>).</p>
<p><img src="architecture%5CReference/image-50.png" alt="Alt text" /></p>
<p>The events are saved in an event store, which serves as the system of record (the official data source) for the data’s present state. These events are often published by the event retailer so that consumers are aware and can handle them if necessary. Consumers may, for example, start tasks that apply the operations in the events to other systems, or they could execute any other associated action required to finish the process. It’s worth noting that the application code that generates the events is separate from the systems that subscribe to them.</p>
<h1 id="sidecar-pattern"><a class="header" href="#sidecar-pattern">SideCar Pattern</a></h1>
<p>Monitoring, logging, configuration, and networking services are frequently required by applications and services. These extraneous chores might be carried out as distinct components or services.</p>
<p>A sidecar service is not always part of the application, but it is linked to it. It follows the parent application everywhere it goes. Sidecars are procedures or services that are delivered alongside the principal application. The sidecar on a motorbike is coupled to one motorcycle, and each motorcycle can have its own sidecar. A sidecar service, similarly, mirrors the fate of its parent application. A sidecar instance is deployed and hosted alongside each instance of the application.</p>
<p><img src="architecture%5CReference/image-49.png" alt="Alt text" /></p>
<p>They can execute in the same process as the application if they are tightly integrated, making optimal use of shared resources. This, however, implies that they are not properly separated, and a failure in one of these components can affect other components or the entire application. Furthermore, they must normally be written in the same language as the parent program. As a result, the component and the application are highly dependent on one another.</p>
<h1 id="cqrs"><a class="header" href="#cqrs">CQRS</a></h1>
<p>CQRS stands for Command and Query Responsibility Segregation, a pattern that isolates data store read and update processes. CQRS implementation in your application can improve its performance, scalability, and security. The flexibility gained by moving to CQRS enables a system to evolve more effectively over time and prevents update instructions from triggering merge conflicts at the domain level.</p>
<p><img src="architecture%5CReference/image-48.png" alt="Alt text" /></p>
<p>Separate query and update models make design and implementation easier. although, CQRS code cannot be automatically generated from a database schema using scaffolding techniques such as O/RM tools (although, you can add your customised on top of the generated code).</p>
<p>You can physically split the read and write data for more isolation. In that instance, the read database can utilise its own query-optimized data schema. It can, for example, store a materialised view of the data to avoid complex joins or O/RM mappings. It may even employ a different sort of data storage. For example, the write database could be relational, and the read database could be a document database.</p>
<h1 id="rate-limiting-pattern"><a class="header" href="#rate-limiting-pattern">Rate Limiting Pattern</a></h1>
<p>To prevent excessive resource consumption, some services impose limits on how fast other applications or services can access them. This is called throttling. You can use a rate limiting pattern to reduce or avoid throttling errors caused by these limits and to estimate throughput more accurately.</p>
<p>A rate-limiting pattern can be useful in many situations, but it is especially helpful for large-scale repetitive automated tasks such as batch processing.</p>
<p>By limiting the amount of records supplied to a service during a specific time, rate limiting can lower your traffic and possibly increase throughput.</p>
<p>Various measures may be used to throttle a service over time, including:</p>
<p>— the quantity of actions (60 requests, for instance).<br />
— the volume of data (50 GB per minute, for instance).<br />
— the relative expense of operations (42,000 RUs per second, for instance).</p>
<p>Regardless of the metric employed for throttling, the rate limiting approach you choose will include regulating the volume and/or size of operations delivered to the service over a predetermined time frame in order to maximize your use of the service without going over the throttling limit.</p>
<h1 id="strangler-fig"><a class="header" href="#strangler-fig">Strangler Fig</a></h1>
<p>Migrate a legacy system incrementally by gradually replacing certain functionalities with new apps and services. The old system is eventually choked by the new system, which eventually replaces all of the features of the legacy system, enabling you to decommission it.</p>
<p>Replace specific functionalities in stages with fresh software and services. Make a façade that catches requests headed for the legacy backend system. These requests are forwarded by the façade to either the new services or the legacy application. Customers can use the same interface while existing functionality are progressively moved to the new system, completely ignorant of the transition.</p>
<p><img src="architecture%5CReference/image-47.png" alt="Alt text" /></p>
<p>This method helps spread out the development work across time and reduce migration risk. You may add functionality to the new system at any rate you like while ensuring the legacy application continues to work because the façade safely directs users to the appropriate application. The legacy system gradually becomes “strangled” and is no longer required over time as features are transferred to the new system. After finishing this procedure, the legacy system can be safely retired.</p>
<p><strong>Health Endpoint Monitoring Pattern</strong></p>
<p>The Health Endpoint Monitoring pattern can be used to ensure that programmes and services are operating properly. This pattern outlines how functional checks should be used in an application. Through open endpoints, external tools have regular access to these checks.</p>
<p>Sending requests to an endpoint on your application will enable health monitoring. After running all essential tests, the programme should indicate its state.</p>
<p>Usually, a health monitoring check combines two elements:</p>
<p>When a request is made to a health verification endpoint, the application or service executes checks, if any.<br />
The evaluation of the outcomes by the system or tool that conducts the health verification check<br />
The response code indicates the application’s status. The status of the app’s components and services may optionally be provided in the response code. The latency or reaction time check is carried out by the monitoring tool or framework.</p>
<p>The pattern is seen in the following figure.</p>
<p><img src="architecture%5CReference/image-46.png" alt="Alt text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-branching-methodologies"><a class="header" href="#git-branching-methodologies">Git Branching Methodologies</a></h1>
<h2 id="trunk-based-development-flow"><a class="header" href="#trunk-based-development-flow">Trunk Based Development Flow</a></h2>
<pre><code class="language-mermaid">gitGraph TB:
  commit id: &quot;1&quot;
  commit id: &quot;2&quot;
  branch &quot;Feature 1&quot;
  checkout &quot;Feature 1&quot;
  commit id: &quot;3&quot;
  checkout main
  branch &quot;Feature 2&quot;
  commit id: &quot;4&quot;
  checkout &quot;Feature 2&quot;
  commit id: &quot;5&quot;
  checkout main
  branch &quot;Feature 3&quot;
  checkout &quot;Feature 3&quot;
  commit id: &quot;5&quot;
  checkout main
  merge &quot;Feature 3&quot;
  checkout &quot;Feature 2&quot;
  merge main
  checkout &quot;Feature 1&quot;
  merge main
  commit id: &quot;6&quot;
  checkout &quot;Feature 2&quot;
  commit id: &quot;7&quot;
  commit id: &quot;8&quot;
  checkout &quot;Feature 1&quot;
  commit id: &quot;9&quot;
  checkout main
  merge &quot;Feature 1&quot;
  checkout &quot;Feature 2&quot;
  merge main
  commit id: &quot;10&quot;




</code></pre>
<h2 id="gitflow"><a class="header" href="#gitflow">GitFlow</a></h2>
<pre><code class="language-mermaid">gitGraph TB:
  commit id: &quot;1&quot;
  commit id: &quot;2&quot;
  branch develop
  checkout develop
  commit id: &quot;3&quot;
  commit id: &quot;4&quot;
  checkout main
  merge develop id: &quot;5&quot; tag: &quot;v1.0&quot;
  checkout develop
  commit id: &quot;6&quot;
  branch feature-A
  checkout feature-A
  commit id: &quot;7&quot;
  checkout develop
  commit id: &quot;8&quot;
  checkout main
  merge feature-A id: &quot;9&quot; tag: &quot;v1.1&quot;
  checkout develop
  commit id: &quot;10&quot;
  branch release-1.0
  checkout release-1.0
  commit id: &quot;11&quot;
  checkout main
  merge release-1.0 id: &quot;12&quot; tag: &quot;v1.0.1&quot;
  checkout develop
  merge release-1.0 id: &quot;13&quot;
  commit id: &quot;14&quot;
  branch hotfix-1.0.2
  checkout hotfix-1.0.2
  commit id: &quot;15&quot;
  checkout main
  merge hotfix-1.0.2 id: &quot;16&quot; tag: &quot;v1.0.2&quot;
  checkout develop
  merge hotfix-1.0.2 id: &quot;17&quot;
  commit id: &quot;18&quot;

</code></pre>
<h2 id="github-flow"><a class="header" href="#github-flow">GitHub Flow</a></h2>
<pre><code class="language-mermaid">gitGraph
  commit id: &quot;1&quot;
  commit id: &quot;2&quot;
  commit id: &quot;3&quot;
  commit id: &quot;4&quot;
  commit id: &quot;5&quot;
  commit id: &quot;6&quot;
  commit id: &quot;8&quot;
  commit id: &quot;9&quot;
  commit id: &quot;10&quot;
  commit id: &quot;12&quot;
  commit id: &quot;13&quot;
  commit id: &quot;14&quot;
  commit id: &quot;15&quot;
  main --&gt; main: Merge feature-A
  main --&gt; main: Merge feature-B
  main --&gt; main: Merge hotfix-1.0.1


</code></pre>
<h2 id="gitlab-flow"><a class="header" href="#gitlab-flow">GitLab Flow</a></h2>
<pre><code class="language-mermaid">
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-architecture-the-most-important-architectural-patterns-you-need-to-know"><a class="header" href="#software-architecture-the-most-important-architectural-patterns-you-need-to-know">Software Architecture: The Most Important Architectural Patterns You Need to Know</a></h1>
<h2 id="explaining-common-different-architecture-patterns"><a class="header" href="#explaining-common-different-architecture-patterns">Explaining <strong>common</strong> different <strong>architecture patterns</strong></a></h2>
<p>[</p>
<p>An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context.</p>
<blockquote>
<p>A pattern is a solution to a problem in a context.</p>
</blockquote>
<p>Many programmers are nowadays still confused about the difference between architecture patterns or don’t even know much about it.</p>
<p>Let me explain to you…!</p>
<ul>
<li>Layered Architecture</li>
<li>Pipe and Filter</li>
<li>Client Server</li>
<li>Model View Controller</li>
<li>Event Driven Architecture</li>
<li>Microservices Architecture</li>
</ul>
<h1 id="layered-architecture"><a class="header" href="#layered-architecture"><strong>Layered Architecture</strong></a></h1>
<p>The most common architecture pattern is the layered architecture or known as the n-tier architecture. It is widely known by most software architects, designers, developers. Although, there are no specific restrictions in terms of the number and type of layers that must exist, most layered architecture consists of four tiers: presentation, business, persistence and database as follows.</p>
<p><img src="architecture%5CReference/image-15.png" alt="Alt text" /></p>
<p>an popular example of n-tier architecture</p>
<h2 id="context-1"><a class="header" href="#context-1"><strong>Context</strong></a></h2>
<p>All complex systems experience the need to develop and evolve portions of the system independently. For this reason, the developers of the system need clear and well-documented separation of concerns, so that modules of the system may be independently developed and maintained.</p>
<h2 id="problem"><a class="header" href="#problem"><strong>Problem</strong></a></h2>
<p>The software needs to be segmented in such a way that the modules can be developed and evolved separately with little interaction among the parts, supporting portability, modifiability, and reuse.</p>
<h2 id="solution"><a class="header" href="#solution"><strong>Solution</strong></a></h2>
<p>To achieve this separation of concerns, the layered pattern divides the software into units called layers. Each layer is a grouping of modules that offers a cohesive set of services. The usage must be unidirectional. Layers completely partition a set of software, and each partition is exposed through a public interface.</p>
<ul>
<li>The first concept is each of the layers has a specific role and responsibility. For example, the presentation layer would be responsible for handling all UI. Because this separation of concerns within the layered architecture makes it easy to build effective roles and responsibility.</li>
<li>On the second concept, the layered architecture pattern is a technically partitioned architecture as opposed to a domain partitioned architecture. They are groups of components, rather being by domain.</li>
<li>The last concept is that each of the layers in the layered architecture is marked as being either closed or open. A closed layer means that a request moves from layer to layer, it must go through the layer right below it to get to the next layer below that one. The request cannot skip any layers.</li>
</ul>
<p><img src="architecture%5CReference/image-16.png" alt="Alt text" /></p>
<p><em>Closed layers and request access</em></p>
<h2 id="weakness"><a class="header" href="#weakness">Weakness</a></h2>
<p>Layers contribute to a performance penalty. The pattern does not lend itself to high-performance applications because it is not efficient to go through multiple layers of the architecture to fulfill a business request.</p>
<p>The addition of layers also adds up-front cost and complexity to a system.</p>
<h2 id="usages"><a class="header" href="#usages">Usages</a></h2>
<p>We should use this style for small, simple applications or websites. It is a good choice for situations with a very tight budget and time constraints.</p>
<h1 id="multi-tier-pattern"><a class="header" href="#multi-tier-pattern">Multi-Tier Pattern</a></h1>
<h2 id="context-2"><a class="header" href="#context-2">Context</a></h2>
<p>In a distributed deployment, there is often a need to distribute a system’s infrastructure into distinct subsets.</p>
<h2 id="problem-1"><a class="header" href="#problem-1">Problem</a></h2>
<p>How can we split the system into a number of computationally independent execution structures: groups of software and hardware connected by some communications media?</p>
<h2 id="solution-1"><a class="header" href="#solution-1">Solution</a></h2>
<p><img src="architecture%5CReference/image-17.png" alt="Alt text" /></p>
<p>a multi-tier example — consumer website J2EE</p>
<p>The execution structures of many systems are organized as a set of logical groupings of components. Each grouping is termed a tier.</p>
<h2 id="weakness-1"><a class="header" href="#weakness-1">Weakness</a></h2>
<p>Substantial up-front cost and complexity.</p>
<h2 id="usages-1"><a class="header" href="#usages-1">Usages</a></h2>
<p>Used in distributed systems.</p>
<h1 id="pipe-and-filter"><a class="header" href="#pipe-and-filter">Pipe and Filter</a></h1>
<p>One of the patterns in software architecture that appears, again and again, is the pipe-filter pattern.</p>
<p><img src="architecture%5CReference/image-18.png" alt="Alt text" /></p>
<p>the pipe filter style</p>
<h2 id="context-3"><a class="header" href="#context-3">Context</a></h2>
<p>Many systems are required to transform streams of discrete data items, from input to output. Many types of transformations occur repeatedly in practice, and so it is desirable to create these as independent, reusable parts.</p>
<h2 id="problem-2"><a class="header" href="#problem-2">Problem</a></h2>
<p>Such systems need to be divided into reusable, loosely coupled components with simple, generic interactionmechanisms. In this way they can be flexibly combined with each other. The components, being generic and loosely coupled, are easily reused. The components, being independent, can execute in parallel.</p>
<h2 id="solution-2"><a class="header" href="#solution-2">Solution</a></h2>
<p>Pipes in this architecture form the communication channel between filters. The first concept is each of the pipes is un-directional and point to point for performance reasons, accepting input from one source and always directing output to another.</p>
<p>There are four types of filters exist within this style as follows.</p>
<ul>
<li>producer (<code>source</code>): the starting point of a process.</li>
<li>transformer (<code>map</code>): performs a transformation on some or all of the data.</li>
<li>tester (<code>reduce</code>): tests one or more criteria.</li>
<li>consumer (<code>sink</code>): the terminating point.</li>
</ul>
<h2 id="weakness-2"><a class="header" href="#weakness-2">Weakness</a></h2>
<p>Not good choice for interactive systems, because of their transformational character.</p>
<p>Excessive parsing and unparsing leads toloss of performance and increased complexity in writing the filters themselves.</p>
<h2 id="usages-2"><a class="header" href="#usages-2">Usages</a></h2>
<p>The pipe-filter architecture uses in a variety of applications, especially tasks that facilitate simple, one-way processing such as EDI, ETL tools.</p>
<p>Compilers: the consecutive filters perform lexical analysis, parsing, semantic analysis, and code generation.</p>
<h1 id="client-server"><a class="header" href="#client-server">Client Server</a></h1>
<p><img src="architecture%5CReference/image-19.png" alt="Alt text" /></p>
<h2 id="context-4"><a class="header" href="#context-4">Context</a></h2>
<p>There are shared resources and services that large numbers of distributed clients wish to access, and for which we wish to control access or quality of service.</p>
<h2 id="problem-3"><a class="header" href="#problem-3">Problem</a></h2>
<p>By managing a set of shared resources and services, we can promote modifiability and reuse, by factoring out common services and having to modify these in a single location, or a small number of locations. We want to improve scalability and availability by centralizing the control of these resources and services while distributing the resources themselves across multiple physical servers.</p>
<h2 id="solution-3"><a class="header" href="#solution-3">Solution</a></h2>
<p>In a client-server style, components and connectors have a particular behavior.</p>
<ul>
<li>Components, called “clients,” send requests to a component, called “server,” and wait for a reply.</li>
<li>A server component receives a request from a client and sends it the reply.</li>
</ul>
<h2 id="weakness-3"><a class="header" href="#weakness-3">Weakness</a></h2>
<p>The server can be a performance bottleneck and a single point of failure.</p>
<p>Decisions about where to locate functionality (in the client or in the server) are often complex and costly to change after a system has been built.</p>
<h2 id="usages-3"><a class="header" href="#usages-3">Usages</a></h2>
<p>We can use the client-server style to model a part of a system that has many components sending requests (clients) to another component (server) that offer services: online applications such as email, document sharing and banking.</p>
<h1 id="model-view-controller"><a class="header" href="#model-view-controller">Model View Controller</a></h1>
<p><img src="architecture%5CReference/image-20.png" alt="Alt text" /></p>
<h2 id="context-5"><a class="header" href="#context-5">Context</a></h2>
<p>The user interface is typically the most frequently modified portion of an interactive application. Users often wish to look at data from different perspectives, such as a bar graph or a pie chart. These representations should both reflect the current state of the data.</p>
<h2 id="problem-4"><a class="header" href="#problem-4">Problem</a></h2>
<p>How can user interface functionality be kept separate from application functionality and yet still be responsive to user input, or to changes in the underlying application’s data?</p>
<p>And how can multiple views of the user interface be created, maintained, and coordinated when the underlying application data changes?</p>
<h2 id="solution-4"><a class="header" href="#solution-4">Solution</a></h2>
<p>The model-view-controller (MVC) pattern separates application functionality into three kinds of components as follows.</p>
<ul>
<li>A model, which contains the application’s data.</li>
<li>A view, which displays some portion of the underlying data and interacts with the user.</li>
<li>A controller, which mediates between the model and the viewand manages the notifications of state changes.</li>
</ul>
<h2 id="weakness-4"><a class="header" href="#weakness-4">Weakness</a></h2>
<p>The complexity may not be worth it for simple user interfaces.</p>
<p>The model, view, and controller abstractions may not be good fits for some user interface toolkits.</p>
<h2 id="usages-4"><a class="header" href="#usages-4">Usages</a></h2>
<p>MVC is an architectural pattern that is commonly used in web, mobile applications while developing user interfaces.</p>
<h1 id="event-driven-architecture"><a class="header" href="#event-driven-architecture">Event Driven Architecture</a></h1>
<h2 id="context-6"><a class="header" href="#context-6">Context</a></h2>
<p>Computational and information resources need to be provided to handle incoming independent asynchronous application-generated events in a manner that can scale up as demand increases.</p>
<h2 id="problem-5"><a class="header" href="#problem-5">Problem</a></h2>
<p>Construct distributed systems that can service asynchronous arriving messages associated with an event, and that can scale from small and simple to large and complex.</p>
<h2 id="solution-5"><a class="header" href="#solution-5">Solution</a></h2>
<p><img src="architecture%5CReference/image-21.png" alt="Alt text" /></p>
<p>Deploy independent event processes/processors for event handling. Arriving events are queued. A scheduler pulls events from the queue and distributes them to the appropriate event handler based on a scheduling policy.</p>
<h2 id="weakness-5"><a class="header" href="#weakness-5">Weakness</a></h2>
<p>Performance and error recovery may be issues.</p>
<h2 id="usages-5"><a class="header" href="#usages-5">Usages</a></h2>
<p>An e-commerce application that uses this approach would work as follows:<br />
The Order Service creates an Order in a pending state and publishes an <code>OrderCreated</code> event.</p>
<ul>
<li>The Customer Service receives the event and attempts to reserve credit for that Order. It then publishes either a Credit Reserved event or a <code>CreditLimitExceeded</code> event.</li>
<li>The Order Service receives the event from the Customer Service and changes the state of the order to either approved or canceled</li>
</ul>
<h1 id="microservices-architecture"><a class="header" href="#microservices-architecture">Microservices Architecture</a></h1>
<h2 id="context-7"><a class="header" href="#context-7">Context</a></h2>
<p>Deploy server-based enterprise applications that support a variety of browsers and native mobile clients. The application handles client requests by executing business logic, accessing a database, exchanging messages with other systems, and returning responses. The application might expose a 3rd party API.</p>
<h2 id="problem-6"><a class="header" href="#problem-6">Problem</a></h2>
<p>Monolithic applications can become too large and complex for efficient support, and deployment for optimal distributed resource utilization such as in cloud environments.</p>
<h2 id="solution-6"><a class="header" href="#solution-6">Solution</a></h2>
<p><img src="architecture%5CReference/image-22.png" alt="Alt text" /></p>
<p>Build applications as suites of services. Each service is independently deployable and scalable and has its own API boundary. Different services can be written in different programming languages, manage their own database, and developed by different teams.</p>
<h2 id="weakness-6"><a class="header" href="#weakness-6">Weakness</a></h2>
<p>Systems must be designed to tolerate service failures that require more system monitoring. Service choreography and event collaboration overhead.</p>
<p>We also need more memory.</p>
<h2 id="usages-6"><a class="header" href="#usages-6">Usages</a></h2>
<p>Many use cases are applicable for a microservices architecture, especially those that involve an extensive data pipeline. For example, a microservices-based system would be ideal for a reporting system on a company’s retail store sales. Each step in the data preparation process would be handled by a microservice: data collection, cleansing, normalization, enrichment, aggregation, reporting, etc.</p>
<p>Easy, right?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices-when-documenting-your-code-for-software-engineers-1"><a class="header" href="#best-practices-when-documenting-your-code-for-software-engineers-1">Best Practices When Documenting Your Code for Software Engineers</a></h1>
<p>It’s all about clear, asynchronous communication</p>
<p><img src="architecture%5CReference/image.png" alt="Alt text" /></p>
<p>As a software engineer, it is very important to acquire the skill of writing high-quality documentation. Due to the recent increase in remote work, it has become even more important to be better at asynchronous communication. Remote company GitLab does an excellent job of <a href="https://about.gitlab.com/company/culture/all-remote/asynchronous/">defining asynchronous communication</a>:</p>
<blockquote>
<p>“Asynchronous communication is the art of communicating and moving projects forward without the need for additional stakeholders to be available at the same time your communique is sent.”</p>
</blockquote>
<p>High-quality documentation is an easier way to achieve effective asynchronous communication. In this article, I am going to talk about some interesting tips that I have found very useful in my personal experience.</p>
<h2 id="google-tech-writing-course-1"><a class="header" href="#google-tech-writing-course-1">Google Tech Writing Course</a></h2>
<p>Google offers a free tech writing course for software engineers. It starts with the fundamentals of tech writing. There are two courses and the content is as shown below:</p>
<p><img src="architecture%5CReference/image-1.png" alt="Alt text" /></p>
<p>TOC — Google Tech Writing One</p>
<p><img src="architecture%5CReference/image-2.png" alt="Alt text" /></p>
<p>TOC — Google Tech Writing Two</p>
<p>Being good at tech writing does not happen overnight. It takes practice. I personally prefer visiting this course each month to remind myself of the best practices.</p>
<h2 id="using-the-divio-documentation-framework-1"><a class="header" href="#using-the-divio-documentation-framework-1">Using the Divio Documentation Framework</a></h2>
<p>Amongst all other documentation frameworks, I personally like <a href="https://www.divio.com/">Divio</a> the best. The documentation systems suggested there are easy and universally applicable.</p>
<p>The framework suggests classifying documentation in the following types:</p>
<ul>
<li>Tutorials — Learning-oriented</li>
<li>How-To Guides — Problem-solving-oriented</li>
<li>Explanation — Understanding-oriented</li>
<li>Reference — Information-oriented</li>
</ul>
<p>The scheme is <a href="https://documentation.divio.com/adoption/#adoption">widely adopted</a> by a lot of famous open source projects and enterprises.</p>
<p>Here is a great video explaining the details of the framework:</p>
<h2 id="use-markdown-based-systems-for-documentation-1"><a class="header" href="#use-markdown-based-systems-for-documentation-1">Use Markdown-Based Systems for Documentation</a></h2>
<p>In a typical enterprise, there are various ways you can maintain your documentation. Some people prefer creating MS Word/Excel documents and uploading those in SharePoint or OneDrives. The biggest problem with such documents is that they are not searchable using your internal search engine. Hence I personally prefer using Markdown-based documentation systems. Creating and maintaining documentation is easy and the documentation is searchable.</p>
<p>If you are not familiar with Markdown, you can easily master it. Check out this free recommended <a href="https://guides.github.com/features/mastering-markdown/">course</a> from GitHub.</p>
<h2 id="using-mermaid-js-for-diagrams-1"><a class="header" href="#using-mermaid-js-for-diagrams-1">Using Mermaid JS for Diagrams</a></h2>
<p>According to <a href="http://mermaid-js.github.io/mermaid/">Mermaid</a> itself, it “is a Javascript-based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams.” If you are using GitLab or Azure DevOps, Mermaid is natively supported. If you are using GitHub or Atlassian products, then there are plug-ins available.</p>
<p>With Mermaid, creating and updating diagrams is very easy and you don’t need to have any UML tools like Visio/draw.io installed on every developer’s workstation.</p>
<p>Here are some sample diagrams created with Mermaid</p>
<p><img src="architecture%5CReference/image-3.png" alt="Alt text" /></p>
<p>Sample Sequence Diagram using Mermaid</p>
<p><img src="architecture%5CReference/image-4.png" alt="Alt text" /></p>
<p>Sample Class Diagram using Mermaid</p>
<p>You can try out creating diagrams using the <a href="https://mermaid-js.github.io/mermaid-live-editor/">Mermaid Live Editor</a> as well.</p>
<h2 id="use-templates-1"><a class="header" href="#use-templates-1">Use Templates</a></h2>
<p>There are numerous templates available on various sites like Confluence that can be used for specific types of documents. For example:</p>
<ul>
<li><a href="https://www.atlassian.com/software/confluence/templates/software-architecture-review">Software Architecture Review Template</a></li>
<li><a href="https://github.com/deshpandetanmay/lightweight-architecture-decision-records/blob/master/doc/adr/0001-use-elasticsearch-for-search-api.md">Architecture Decision Record Template</a></li>
<li><a href="https://www.atlassian.com/software/confluence/templates/incident-postmortem">Incident Postmortem Template</a></li>
<li><a href="https://www.atlassian.com/software/confluence/templates/devops-runbook">DevOps Runbook</a></li>
<li><a href="https://www.atlassian.com/software/confluence/templates/decision">Decision Template</a></li>
<li><a href="https://www.atlassian.com/software/confluence/templates/writing-guidelines">Writing Guidelines</a></li>
<li><a href="https://www.atlassian.com/software/confluence/templates/okrs">OKR Template</a></li>
<li>Etc.</li>
</ul>
<h2 id="refer-to-style-guides-1"><a class="header" href="#refer-to-style-guides-1">Refer to Style Guides</a></h2>
<p>If your team does not have a style guide already, refer to what the Googles and Microsofts of the world do:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/style-guide/">Microsoft Style Guide</a></li>
<li><a href="https://developers.google.com/style">Google Developer Documentation Style Guide</a></li>
</ul>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><a href="https://developers.google.com/tech-writing">Google Tech Writing Course</a></li>
<li><a href="https://documentation.divio.com/">Divio Documentation Framework</a></li>
<li><a href="https://mermaid-js.github.io/mermaid/#/">Mermaid</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code---general-implementation"><a class="header" href="#code---general-implementation">Code - General Implementation</a></h1>
<h2 id="before-you-begin"><a class="header" href="#before-you-begin">Before You Begin</a></h2>
<ul>
<li>CDG-1      Do you understand the design you are about to construct?</li>
<li>CDG-2      Does the design provide an appropriate level of detail for coding to begin?</li>
<li>CDG-3      Is the design to be implemented straightforward and feasible, or should it be revisited before attempting to construct it?</li>
<li>CDG-4      Do you understand the language and technology well enough to implement the design?</li>
</ul>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<ul>
<li>CDG-5      Is the code written in terms of the problem domain as much as possible rather than in terms of computer-science or programming language structures?</li>
<li>CDG-6      Is the code traceable to upstream design and requirements artifacts?</li>
<li>CDG-7      Does the code have documented test cases and/or unit tests as defined by the project?</li>
<li>CDG-8      Does the code adhere to the designated coding standard?</li>
<li>CDG-9      Does the code adhere to designated coding styles and / or templates?</li>
<li>CDG-10   Does the code compile with no warnings from the compiler?</li>
</ul>
<h2 id="understandability"><a class="header" href="#understandability">Understandability</a></h2>
<ul>
<li>CDG-11   Does the code read from top to bottom?</li>
<li>CDG-12   Are implementation details hidden as much as possible?</li>
<li>CDG-13   Is the code straightforward and does it avoid &quot;cleverness&quot;?</li>
<li>CDG-14   Has tricky code been rewritten rather than commented?</li>
<li>CDG-15   Do you thoroughly understand your code?</li>
<li>CDG-16   Is it easy to understand?</li>
</ul>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<ul>
<li>CDG-17   Are the affects of resource constraints on the technology and operational environment understood and within the bounds of the performance requirements?</li>
<li>CDG-18   Are the affects of system load on the technology and operational environment understood and within the bounds of the performance requirements?</li>
<li>CDG-19   Is the expected priority of efficient or highly optimized code clear for various areas of the system?</li>
<li>CDG-20   Has profiling support been planned for areas of the code at risk for performance issues?</li>
</ul>
<h2 id="assertions-and-tracing"><a class="header" href="#assertions-and-tracing">Assertions and Tracing</a></h2>
<ul>
<li>CDG-21   Are assertions used to document assumptions?</li>
<li>CDG-22   Are assertions used to aid debugging?</li>
<li>CDG-23   Are tracing statements used to document events and aid debugging?</li>
<li>CDG-24   Assertions are not being used to handle errors that should be handled in the code?</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<ul>
<li>CDG-25   Is it easy to differentiate between nominal path processing and error processing?</li>
<li>CDG-26   Are error conditions handled appropriately as per the requirements and design? (i.e., the level of robustness in detecting and responding to errors matches the needs of the system: not too little and not too much).</li>
<li>CDG-27   When attempting recovery from error conditions, are assumptions reasonable?</li>
</ul>
<h2 id="code-changes"><a class="header" href="#code-changes">Code Changes</a></h2>
<ul>
<li>CDG-28   Is the change part of a systematic change strategy?</li>
<li>CDG-29   Has the change been reviewed as thoroughly as initial development would be?</li>
<li>CDG-30   Does the change enhance the program's internal quality rather than degrading it?</li>
<li>CDG-31   Have you improved the system's modularity by breaking routines into smaller routines, when possible?</li>
<li>CDG-32   Have you improved the programming style--variable names, routine names, formatting, comments, and so on?</li>
<li>CDG-33   If changes cause you to look for ways to share code, have you considered putting the shared code at a higher level as well as considered putting it at a lower level?</li>
<li>CDG-34   Does this change make the next change easier?</li>
</ul>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<ul>
<li>CDG-35   Does the program's layout show its logical structure?</li>
<li>CDG-36   Is formatting done primarily to illuminate the logical structure of the code?</li>
<li>CDG-37   Is the formatting scheme used consistently?</li>
<li>CDG-38   Are related statements grouped together?</li>
<li>CDG-39   Are blank lines used to separate code elements including functions, control sequences, related blocks of code, etc?</li>
<li>CDG-40   Does the formatting scheme result in code that's easy to maintain?</li>
<li>CDG-41   Does the formatting scheme improve code readability?</li>
<li>CDG-42   Have relatively independent groups of statements been moved into their own routines?</li>
<li>CDG-43   Are references to variables as close together as possible, both in total live time and from each reference to a variable to the next?</li>
</ul>
<h2 id="individual-statements"><a class="header" href="#individual-statements">Individual Statements</a></h2>
<ul>
<li>CDG-44   Are continuation lines indented sensibly?</li>
<li>CDG-45   Are groups of related statements aligned?</li>
<li>CDG-46   Are groups of unrelated statements unaligned?</li>
<li>CDG-47   Does each line contain one statement?</li>
<li>CDG-48   Is each statement written without side effects?</li>
<li>CDG-49   Are data declarations aligned?</li>
<li>CDG-50   Is there one data declaration per line?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-review-checklist"><a class="header" href="#code-review-checklist">Code Review Checklist</a></h1>
<p>The following is a basic checklist on items to consider when doing code
reviews.</p>
<p><img src="architecture%5CReference/media/image1.jpg" alt="Good Code v Bad Code" /></p>
<h2 id="functionality"><a class="header" href="#functionality"><strong>Functionality</strong></a></h2>
<ul>
<li>F-1. Does the code match the design and the system requirements?</li>
<li>F-2. Does the code do what it should be doing?</li>
<li>F-3. Does the code do anything it should not be doing?</li>
<li>F-4. Can the code be made simpler while still doing what it needs to do?</li>
<li>F-5. Are available building blocks used when appropriate? (algorithms, data structures, types, templates, libraries, RTOS functions)</li>
<li>F-6. Does the code use good patterns and abstractions? (e.g., state charts, no copy-and paste)</li>
<li>F-7. Can this function be written with a single point of exit? (no returns in middle of function)</li>
<li>F-8. Are all variables initialized before use?</li>
<li>F-9. Are there unused variables?</li>
<li>F-10. Is each function doing only one thing? (Does it make sense to break it down into smaller modules that each do something different?)</li>
<li>F-11. Has reusable functionality been pulled out into utility functions?</li>
</ul>
<h2 id="style"><a class="header" href="#style"><strong>Style</strong></a></h2>
<ul>
<li>S-1. Does the code follow the style guide? (e.g. formatting, commenting)</li>
<li>S-2. Is the header information for each file and each function descriptive enough?</li>
<li>S-3. Is there an appropriate amount of comments? (frequency, location, and level of detail)</li>
<li>S-4. Is the code well structured? (typographically and functionally)</li>
<li>S-5. Are the variable and function names descriptive and consistent in style?</li>
<li>S-6. Are &quot;magic numbers&quot; avoided? (use named constants rather than numbers)</li>
<li>S-7. Is there any &quot;dead code&quot; (commented out code or unreachable code) that should be removed?</li>
<li>S-8. Is the code too complicated? (Did you have to think hard to understand what it does?)</li>
<li>S-9. Did you have to ask the author what the code does? (code should be self-explanatory)</li>
<li>S-10. Is there commented out code that should be removed?</li>
<li>S-11. Are the compilation and/or Static Analysis checks 100% warning-free? (are warnings enabled?)</li>
<li>S-12. Are there comments for saying what the code is doing rather than why it is doing it? (does it specify about any hacks, workaround and temporary fixes. Additionally, does it mention pending tasks in to-do comments, which can be tracked easily)</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture"><strong>Architecture</strong></a></h2>
<ul>
<li>A-1. Is the function too long? (e.g., longer than fits on one printed page)</li>
<li>A-2. Can this code be reused? Should it be reusing something else?</li>
<li>A-3. Is there minimal use of global variables? Do all variables have minimum scope?</li>
<li>A-4. Are classes and functions that are doing related things grouped appropriately? (cohesion)</li>
<li>A-5. Is the code portable? (especially variable sizes, e.g., &quot;int32&quot; instead of &quot;long&quot;)</li>
<li>A-6. Are specific types used when possible? (e.g., &quot;unsigned&quot; and typedef, not just &quot;int&quot;)</li>
<li>A-7. Are there any if/else structures nested more than two deep? (consecutive &quot;else if&quot; is OK)</li>
<li>A-8. Are there nested switch or case statements? (they should never be nested)</li>
<li>A-9. Is there any hard coding of values? (use constants/configuration values)</li>
<li>A-10. Has security been considered? (e.g SQL injections, Cross Site Scripting and API security)</li>
</ul>
<h2 id="exception-handling"><a class="header" href="#exception-handling"><strong>Exception handling</strong></a></h2>
<ul>
<li>E-1. Are input parameters checked for proper values (sanity checking)?</li>
<li>E-2. Are error return codes/exceptions generated and passed back up to the calling function?</li>
<li>E-3. Are error return codes/exceptions handled by the calling function?</li>
<li>E-4. Are null pointers and negative numbers handled properly?</li>
<li>E-5. Do switch statements have a default clause used for error detection?</li>
<li>E-6. Are arrays checked for out of range indexing? Are pointers similarly checked?</li>
<li>E-7. Is garbage collection being done properly, especially for errors/exceptions?</li>
<li>E-8. Is there a chance of mathematical overflow/underflow?</li>
<li>E-9. Are error conditions checked and logged? Are the error messages/codes meaningful?</li>
</ul>
<h2 id="logging"><a class="header" href="#logging"><strong>Logging</strong></a></h2>
<ul>
<li>L-1. Are we logging relevant information ?</li>
<li>L-2. Are we logging at the correct priority?</li>
<li>L-3. Is the log message clear (i.e access to code is not required to understand it and it clearly describes what has occurred)?</li>
</ul>
<h2 id="timing"><a class="header" href="#timing"><strong>Timing</strong></a></h2>
<ul>
<li>T-1. Is the worst-case timing bounded? (no unbounded loops, no recursion)</li>
<li>T-2. Are there any race conditions? (especially multi-byte variables modified by an interrupt) T-3. Is appropriate code thread safe and re-entrant?</li>
<li>T-4. Are there any long-running ISRs? Are interrupts masked for more than a few clocks?</li>
<li>T-5. Is priority inversion avoided or handled by the RTOS?</li>
<li>T-6. Is the watchdog timer turned on? Is the watchdog kicked only if every task is executing?</li>
<li>T-7. Has code readability been sacrificed for unnecessary optimization?</li>
</ul>
<h2 id="hardware"><a class="header" href="#hardware"><strong>Hardware</strong></a></h2>
<ul>
<li>H-1. Do I/O operations put the hardware in correct state?</li>
<li>H-2. Are min/max timing requirements met for the hardware interface?</li>
<li>H-3. Are you sure that multi-byte hardware registers can't change during read/write?</li>
<li>H-4. Does the software ensure that the system resets to a well-defined hardware system state?</li>
<li>H-5. Have brownout and power loss been handled?</li>
<li>H-6. Is the system correctly configured for entering/leaving sleep mode (e.g. timers)?</li>
<li>H-7. Have unused interrupt vectors been directed to an error handler?</li>
<li>H-8. Has care been taken to avoid EEPROM corruption? (e.g., power loss during write)</li>
</ul>
<h2 id="commit"><a class="header" href="#commit"><strong>Commit</strong></a></h2>
<ul>
<li>C-1. Do the commit comments explain what the change is and why?</li>
<li>C-2. Do the commit comments reference the appropriate JIRA issue?</li>
<li>C-3. Is the merge for one change only? (do not resolve multiple issues in one merge)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<h2 id="general-approach-to-debugging"><a class="header" href="#general-approach-to-debugging">General approach to debugging</a></h2>
<ul>
<li>DBG-1      Have you set a maximum time for quick and dirty debugging?</li>
<li>DBG-2      Do you research an issue to ensure an easy answer is not readily available?</li>
<li>DBG-3      Do you use all available debugging tools? (e.g., warning messages, execution tracing and profiling, scaffolding, interactive debugging, etc.)</li>
<li>DBG-4      Do you assume that errors are your fault?</li>
<li>DBG-5      Do you avoid the trial-and-error, superstitious approach to debugging?</li>
<li>DBG-6      Do you use several different techniques to find errors and alternate approaches?</li>
<li>DBG-7      Do you get help when appropriate?</li>
<li>DBG-8      If an issue appears that it will take longer to identify or fix than initially thought, do you notify project management as appropriate?</li>
<li>DBG-9      Do you move on when appropriate?</li>
<li>DBG-10    Do you verify that the fix is correct?</li>
<li>DBG-11    Do you use debugging as an opportunity to learn?</li>
</ul>
<h2 id="techniques-for-finding-errors-have-you-tried-to"><a class="header" href="#techniques-for-finding-errors-have-you-tried-to">Techniques for Finding Errors. Have you tried to</a></h2>
<ul>
<li>DBG-12    ... Use all the data available to form a hypothesis?</li>
<li>DBG-13    ... Refine the test cases that produce the error?</li>
<li>DBG-14    ... Reproduce the error several different ways?</li>
<li>DBG-15    ... Generate more data to generate more hypotheses?</li>
<li>DBG-16    ... Use results of negative tests?</li>
<li>DBG-17    ... Brainstorm for possible hypotheses?</li>
<li>DBG-18    ... Narrow the suspicious region of the code?</li>
<li>DBG-19    ... Check code that's changed recently?</li>
<li>DBG-20    ... Expand the suspicious region of the code?</li>
<li>DBG-21    ... Integrate incrementally?</li>
<li>DBG-22    ... Be suspicious of routines that have had errors before?</li>
<li>DBG-23    ... Use brute force?</li>
<li>DBG-24    ... Check for common errors?</li>
<li>DBG-25    ... Use confessional debugging?</li>
<li>DBG-26    ... Take a break from the problem?</li>
</ul>
<h2 id="techniques-for-fixing-errors-have-you-tried-to"><a class="header" href="#techniques-for-fixing-errors-have-you-tried-to">Techniques for Fixing Errors. Have you tried to</a></h2>
<ul>
<li>DBG-27    ... Understand the problem?</li>
<li>DBG-28    ... Check your work?</li>
<li>DBG-29    …Verify that the fix is correct?</li>
<li>DBG-30    ... Relax?</li>
<li>DBG-31    ... Confirm the error diagnosis?</li>
<li>DBG-32    ... Save the original source code?</li>
<li>DBG-33    ... Fix the problem, not the symptom?</li>
<li>DBG-34    ... Change the code only for good reason?</li>
<li>DBG-35    ... Understand the program as well as the problem?</li>
<li>DBG-36    ... Make one change at a time?</li>
<li>DBG-37    ... Look for similar errors?</li>
<li>DBG-38    ... Have a break?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="defect-creation"><a class="header" href="#defect-creation">Defect Creation</a></h2>
<p>DC-1 Define the defect</p>
<blockquote>
<p>State the platform and version</p>
<p>Log in and examine data (client, patient, program selected)</p>
<p>List any nonstandard configuration settings with values</p>
<p>State the workflow direction through the application</p>
</blockquote>
<p>DC-2 Research to narrow down the root cause and get beyond the defect
symptom</p>
<blockquote>
<p>Retest until you have the exact steps in the correct order to
reproduce the defect</p>
<p>Define the who, what, where, when, and how you found the defect</p>
<p>Execute database queries</p>
<p>Scan error logs</p>
<p>If the defect is intermittent, say so</p>
</blockquote>
<p>DC-3 Add support documentation</p>
<blockquote>
<p>Screenshots</p>
<p>Video</p>
<p>Step recording files</p>
<p>Error log data</p>
<p>Database query results</p>
</blockquote>
<p>DC- 4Format all text for readability and easy understanding</p>
<blockquote>
<p>Stick to a known and familiar format when possible</p>
<p>List using bulleted or numbered lists</p>
<p>Keep textual descriptions succinct and direct</p>
<p>Facts only; no opinion, no suggestions, no accusations, no blame</p>
</blockquote>
<h3 id="full-defect-report-example"><a class="header" href="#full-defect-report-example">Full defect report example</a></h3>
<p>The following is a full-text example of a defect report:</p>
<blockquote>
<p><strong>Summary</strong></p>
</blockquote>
<p>Allergy button not highlighted in red and user able to enter medication.</p>
<blockquote>
<p><strong>Description</strong></p>
</blockquote>
<p>Allergy button fails to highlight in red when an allergy is saved on the
patient record. Additionally, allergy entry is configured to disallow
medication entry of the interacting medication. User is able to enter
and save the medication that to which the patient is allergic.</p>
<blockquote>
<p><strong>Build/Platform</strong></p>
</blockquote>
<p>Windows 10/IE 11.5.1 / OS X Yosemite/Safari 10.0.3</p>
<blockquote>
<p><strong>Steps to reproduce</strong></p>
</blockquote>
<ol>
<li>
<p>Setup: Set the allergy configuration to ALWAYS BLOCK and save.</p>
</li>
<li>
<p>Log in as a MD user with full access.</p>
</li>
<li>
<p>Select a patient with an existing, saved allergy to penicillin.</p>
</li>
<li>
<p>View the Allergy alert button in the upper right corner.</p>
</li>
<li>
<p>Enter a medication order for penicillin, q4h for 30 days. Save.</p>
</li>
</ol>
<blockquote>
<p><strong>Actual results</strong></p>
</blockquote>
<p>The allergy button doesn't refresh and turn red to alert users to the
presence of an allergy, and it allows the user to add the medication
even though the allergy is on the patient record.</p>
<blockquote>
<p><strong>Expected results</strong></p>
</blockquote>
<p>The allergy button automatically refreshes anytime a new allergy is
entered and saved. The button turns red to indicate an allergy exists
for the patient. The MD user is blocked from saving a medication order
on the patient record when the allergy is present. The configuration
setting of ALWAYS BLOCK allows the medication order to be blocked
regardless of the severity of the allergy.</p>
<blockquote>
<p><strong>Evidence and supporting documentation</strong></p>
</blockquote>
<p>See the red arrow in the sample screenshot below. The allergy button
should be displaying where the red rectangle is drawn.</p>
<p><em>NOTE: Configuration set to block medication entry when any related
allergy exists on the patient record regardless of severity value. User
is an MD with full access. Database table displays the correct allergy
value on the patient. No errors generated in the error log.</em> Defect
Severity and Priority</p>
<h3 id="severity"><a class="header" href="#severity"><strong>Severity</strong></a></h3>
<blockquote>
<p><em>A blocking bug affects the inoperability of a system, and as a
result, proceed work with the application under test, or its essential
functions become Functioning of a scheme can only be ensured by a
solution of the problem</em>.</p>
<p><em>A critical error can be caused by malfunctioning key business logic,
a security hole, an issue that resulted in a temporary disability of
server or causing a part of the system to fail, without the ability to
fix the bug applying input points. The solution of the problem is
necessary for continuous operation of the essential functions of the
system under test</em>.</p>
<p><em>A major defect happens when the piece of the business rationale is
not working accurately. The bug is not critical unless there is a
chance to proceed with the capacity being tested utilizing other input
data.</em></p>
<p><em>Such bug does not aggravate the rationale of tested part of the
application. Usually, it is a prominent issue of the UI.</em> <strong>S5
Trivial</strong>.</p>
<p>It is an insignificant mistake that does not concern the business
rationale of the application is an inadequately reproducible problem
scarcely noticeable through the interface. This defect of third-party
libraries or services does not have any effect on the quality of the
product.</p>
</blockquote>
<p>Priority</p>
<blockquote>
<p><em><strong>P1 High</strong>.</em></p>
<p><em>The error has to be fixed the soonest way since its availability is
essential for proper operability.</em></p>
<p><em><strong>P2 Medium</strong>.</em></p>
<p><em>Elimination of the error is required, though its availability is not
critical, but needs a binding elimination.</em></p>
<p><em><strong>P3 Low</strong>.</em></p>
<p><em>The presence of a bug is not critical and does not require an urgent
solution</em>.</p>
</blockquote>
<h3 id="basic-understanding-between-bug-severity-and-priority"><a class="header" href="#basic-understanding-between-bug-severity-and-priority"><strong>Basic Understanding Between Bug Severity and Priority</strong></a></h3>
<h4 id="1-severity"><a class="header" href="#1-severity">1. Severity</a></h4>
<p>Severity is how austere a bug is! The severity of a bug is derived based
on the effect of that bug on the system. It indicates the level of
threat that a bug can affect the system. Severity is divided into
levels, such as-</p>
<p><img src="architecture%5CReference/media/image2.png" alt="" /></p>
<p>Realizing the Severity of a bug is critical from risk assessment and
management point of view.</p>
<h4 id="2-priority"><a class="header" href="#2-priority">2. Priority</a></h4>
<p>Priority is how quickly a bug should be fixed and eradicated from the
website. Bug priority indicates the sense of urgency for dealing with a
bug on our website.</p>
<p><img src="architecture%5CReference/media/image3.png" alt="" /></p>
<p>Buggy software or a website may severely infect the roster, which is a
result, can lead to a re-evaluation of risk and priorities, which turn
out to be more time, and resource consuming. This is why Shift-left
testing is trending in order to evaluate the risk and bugs by testing a
website as early as possible. In <a href="https://www.lambdatest.com/blog/how-shift-left-testing-can-help-your-product-quality/">shift-left
testing</a>,
you implement website testing right from the requirement gathering
phase. That being said, prioritizing a bug in the right manner goes a
long way in planning your SDLC(Software Development Lifecycle).</p>
<h3 id="bug-severity-vs-priority"><a class="header" href="#bug-severity-vs-priority"><strong>Bug Severity vs Priority</strong></a></h3>
<p><img src="architecture%5CReference/media/image4.png" alt="" />
&gt;</p>
<blockquote>
<p>Bug Severity is the degree of impact that a defect has on the system;
whereas, Bug Priority is the order of severity which has impacted the
system.</p>
<p>Severity is related to standards and functionality of the system;
whereas, Priority is related to scheduling.</p>
<p>Depending upon the impact of the bug, Bug Severity examines whether
the impact is serious or not. On the other hand, Bug Priority examines
whether the bug should be resolved soon or can be delayed.</p>
<p>Bug Severity is operated by functionality. On the other hand, bug
priority is operated by business value.</p>
<p>In the case of bug severity, the level of severity is less likely to
change. However, bug priority may differ.</p>
<p>Bug severity is assessed from a technical perspective of the
web-application workflow. On the other hand, bug priority is assessed
from a user-experience perspective on web-application usage.</p>
</blockquote>
<h2 id="defect-resolution"><a class="header" href="#defect-resolution">Defect Resolution</a></h2>
<ul>
<li>DR-1 Ensure you have understanding in the area you are fixing</li>
<li>DR-2 Clarify if the defect is a:
<ul>
<li>Functional defect</li>
<li>Integration related defect</li>
<li>Architectural defect</li>
<li>Requirement related defect</li>
</ul>
</li>
<li>DR-3 Detail what is wrong with the current implementation</li>
<li>DR-4 Explain what you will change to resolve the defect</li>
<li>DR-5 Summarise what tests you have done to ensure the defect is resolved</li>
<li>DR-6 Ensure linkage between the code commits and the defect</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="definition-of-done"><a class="header" href="#definition-of-done">Definition of Done</a></h1>
<ul>
<li>DoD-1 Code builds without warnings</li>
<li>DoD-2 Code developer tested</li>
<li>DoD-3 Code is QA tested</li>
<li>DoD-4 Documentation updated</li>
<li>DoD-5 Code reviewed</li>
<li>DoD-6 Code meets code review checklist</li>
<li>DoD-7 Any technical Debt is recorded</li>
<li>DoD-8 CI build is complete</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="definition-of-ready"><a class="header" href="#definition-of-ready">Definition of Ready</a></h1>
<ul>
<li>DoR-1 Design specs provided</li>
<li>DoR-2 User story is clear</li>
<li>DoR-3 Architecture understood</li>
<li>DoR-4 Acceptance criteria agreed</li>
<li>DoR-5 Meets INVEST</li>
<li>DoR-5 Non-functional requirements are understood</li>
</ul>
<h2 id="invest"><a class="header" href="#invest">INVEST</a></h2>
<ul>
<li>I-1 Immediately actionable   a team can begin work on the item right away</li>
<li>I-2 Negotiable   the team can discuss details about the PBI and how it is to be accomplished.</li>
<li>I-3 Value   the PBI produces value to customers/stakeholders.</li>
<li>I-4 Estimable   the team can estimate how much effort it will take to complete.</li>
<li>I-5 Small   the work can be accomplished in a single Sprint.</li>
<li>I-6 Testable the increment can be tested</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choosing-the-right-git-branching-strategy-a-comparative-analysis"><a class="header" href="#choosing-the-right-git-branching-strategy-a-comparative-analysis">Choosing the Right Git Branching Strategy: A Comparative Analysis</a></h1>
<p>Effective branch management is crucial for successful collaboration and efficient development with Git. In this article, we will explore four popular branching strategies — Git-Flow, GitHub-Flow, GitLab-Flow, and Trunk Based Development. By understanding their pros, cons, and ideal use cases, you can determine the most suitable approach for your project.</p>
<h2 id="git-flow"><a class="header" href="#git-flow">Git-Flow</a></h2>
<p>Git-Flow is a comprehensive branching strategy that aims to cover various scenarios. It defines specific branch responsibilities, such as main/master for production, develop for active development, feature for new features, release as a gatekeeper to production, and hotfix for addressing urgent issues. The life-cycle involves branching off from develop, integrating features, creating release branches for testing, merging into main/master, and tagging versions.</p>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<p>- Well-suited for large teams and aligning work across multiple teams.<br />
- Effective handling of multiple product versions.<br />
- Clear responsibilities for each branch.<br />
- Allows for easy navigation of production versions through tags.</p>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<p>- Complexity due to numerous branches, potentially leading to merge conflicts.<br />
- Development and release frequency may be slower due to multi-step process.<br />
- Requires team consensus and commitment to adhere to the strategy.</p>
<p><img src="architecture%5CReference/image-12.png" alt="Alt text" /></p>
<p>Git-Flow</p>
<h2 id="github-flow-1"><a class="header" href="#github-flow-1">GitHub-Flow</a></h2>
<p>GitHub-Flow simplifies Git-Flow by eliminating release branches. It revolves around one active development branch (often main or master) that is directly deployed to production. Features and bug fixes are implemented using long-living feature branches. Feedback loops and asynchronous collaboration, common in open-source projects, are encouraged.</p>
<h3 id="pros-1"><a class="header" href="#pros-1">Pros</a></h3>
<p>- Faster feedback cycles and shorter production cycles.<br />
- Ideal for asynchronous work in smaller teams.<br />
- Agile and easier to comprehend compared to Git-Flow.</p>
<h3 id="cons-1"><a class="header" href="#cons-1">Cons</a></h3>
<p>- Merging a feature branch implies it is production-ready, potentially introducing bugs without proper testing and a robust CI/CD process.<br />
- Long-living branches can complicate the process.<br />
- Challenging to scale for larger teams due to increased merge conflicts.<br />
- Supporting multiple release versions concurrently is difficult.</p>
<p><img src="architecture%5CReference/image-13.png" alt="Alt text" /></p>
<p>GitHub-flow</p>
<h2 id="gitlab-flow-1"><a class="header" href="#gitlab-flow-1">GitLab-Flow</a></h2>
<p>GitLab-Flow strikes a balance between Git-Flow and GitHub-Flow. It adopts GitHub-Flow’s simplicity while introducing additional branches representing staging environments before production. The main branch still represents the production environment.</p>
<h3 id="pros-2"><a class="header" href="#pros-2">Pros</a></h3>
<p>- Can handle multiple release versions or stages effectively.<br />
- Simpler than Git-Flow.<br />
- Focuses on quality with a lean approach.</p>
<h3 id="cons-2"><a class="header" href="#cons-2">Cons</a></h3>
<p>- Complexity increases when maintaining multiple versions.<br />
- More intricate compared to GitHub-Flow.</p>
<p><img src="architecture%5CReference/image-14.png" alt="Alt text" /></p>
<p>GitLab-Flow</p>
<h2 id="trunk-based-development"><a class="header" href="#trunk-based-development">Trunk Based Development</a></h2>
<p>Trunk Based Development promotes a single shared branch called “trunk” and eliminates long-living branches. There are two variations based on team size: smaller teams commit directly to the trunk, while larger teams create short-lived feature branches. Frequent integration of smaller feature slices is encouraged to ensure regular merging.</p>
<h3 id="pros-3"><a class="header" href="#pros-3">Pros</a></h3>
<p>- Encourages DevOps and unit testing best practices.<br />
- Enhances collaboration and reduces merge conflicts.<br />
- Allows for quick releases.</p>
<h3 id="cons-3"><a class="header" href="#cons-3">Cons</a></h3>
<p>- Requires an experienced team that can slice features appropriately for regular integration.<br />
- Relies on strong CI/CD practices to maintain stability.</p>
<p><img src="architecture%5CReference/image-11.png" alt="Alt text" /></p>
<p>Trunk Based Development — TBD</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Each branching strategy — Git-Flow, GitHub-Flow, GitLab-Flow, and Trunk Based Development — offers its own advantages and considerations. Choosing the right strategy depends on your specific project requirements. Git-Flow suits large teams and complex projects, while GitHub-Flow excels in open-source and small team environments. GitLab-Flow provides a compromise between Git-Flow and GitHub-Flow, while Trunk Based Development is ideal for experienced teams focused on collaboration and quick releases. Select the strategy that aligns with your team’s capabilities, project complexity, and desired workflow to maximize efficiency and success.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="habits-of-great-software-engineers"><a class="header" href="#habits-of-great-software-engineers">Habits of great software engineers</a></h1>
<p>The role of a software developer often gets distilled down to a singular activity: coding. While coding is undeniably the heartbeat of the profession, defining a developer by this act alone is akin to defining a painter by their ability to mix colors. It's a crucial part but just the tip of the iceberg. The true essence of a software developer's role combines many different skills, mindsets, and disciplines.</p>
<p>Imagine a world where every software developer is just a coder. In such a world, code might get written, but would it solve any problems? <em>Would the code be even useful or just an implementation of something fancy</em>? The difference between a developer and a great developer is the breadth and depth of their approach in delivering value.</p>
<p>I want to talk more about what makes a great software developer. What are the habits of highly effective developers? And I’m not going to talk about coding (too much).</p>
<p><strong>TL;DR;</strong> <strong>for those who want to know if there's value before they scroll down.</strong> I talk about:</p>
<ol>
<li><em>Focusing beyond the code</em> - as a developer you will code 20% of your time. You should excel at coding nonetheless, but it won't be enough to be great.</li>
<li><em>Efficiency / Antifragility</em> — Making sure everything around you runs smoothly and has forward momentum</li>
<li><em>Joy of tinkering</em> - build projects, try out frameworks, build stuff on the side. Keeps the spark alive.</li>
<li><em>Knowing the why</em> — It's important to know why your code does what it does, too many abstractions nowadays that rarely someone thinks below the level of their language e.g JS devs not thinking about the engine that runs their code.</li>
<li><em>Thinking in systems</em> — knowing how your code impacts not only your individual system but other parts of the business/application/life.</li>
<li><em>Tech detox</em> — Recharging away from your monitor makes you a better programmer.</li>
<li><em>The art of approximation</em> — Knowing important tech numbers to approximate calculations when making decisions when programming.</li>
<li>If this sounds interesting there's a few more things like that at the bottom. But you'll have to read it.</li>
</ol>
<p><strong><em>Disclaimer:</em></strong> <em>Purely subjective thoughts, yours may vary.</em></p>
<h2 id="focusing-beyond-the-code"><a class="header" href="#focusing-beyond-the-code">Focusing beyond the code</a></h2>
<p>Coding is to a developer what a brush is to a painter or a chisel to a sculptor. It's the primary tool, the foundational skill upon which everything else is built. Every application, every website, and every digital solution starts with a line of code. Someone wrote it. You probably write it daily as well.</p>
<p>However, while coding is fundamental, it's essential to recognize that it's not the actual purpose. It's about writing <em>meaningful</em> lines of code. It's about <em>solving problems</em> with the code. A line of code means nothing if there’s no context to it.</p>
<p>Being a great developer means being efficient in coding. It’s not something you can skip. It's the entry ticket to the world of software development. But what separates the good from the great is the ability to see beyond the immediate lines of code. <em>How will it interact with other components? How will it scale? How maintainable is it?</em> These are the questions that a decent software developer constantly grapples with.</p>
<p>We’re not going too deep on the coding; there are better teachers than me out there who share practical wisdom on how to master the machine. Here are some books purely on coding/programming that will boost your skills immensely:</p>
<ul>
<li><em>Cracking the Coding Interview</em>, McDowell <a href="https://www.amazon.com/dp/0984782850">[Link to Amazon]</a></li>
<li><em>Introduction to Algorithms</em>, Cormen <a href="https://www.amazon.com/Introduction-Algorithms-fourth-Thomas-Cormen/dp/026204630X/">[Link to Amazon]</a></li>
<li><em>Clean Code</em>, Martin <a href="https://www.amazon.com/dp/0132350882">[Link to Amazon]</a></li>
<li><em>Coders at Work</em>, Seibel <a href="https://www.amazon.com/gp/product/1430219483">[Link to Amazon]</a></li>
</ul>
<h2 id="the-pursuit-of-efficiency"><a class="header" href="#the-pursuit-of-efficiency">The Pursuit of Efficiency</a></h2>
<p>All the best developers that I’ve met have been highly efficient. I don’t know how they manage to do it, but it seems they’re always one step ahead of you. It’s a feeling when you’re near them; the progress is felt in the air. Everything moves smoothly — challenges get resolved in a timely matter, and things are under control and moving toward the purpose that the engineer has set.</p>
<p>Great feeling.</p>
<p>Some may argue that efficiency = the <a href="https://psyche.co/ideas/why-efficiency-is-dangerous-and-slowing-down-makes-life-better">opposite of stability</a>. But this is not the kind of efficiency I'm talking about. I'm talking more in terms of <a href="https://en.wikipedia.org/wiki/Antifragility">Antifragility</a>. No running around and doing everything as fast as possible. You don't have to make tradeoffs by reducing the buffers that you have, and be wary of making changes that reduce your resiliency to unexpected things.</p>
<p>So we’re talking about staying efficient. At its core, efficiency is about progress — momentum, ensuring that the wheels of development are always turning. To make it clear what I’m talking about, let’s take a look at the opposite. Every developer knows the feeling of being &quot;stuck&quot; – whether it's a particularly challenging bug — where you start doubting your competence or a piece of code that just won't cooperate. The progress seems to have come to a halt. The pursuit of efficiency, in this case, means not letting these obstacles impede you. It's about thinking on your feet, finding resources to solve the issue, finding alternative solutions, and keeping the end goal in sight.</p>
<pre><code>🏄 Think of it as adopting a proactive mindset, where doing something 
– even if it doesn’t solve your problem directly – is better than doing nothing.
</code></pre>
<p>This means breaking a complex problem into smaller, more manageable tasks. It means seeking input from a colleague when you're feeling stuck or temporarily setting aside a challenging task to focus on another aspect of the project. The key is to maintain forward momentum with small increments.</p>
<p>You might say, <em>“Solving hard problems requires time. You shouldn’t hurry”.</em> And you will be correct. Solving complex problems does require a lot of time. But even solving one big problem has forward momentum — For example getting a new exception after hours of debugging is cause for celebration as you move closer to figuring out the issue.</p>
<h2 id="the-joy-of-tinkering"><a class="header" href="#the-joy-of-tinkering">The Joy of Tinkering</a></h2>
<p>I will be honest: great developers aren't just skilled or knowledgeable; they're passionate. They're eyes light up at the mention of a new programming language. They spend hours diving deep into a challenging problem not just because they have to but because they <em>want</em> to. They're driven by an insatiable curiosity, a hunger to know more, do more, and be more.</p>
<p>I have nothing against people who are not passionate about programming; it’s okay, but these people will also not be pursuing greatness doing 9-5.</p>
<p>This passion manifests itself in various ways, but one of the most evident is the joy of exploration. Great developers are explorers at heart. They're not content with just knowing the tools and technologies of today; they're always on the lookout for what's on the horizon. They tinker, they experiment, they play. Whether it's a new framework, a novel algorithm, or an emerging tech trend, they dive in headfirst, eager to learn, understand, and master.</p>
<p>https://youtu.be/nctqc8FBJ2U</p>
<p>So here's George Hotz having great time tinkering with LLaMa and building a chatbot, can you see the joy while he's coding? I find this so cool.</p>
<p>This kind of tinkering keeps the spark alive. In a field as vast and ever-evolving as software development, it's easy to feel overwhelmed or stuck in a rut. However, by embracing curiosity and actively seeking new challenges and learning opportunities, developers can keep their skills sharp and enthusiasm high.</p>
<p>Moreover, this exploration has a more profound, more intrinsic value: the sheer joy of the process. I think great developers also enjoy being passionate about programming. From my personal side, I can tell you I could not see my life without some kind of programming.</p>
<h2 id="knowing-the-why"><a class="header" href="#knowing-the-why">Knowing the Why</a></h2>
<p>Nowadays, developers often find themselves engrossed in specific layers or components, be it perfecting a REST API request or finetuning CSS for that impeccable web design. We’ve gotten very high in abstractions in the last decade or so. Nobody writes assembly, and many developers have never even seen it. Developers usually just work with what they have and don’t ask questions about why it works the way it does. There's an underlying layer of understanding that often goes overlooked: knowing why things are the way they are.</p>
<p>Now, it's a valid argument that a developer doesn't need to be an expert in every layer of the stack. One doesn't need to trace the journey from circuit boards to bits and bytes for every line of code written. But having a foundational understanding and a sense of the bigger picture can be incredibly empowering.</p>
<p><em>Frontend Developers</em> — why and how the CSS is rendered? So many cool things in the <a href="https://www.chromium.org/blink/">Blink rendering engine</a> will change how you think about the page.<br />
<em>Backend Developers</em> — why and how the Python interpreter works? There are so many fascinating things in the <a href="https://github.com/python/cpython">CPython interpreter/compiler</a> that you’ll be surprised how your code runs.</p>
<p>Knowing the WHY/HOW behind the code offers several advantages:</p>
<ol>
<li><strong>Problem Solving:</strong> When challenges arise, understanding the underlying logic can guide you towards an answer much faster. Even the errors will be clearer when you know how they are thrown.</li>
<li><strong>Informed Decisions:</strong> Your knowledge of the underlying systems will subconsciously influence every decision you make. Whether it's choosing a protocol, seeing a function and understanding immediately it can run in O(n), or ensuring security, a deeper understanding equips a developer to make highly effective decisions.</li>
<li><strong>Bridging Gaps:</strong> In multidisciplinary teams, grasping the broader landscape can foster better communication and collaboration, bridging the gap between specialists of different domains.</li>
<li><strong>Innovation:</strong> Often, groundbreaking solutions emerge at the intersection of disciplines. Knowing the 'why' of various layers can spark innovative ideas and approaches.</li>
</ol>
<p>I’m not saying you should know everything. It’s more about not just blindly accepting things at face value but delving deeper and expanding one's horizons. I guarantee you this knowledge will be useful to you.</p>
<h2 id="thinking-in-systems"><a class="header" href="#thinking-in-systems">Thinking in Systems</a></h2>
<p>This is similar to the first part of not just focusing on the code but thinking about systems and their interactions. In my eyes, a great developer doesn’t just see the individual pieces; they see the entire puzzle, understanding not only how each piece fits into the current puzzle but also what the puzzle is and if there are more puzzles that need to be interacted with.</p>
<p>Systems thinking is about recognizing that software is made up of numerous components that interact with each other in complex ways. It's not enough to ensure that each component works well separately; it's crucial to understand how it works as part of the whole and what implications it has on the company. Simply — focus not only on unit tests but also E2E tests. It's about asking questions like: <em>Why is this component necessary for the business? If this component fails, how will it impact other systems? How can we design our software to be resilient?</em></p>
<p>Furthermore, systems thinking extends beyond the software itself. Great developers understand that software doesn't exist in a vacuum. It interacts with users, with other systems, with external databases, and even with other non-IT departments.</p>
<p>It's about seeing the forest <em>and</em> the trees, understanding both the macro and the micro level of the things that you develop. Imagine you’re a YouTube Engineer, given a task to improve the algorithm to increase the average time a user spends on YouTube. A straightforward task, you might think, but when you take a step back and look at the issue from a macro level, you’ll see that there are many complex systems at play — from Scalability to UX to moral considerations to legal department.</p>
<p>Or a better, recent example — imagine <a href="https://www.theregister.com/2023/10/10/ftx_python_code/">you’re an FTX Engineer</a>, and you’re asked to allow accounts to go into the negative. Again, it is a straightforward feature from the perspective of your individual system — a single line of code. But again, let’s step back and think of the risk management system, compliance system, and every other system affected by this change.</p>
<h2 id="recharging-beyond-the-pixels"><a class="header" href="#recharging-beyond-the-pixels">Recharging Beyond the Pixels</a></h2>
<p>In the digital age, screens have become ubiquitous. From the workstation where you transform code into applications to the smartphones that keep us connected 24/7, technology is an ever-present force in our lives. And for developers, this immersion is even more profound.</p>
<p>Great developers aren't just masters of their craft but well-rounded individuals who understand the value of experiences beyond the digital realm. They recognize that while technology can expand horizons, it can also, paradoxically, become a limiting bubble.</p>
<pre><code>🏄Constant immersion in the digital world can lead to a narrowed perspective. 
There’s so much more outside of the tech bubble.
</code></pre>
<p>I won’t talk too much about the dangers of constant screen time. Physically, it can lead to ailments like eye strain, disrupted sleep patterns, and sedentary lifestyle-related issues. Mentally, it can result in burnout, increased stress, and a feeling of being perpetually &quot;wired.&quot; Moreover, a predominantly online life can lead to a sense of isolation and a disconnection from the tangible, real world around us.</p>
<p>But stepping away from the screens, even momentarily, can work wonders. A tech detox can be incredibly rejuvenating, be it a short walk in the park, a weekend getaway, or even a few hours spent on a non-digital hobby.</p>
<p>Moreover, these breaks from technology serve as a reminder of the bigger picture. They ground us, reminding us of the real-world implications of their work, of the people and communities we serve, and of the myriad experiences and challenges that shape human lives.</p>
<h2 id="the-art-of-approximation"><a class="header" href="#the-art-of-approximation">The Art of Approximation</a></h2>
<p>How fast can you read 10GB from RAM? From SSD? There’s a subtle yet crucial skill that many developers overlook: the art of approximation. It's not about knowing everything but about having a mental toolkit of numbers to guide decisions, shape solutions, and prevent costly missteps.</p>
<p>Amidst the lines of logic and structures, there are numbers that matter. If you're building a high-throughput application, what's the storage cost for logging at 100,000 RPS? While the exact numbers might vary based on various factors, having a rough estimate can be invaluable. It can guide architectural decisions, inform optimizations, and provide a reality check on feasibility.</p>
<p>I’ve seen this cool concept called <em>“The Napkin Math”</em> — for situations where you need to quickly approximate how much it will cost or how fast it will be. In today's cloud-centric world, where scalability and performance are paramount, costs can soon spiral out of control if not kept in check. Being able to approximate calculations on the fly can provide a solid roadmap. It can help you anticipate costs, allocate resources efficiently, and design performant and cost-effective systems.</p>
<p>https://youtu.be/IxkSlnrRFqc</p>
<p>I won’t talk too in-depth about this - but watch the talk. It’s great.</p>
<h2 id="transfering-knowledge-to-other-problems"><a class="header" href="#transfering-knowledge-to-other-problems">Transfering Knowledge to Other Problems</a></h2>
<p>One of the most profound moments in a student's life is the realization that learning isn't just about absorbing information but understanding its essence and applying it to similar problems. This truth, often first encountered in math classes, extends far beyond the classroom and is especially pertinent in software development.</p>
<p>Think back to those math problems. You'd spend hours understanding a concept, practicing it with a specific set of problems, only to be presented with a different challenge during exams. The numbers changed, the context shifted, but the underlying principle remained unchanged. The real test wasn't just your knowledge of the concept but your ability to adapt and apply it to a new scenario.</p>
<p>I find this adaptability and transfer mindset quite important. Challenges are constant, but they rarely come in familiar packages. A coding solution that worked for one project might not fit another, even if they seem similar. The true mark of a developer's skill is their ability to take their knowledge and mold it to fit the task at hand.</p>
<p>If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</p>
<p>🏄 Experience plays a pivotal role in this. With each challenge faced, a developer adds to their repertoire, expanding their understanding and refining their approach. I tell my developers, “Every bug you solve today is a skill tomorrow.”</p>
<p>Static knowledge, rigid and unyielding, can become a limitation. The real magic lies in understanding and grasping the core principles so that they can be reshaped and repurposed as needed.</p>
<h2 id="making-hard-things-easy"><a class="header" href="#making-hard-things-easy">Making Hard Things Easy</a></h2>
<p>Julia Evans has a great talk on making hard things easy. That’s where I stole the title of this section as well.</p>
<p>There's a truth often attributed to the genius of Albert Einstein: &quot;If you can't explain it simply, you don't understand it well enough.&quot; In software engineering especially, the pinnacle of understanding isn't just about mastering the hard things but about making those hard things easy for others.</p>
<p>I’ve met quite a few developers who explained complex things to me in such simple terms that I was surprised that a) I understood it and b) that the concepts were not as complicated as I feared.</p>
<p>For example, I didn’t know much about network programming or Linux sockets. I spent days googling, but the information I found wasn’t really clicking with me. It might say a lot about Google search quality, but then I found the <a href="https://beej.us/guide/bgnet/html/">beej’s guide</a> , and it clicked into place for me.</p>
<p>I think it’s a mark of great engineers if they can explain something and be understood not just by their fellow programmers who work in the same field but also by average people.</p>
<p>Furthermore, making hard things easy is about leveling the playing field. It's about recognizing that knowledge shouldn't be a guarded treasure but a shared resource. By simplifying concepts by making them accessible, you empower others. You give them the tools to rise, to reach your level of understanding, and perhaps even surpass it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microservices-checklist--cover-all-aspects-of-microservices-architecture"><a class="header" href="#microservices-checklist--cover-all-aspects-of-microservices-architecture">Microservices Checklist — Cover All Aspects of Microservices Architecture</a></h1>
<p>We are going to learn our <strong>Microservices Checklist</strong> and cover <strong>All Aspects</strong> with exploring <strong>vertical topics</strong> of <strong>Microservices Architecture.</strong></p>
<p><img src="architecture%5CReference/image-23.png" alt="Alt text" /></p>
<p>Vertical Considerations</p>
<p>Before design any architecture, we should <strong>evaluate</strong> and <strong>verify</strong> some <strong>vertical topics</strong> and <strong>question</strong> to our <strong>architecture</strong> in order to make sure that we have <strong>calculated</strong> every <strong>tradeoffs</strong> and <strong>risks</strong> at acceptable level for your project.</p>
<h2 id="software-architecture-design"><a class="header" href="#software-architecture-design">Software Architecture Design</a></h2>
<p>Software architecture is always a <strong>balancing</strong> act <strong>between trade-offs</strong> and <strong>compromises</strong>. There is no single design or architecture that is perfect for every situation. Instead, software architects must <strong>carefully consider</strong> the <strong>trade-offs</strong> and make decisions based on the specific requirements, constraints, and goals of the software system.</p>
<p>For example, a <strong>monolithic architecture</strong> may be simpler and easier to manage, but it may not scale well as the system grows. On the other hand, a <strong>microservices-based architecture</strong> may provide greater scalability and flexibility, but it may be more complex and difficult to manage. <a href="https://medium.com/design-microservices-architecture-with-patterns/macro-services-to-nano-services-evolution-of-software-architecture-424f927b63cb">In the previous article, you can read the <strong>Evolution of Architectures; Monolithic, Microservices and Serverless.</strong></a></p>
<p>The key point is that <strong>there is no single “best” solution</strong> for software architecture, and software architects must constantly <strong>make trade-offs</strong> and <strong>compromises</strong> based on the <strong>specific requirements</strong>, <strong>constraints</strong>, and <strong>goals</strong> of the system. The goal is to find the <strong>right balance</strong> that meets the needs of the system and the stakeholders.</p>
<p>So to verify any architecture, we should think every aspects of design and make sure that cover all <strong>different angle of the design.</strong> During this article, we will discuss which <strong>vertical considerations</strong> could be think when we design microservices architecture.</p>
<h1 id="microservices-building-blocks"><a class="header" href="#microservices-building-blocks">Microservices Building Blocks</a></h1>
<p>We can start to discuss Vertical Considerations of microservices architectures. These are:</p>
<ul>
<li><strong>Microservices Decomposition — Breaking Down Microservices</strong></li>
<li><strong>Microservices Communications (Sync / Async Message-Based Communication, API Gws)</strong></li>
<li><strong>Microservices Data Management (Databases / Query / Commands)</strong></li>
<li><strong>Microservices Transaction Management</strong></li>
<li><strong>Microservices Distributed Caching</strong></li>
<li><strong>Microservices Deployments with Containers and Orchestrators</strong></li>
<li><strong>Microservices Resilience with Distributed Logging, Tracing and Health</strong></li>
<li><strong>Microservices Testing; Contract Testing, Integration Testing, E2E Test</strong></li>
<li><strong>Microservices Security; Authentication and Authorization</strong></li>
</ul>
<p>with applying microservices design patterns and practices.</p>
<p><img src="architecture%5CReference/image-24.png" alt="Alt text" /></p>
<p>Vertical Considerations</p>
<p>According to this image, we can evaluate and verify any architecture with checking all these vertical considerations.</p>
<h1 id="microservices-building-blocks--sub-components"><a class="header" href="#microservices-building-blocks--sub-components">Microservices Building Blocks — Sub Components</a></h1>
<p>Now we can go one more level to identify and check sub components of building blocks. Here you can reach the <strong>sub components</strong> of these <strong>Microservices Building Blocks</strong>:</p>
<h2 id="microservices-decomposition--breaking-down-microservices"><a class="header" href="#microservices-decomposition--breaking-down-microservices">Microservices Decomposition — Breaking Down Microservices:</a></h2>
<ul>
<li>DDD — Bounded Context</li>
<li>Business Capabilities</li>
</ul>
<h2 id="microservices-communications"><a class="header" href="#microservices-communications">Microservices Communications:</a></h2>
<ul>
<li>Synchronous Communication</li>
<li>Asynchronous Communication</li>
<li>Poll-Based Communications</li>
</ul>
<p>So in this building block, we should also go one more deep level and identify consideration topics as bellowed:</p>
<h2 id="microservices-synchronous-communication"><a class="header" href="#microservices-synchronous-communication">Microservices Synchronous Communication</a></h2>
<ul>
<li>Sync Communication Types: REST / gRPC / GraphQL / WebSocket</li>
<li>API Gateway Requirements: Discovery, Registry, Route, Aggregation, Composition, Authentication</li>
<li>Service-to-service Integration Considerations : Backend Microservices / 3rd party calls / B2B Gateways / IoT Devices</li>
<li>Headless Architecture Decisions: Micro-frontend designs, Edge Functions</li>
</ul>
<h2 id="microservices-asynchronous-communication"><a class="header" href="#microservices-asynchronous-communication">Microservices Asynchronous Communication</a></h2>
<ul>
<li>Async Com Types: 1–1 / 1-many (point-to-point / publish-subscribe)</li>
<li>Async Com Way: Fire&amp;Forget / Callback</li>
<li>Async Tools: Message Broker / Event Bus / Queue / DLQ</li>
<li>Async Patterns: Pub-Sub / Fanout / Topic Queue Chain / Event Filters / Rule Engine</li>
<li>EDA Design Considerations: Event Backbone / Event Queue Topic Design / Real-time Event Streams / Event Filters, Routers, Deserializers / Event Stores</li>
</ul>
<p>Lets continue with other sub components of Microservices Building Blocks.</p>
<h2 id="microservices-data-management-databases--query--commands"><a class="header" href="#microservices-data-management-databases--query--commands">Microservices Data Management (Databases / Query / Commands)</a></h2>
<ul>
<li>Database Chooses</li>
<li>Queries</li>
<li>Commands — Consistency</li>
<li>Distributed Transactions</li>
<li>Caching</li>
</ul>
<p>So in this building block, we should also go one more deep level and identify consideration topics as bellowed:</p>
<h2 id="database-chooses"><a class="header" href="#database-chooses">Database Chooses</a></h2>
<ul>
<li>DB Types : Relational / NoSQL — Document, Key/Value, Wide Column, Graph, Time Series, DWH</li>
<li>DB Scale Options : Master-Slave/ Masterless, Replication, Sharding, Read/Write</li>
<li>DB Capabilities: CDC / Streaming / Sharding / K8s Management DBs / DWH Reporting / Big Data Analysis / AI/ML model processing</li>
</ul>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<ul>
<li>API Gateway / Composition / Aggregation / BFF</li>
<li>CQRS / Materialized View / Event Sourcing / Read Database</li>
<li>Analytics/AI-ML/Reporting/Real-time stream analysis and processing / Big Data Analysis</li>
</ul>
<h2 id="commands--consistency"><a class="header" href="#commands--consistency">Commands — Consistency</a></h2>
<ul>
<li>Consistency: Strict / Eventual Consistency</li>
<li>CQRS / Write Database / ACID / Event Sourcing / Repayable Snapshot / Single source of truth</li>
</ul>
<h2 id="microservices-distributed-transactions"><a class="header" href="#microservices-distributed-transactions">Microservices Distributed Transactions</a></h2>
<ul>
<li>Transaction Management: 2PC / SAGA (Orchestrator / Choreography )</li>
<li>Outbox / Dual Write / Change Data Capture / Message Broker Event Bus / read-after-write consistency</li>
<li>MS Design : Idempotency / Stateless / Immutable events</li>
</ul>
<h2 id="microservices-distributed-caching"><a class="header" href="#microservices-distributed-caching">Microservices Distributed Caching</a></h2>
<ul>
<li>Cache Type: Static Content (CDN) / In-memory / Distributed</li>
<li>Cache Settings: Cache Expire / TTL / Hit — Miss — Invalidation</li>
</ul>
<p>Lets continue with other sub components of Microservices Building Blocks.</p>
<h2 id="microservices-deployments-with-containers-and-orchestrators"><a class="header" href="#microservices-deployments-with-containers-and-orchestrators">Microservices Deployments with Containers and Orchestrators</a></h2>
<ul>
<li>IaC</li>
<li>Devops CI/CD</li>
<li>Network Management</li>
</ul>
<p>So in this building block, we should also go one more deep level and identify consideration topics as bellowed:</p>
<h2 id="iac"><a class="header" href="#iac">IaC</a></h2>
<ul>
<li>Multi-Cloud Deployments — EKS, AKS, GKS</li>
<li>PaaS, Managed K8s (Openshift), Databases (k8cassandra, ksql), EventBus (Confluence Kafka), Api Gw</li>
<li>Serverless options, FAAS, Serverless and Edge Functions, CDN</li>
</ul>
<h2 id="devops-cicd"><a class="header" href="#devops-cicd">Devops CI/CD</a></h2>
<ul>
<li>Deployments: Containers, Orchestrators, Serverless options, Frameworks: Openshift</li>
<li>Pipeline Steps, Automation, Devops tools</li>
<li>Package Management: Helm Charts, Artifactory Hubs, Re-usable container registry</li>
<li>Deployment Strategy: Blue/Green, Canary, Recreate</li>
<li>Configurations : Config Server, Encryption, Key Vault Management</li>
</ul>
<h2 id="network-management"><a class="header" href="#network-management">Network Management</a></h2>
<ul>
<li>Load Balancing, Ingress, CDN, DNS Management, Cluster Management, Disaster recovery</li>
</ul>
<p>Lets continue with other sub components of Microservices Building Blocks.</p>
<h2 id="microservices-resilience"><a class="header" href="#microservices-resilience">Microservices Resilience</a></h2>
<ul>
<li>Observability / Logging</li>
<li>Monitoring</li>
<li>Tracing</li>
<li>Resilient / Fault Tolerance</li>
</ul>
<p>So in this building block, we should also go one more deep level and identify consideration topics as bellowed:</p>
<h2 id="observability--logging"><a class="header" href="#observability--logging">Observability / Logging</a></h2>
<ul>
<li>Centralized Logging, Distributed Logging, Dashboards, ELK Stack</li>
<li>Log Id per Request, Service App Logs, Integration Logs</li>
</ul>
<h2 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h2>
<ul>
<li>System Monitoring: CPU, Ram</li>
<li>Application Monitoring: Queue Count, unprocessed messages</li>
<li>Health Checks : Microservices, Databases, Brokers Event Buses, 3rd party systems</li>
</ul>
<h2 id="tracing"><a class="header" href="#tracing">Tracing</a></h2>
<ul>
<li>Distributed Transactions, Transaction Id, Correlation Id, E2E Request Id, Event Id</li>
<li>OpenTelemetry Compliance: Jeager, Zipkin</li>
</ul>
<h2 id="resilient--fault-tolerance"><a class="header" href="#resilient--fault-tolerance">Resilient / Fault Tolerance</a></h2>
<ul>
<li>API Call Management : Retry, Circuit Breaker, Bulkhead, Rate limiting, Fault Tolerant</li>
<li>Kubernetes Patterns &amp; Best Practices : Sidecar, Service Mesh, Service Proxy</li>
<li>Async Fault Alarms: DLQ, Notifications, Alarms</li>
</ul>
<p>Lets continue with other sub components of Microservices Building Blocks.</p>
<h2 id="microservices-testing-contract-testing-integration-testing-e2e-test"><a class="header" href="#microservices-testing-contract-testing-integration-testing-e2e-test">Microservices Testing; Contract Testing, Integration Testing, E2E Test</a></h2>
<ul>
<li>Pre-Deployment Test : Unit / Integration / Contract Test</li>
<li>Post-Deployment Test : E2E SIT Test / Consumer-Driven Test / Chaos Test</li>
</ul>
<h2 id="microservices-security-authentication-and-authorization"><a class="header" href="#microservices-security-authentication-and-authorization">Microservices Security; Authentication and Authorization</a></h2>
<ul>
<li>Authentication</li>
<li>Identity Servers: Managed (IS4, Keycloak) and Serverless options (Cognito)</li>
<li>Protocols: OAuth2.0 , OpenIDConnect flows</li>
<li>Token Types and Claims</li>
<li>Authorization</li>
<li>API Gw Authentication flows, Claim based authorizations, RBAC</li>
<li>Configurations</li>
<li>Encryption, Key Vault Management</li>
<li>SSL and TLS, Firewalls</li>
<li>Audit Logs</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>These are created from our team when we design and iterate microservices into our cloud-native enterprise applications and projects. So if you have additional consideration feel free to extend this list with adding new considerations regarding to microservices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cloud-naming-convention"><a class="header" href="#cloud-naming-convention">Cloud Naming Convention</a></h1>
<p>Consistent naming strategy is important and should be an essential part of any cloud effort. Sadly it's often overlooked. It might seem like a luxury when you run a few &quot;pet&quot; servers, but it quickly becomes critical as the number of managed resources grows. It is the first step in achieving even basic levels of consistency and prerequisite to establishing any sort of cloud governance.</p>
<p>After reading this article, you'll hopefully know how to get from:</p>
<pre><code>
$ gcloud container clusters list\
    --format 'value(name)'
k8s-cluster
k8s-cluster
k8s-cluster
k8s-cluster

</code></pre>
<p>to something like:</p>
<pre><code>
$ gcloud container clusters list\
    --format 'value(name)'
ste-blog-p-kcl-euwe4-primary
ste-webshop-d-kcl-euwe4-primary
ste-webshop-p-kcl-euwe4-primary
ste-webshop-p-kcl-usce1-primary

</code></pre>
<p>The latter will quickly tell us what type of resources are we dealing with, to which project and environment they belong, where are they located and whether they're functionally equivalent to each other.</p>
<h2 id="benefits"><a class="header" href="#benefits">Benefits</a></h2>
<p>Consistent and descriptive naming of resources has many benefits:</p>
<ul>
<li>Indicates the role and ownership of a resource.</li>
<li>Helps formalize expectations and promote consistency within an infrastructure.</li>
<li>Prevents name clashes when resource names must be unique.</li>
<li>Makes resources easier to locate.</li>
<li>Reduces effort to understand code and allows developers to focus on more important aspects than arguing over naming standards.</li>
<li>Allows to sort and filter resources quickly.</li>
<li>Is a prerequisite for establishing any successful cloud governance and automated policy evaluation or enforcement.<br />
I'm not quite sure when I first came across this quote, but it since became one of my favourites. Martin Fowler <a href="https://martinfowler.com/bliki/TwoHardThings.html">attributes it to Phil Karlton</a>.</li>
</ul>
<blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things.</p>
<p>Phil Karlton</p>
</blockquote>
<h2 id="main-properties"><a class="header" href="#main-properties">Main Properties</a></h2>
<p>Good naming convention must provide clarity and work in both directions:</p>
<ul>
<li>Clearly define how newly created resources should be named.</li>
<li>Identify and indicate the purpose and ownership of existing resources.</li>
</ul>
<p>We'll focus on how a naming convention for cloud-level resources should look like. GCP is used in our examples, but the concepts and strategies are generic and can be easily adapted to other cloud providers.</p>
<h2 id="naming-restrictions"><a class="header" href="#naming-restrictions">Naming Restrictions</a></h2>
<p>When designing your naming convention, you should take into account limitations imposed by the cloud provider. Each resource comes with a set of naming restrictions. The rule of thumb is to keep it short and simple (use only letters and numbers for individual components, keep <code>-</code> as separator).</p>
<p>GCP limits name length for most of the resources to 62 or 63 characters, Project IDs are limited to 30. Resources must have unique names, either globally or within a given scope. Some resources have additional constraints to take into consideration (e.g. GCP Projects can't be immediately deleted).</p>
<h2 id="global-naming-pattern"><a class="header" href="#global-naming-pattern">Global Naming Pattern</a></h2>
<p>First we establish naming pattern that all directly managed resources should follow - Global Naming Pattern.</p>
<p><strong><code>[prefix]-[project]-[env]-[resource]-[location]-[description]-[suffix]</code></strong></p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th><th>Req.</th><th>Constraints</th></tr></thead><tbody>
<tr><td><strong><code>prefix</code></strong></td><td>Fixed prefix</td><td>✔</td><td>len 3, fixed</td></tr>
<tr><td><strong><code>project</code></strong></td><td>Project name</td><td>✔</td><td>len 4-10, a-z0-9</td></tr>
<tr><td><strong><code>env</code></strong> .</td><td>Environment</td><td>✔</td><td>len 1, a-z, enum</td></tr>
<tr><td><strong><code>resource</code></strong></td><td>Resource type</td><td>✔</td><td>len 3, a-z, enum</td></tr>
<tr><td><strong><code>location</code></strong></td><td>Resource location</td><td>✗</td><td>len 1-6, a-z0-9</td></tr>
<tr><td><strong><code>description</code></strong></td><td>Additional description</td><td>✗</td><td>len 1-20, a-z0-9</td></tr>
<tr><td><strong><code>suffix</code></strong></td><td>Random suffix</td><td>✗</td><td>len 4, a-z0-9</td></tr>
</tbody></table>
</div>
<p>Let's go over the individual components more in detail.</p>
<h3 id="fixed-prefix"><a class="header" href="#fixed-prefix">Fixed Prefix</a></h3>
<p>This is a fixed value prefix used for all resources. Typically some form of abbreviation for your organization name.</p>
<ul>
<li><code>ste</code> for Stepan</li>
<li><code>ggl</code> for Google</li>
</ul>
<h3 id="project-name"><a class="header" href="#project-name">Project Name</a></h3>
<p>This is different from a GCP Project. Typically one Project will have multiple GCP Projects.We're using flat hierarchy and Project serves as the main mechanism of organizing resources into groups. I like using flat hierarchy as it's very universal and flexible to fit pretty much any organizational structure. You might consider replacing this with some other form of group (e.g. team, product), but in my experience it never quite works in the long term.</p>
<ul>
<li><code>blog</code> for blog project</li>
<li><code>webshop</code> for web shop project</li>
</ul>
<h3 id="environment"><a class="header" href="#environment">Environment</a></h3>
<p>Resources belong to deployment environments. It's beneficial to establish a common set of names used across your organization.</p>
<ul>
<li><code>d</code> for development</li>
<li><code>s</code> for staging</li>
<li><code>p</code> for production</li>
</ul>
<h3 id="resource-type"><a class="header" href="#resource-type">Resource Type</a></h3>
<p>I've tried various mechanisms over the time to construct the abbreviation for resources - most consistent results are achieved if the names are based on the API resource names.Abbreviation of the given resource type. In GCP I tend to use three letters.</p>
<p>For larger and more frequently used APIs (e.g. Compute, Kubernetes) first letter stands for the API and the remaining two for the resource type. For APIs with fewer resources, it's the other way around. I know this is not a completely deterministic rule, but this will always be a compromise to it short and usable.</p>
<ul>
<li><code>cin</code> - Compute Engine VM Instance</li>
<li><code>cig</code> - Compute Engine VM Instance Group</li>
<li><code>kcl</code> - Kubernetes Engine Cluster</li>
<li><code>bqd</code> - BigQuery Dataset</li>
</ul>
<h3 id="resource-location"><a class="header" href="#resource-location">Resource Location</a></h3>
<p>Location is required when there's a possibility to create a given resource in different locations.</p>
<ul>
<li>
<p><strong>Regional</strong> - five letter acronym (two letters for the continent, two for cardinal directions, 1 digit)</p>
</li>
<li>
<p><strong>Zonal</strong> - six letters - Regional + zone</p>
</li>
<li>
<p><strong>Global</strong> - <code>g</code></p>
</li>
<li>
<p><strong>Multi- and Dual-regional</strong> - follow GCP's own naming (two letters for multi and 4 letters for dual-regional)</p>
</li>
<li>
<p><code>euwe1</code> - europe-west1 region</p>
</li>
<li>
<p><code>nane1</code> - northamerica-northeast1 region</p>
</li>
<li>
<p><code>euwe1a</code> - europe-west1 region, zone a</p>
</li>
<li>
<p><code>eu</code> - Europe multi-region</p>
</li>
<li>
<p><code>eur4</code> - europe-north1 and europe-west4 dual-region</p>
</li>
</ul>
<h3 id="additional-description"><a class="header" href="#additional-description">Additional Description</a></h3>
<p>A description used to distinguish between resources of the same type but different roles. For example a group of servers with a different purpose - <code>frontend</code> and <code>backend</code>. This should not be used to differentiate between multiple instances of the same purpose resource, use <code>suffix</code> instead.</p>
<p>It's also beneficial to agree on generic keywords used for description, when there is no better, more specific, term available. This avoids many different names like <code>main</code>, <code>core</code>, <code>common</code>, <code>this</code> and similar. Often good strategy is to use the Latin ordinal sequence, i.e. <code>primary</code>, <code>secondary</code>, <code>tertiary</code>, etc.</p>
<ul>
<li><code>frontend</code></li>
<li><code>backend</code></li>
<li><code>kafka</code></li>
</ul>
<h3 id="random-suffix"><a class="header" href="#random-suffix">Random Suffix</a></h3>
<p>I typically use a 2-byte number represented in hexadecimal form</p>
<ul>
<li>
<p>good for readability and easily generated with Terraform <code>random_id</code> resource. Use Suffix to differentiate resource from its peers when there are multiple instances, or when there's a requirement for uniqueness.</p>
</li>
<li>
<p><code>a49f</code></p>
</li>
</ul>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>Let's go over several full examples of how resources should be named based on the above established pattern.</p>
<p>All the examples use prefix <code>ste</code> and belong to Production (<code>p</code>) environment of project <code>blog</code>.</p>
<ul>
<li>Set of functionally equivalent Compute Instances
<ul>
<li><code>ste-blog-p-cin-euwe1a-nginx-408f</code></li>
<li><code>ste-blog-p-cin-euwe1a-nginx-c338</code></li>
<li><code>ste-blog-p-cin-euwe1a-nginx-d7aa</code></li>
</ul>
</li>
<li>VPC (Network) and Subnet
<ul>
<li><code>ste-blog-p-cne-primary</code></li>
<li><code>ste-blog-p-csn-euwe1-primary</code></li>
</ul>
</li>
<li>GKE Regional Cluster and Node Pool
<ul>
<li><code>ste-blog-p-kcl-usce1-primary</code></li>
<li><code>ste-blog-p-knp-usce1-primary-cbe7</code></li>
</ul>
</li>
</ul>
<h2 id="gcp-projects"><a class="header" href="#gcp-projects">GCP Projects</a></h2>
<p>Projects (and Folders) are considered resource containers for the purpose of this naming convention and therefore omit the <code>resource</code> part of the name.</p>
<p>You can notice GCP does this by default for projects created via console - e.g. <code>rapid-depot-253717</code>.Project IDs in GCP have to be globally unique and cannot be deleted immediately. This is unfortunate for automation, as you can't create a project with the same name right after it has been deleted. And that's why we include the unique random suffix part.</p>
<p><em>Folders</em>: We don't use GCP folders to organize projects. I generally believe that keeping it simple and flat is beneficial more often than not. However, if you want to further structure your resources, consider adding an additional component to your naming pattern, such as <code>[org_group]</code>. Folders can then follow <code>[prefix]-[org-group]</code> pattern.GCP also allows configuring Project Name. I recommend to set this to the same value as Project ID and forget about it. For all the practical purposes you'll reference the Projects by their IDs.</p>
<p>GCP Projects will therefore be named following the <code>[prefix]-[project]-[env]-[suffix]</code> pattern.</p>
<ul>
<li><code>ste-blog-p-a8d6</code></li>
<li><code>abc-research-d-ab45</code></li>
</ul>
<p><a href="https://xkcd.com/910/">xkcd - Permanence</a> by Randall Munroe<a href="https://stepan.wtf/cloud-naming-convention/#66ec467cfa84e7c7ceea8e9bd57df35b-lightbox"><img src="https://stepan.wtf/imgs/cloud-naming-convention-xkcd.png" alt="" /></a></p>
<h2 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h2>
<p>There will always be exceptions where it's not possible to follow the Global Naming Pattern (for example resource does not allow <code>-</code> in the name) or when it simply doesn't make sense. A subset of the full pattern should be used if possible and all exceptions documented.</p>
<h3 id="service-accounts"><a class="header" href="#service-accounts">Service Accounts</a></h3>
<p>Service accounts follow the <code>[resource]-[description]</code> pattern only, as the project is already included in the part after <code>@</code> and therefore there's no need to repeat that bit,</p>
<ul>
<li><code>svc-frontend@ste-blog-p-a8d6.iam.gserviceaccount.com</code></li>
</ul>
<h3 id="iam-and-groups"><a class="header" href="#iam-and-groups">IAM and Groups</a></h3>
<p>This is a complex topic, perhaps for another article, but you should establish a naming convention for groups and a strategy on how to assign permissions. As a rule of thumb, never assign permissions directly to individuals, but to groups only.</p>
<h2 id="labelling-resources"><a class="header" href="#labelling-resources">Labelling Resources</a></h2>
<p>You should also cover the use of labels (or tags). A good one is to add information to further categorize your resources, such as <code>cost-center</code>. Labels are also helpful in situations when you can't manage resource names directly, but you can manage a set of labels that is propagated to the child resources (e.g. GKE Cluster labels or Instance Groups).</p>
<p>Do not duplicate information already contained in your naming convention (such as <code>project</code>) or create large numbers of unique labels with information that can be obtained from the objects themselves (such as <code>creationTimestamp</code>).</p>
<h2 id="dns"><a class="header" href="#dns">DNS</a></h2>
<p>DNS naming convention across your infrastructure is again a larger topic, but you should definitely have one. A simple strategy can be creating a subdomain for each GCP project in the <code>[project]-[env].&lt;common_dns_domain&gt;</code> form. DNS records created for given resources should then follow the <code>[resource]-[resource_location]-[description]-[suffix]</code> part of the Global Naming pattern and therefore mirror the resource name.</p>
<p>This allows for easy subdomain delegation to individual GCP projects.</p>
<ul>
<li>DNS record for VM with name <code>ste-blog-p-cin-euwe1b-frontend-a6bc</code> would be <code>cin-euwe1b-frontend-a6bc.blog-p.stepan.wtf</code></li>
</ul>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>You should establish a consistent naming convention as one of the first things when you start using cloud or on a new project. It's one of those things that are really easy to do in the beginning, but much more difficult to fix later on. And you'll benefit from it every day.</p>
<p>The key to success with naming conventions is establishing them early on and ruthlessly following across your entire infrastructure. Automation helps a lot.</p>
<p>As usual, there's no silver bullet and the actual naming convention should always be tailored to your environment. The main point is having one! And I hope this post gives you a head start.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-pragmatic-programmer-quick-reference-guide"><a class="header" href="#the-pragmatic-programmer-quick-reference-guide">The Pragmatic Programmer Quick Reference Guide</a></h1>
<p>This page summarizes the tips and checklists found in <em>The Pragmatic
Programmer</em>.</p>
<p><strong>Care About Your Craft</strong></p>
<p>Why spend your life developing software unless you care about doing it
well?</p>
<p><strong>Think! About Your Work</strong></p>
<p>Turn off the autopilot and take control. Constantly critique and
appraise your work.</p>
<p><strong>Provide Options, Don't Make Lame Excuses</strong></p>
<p>Instead of excuses, provide options. Don't say it can't be done;
explain what can be done.</p>
<p><strong>Don't Live with Broken Windows</strong></p>
<p>Fix bad designs, wrong decisions, and poor code when you see them.</p>
<p><strong>Be a Catalyst for Change</strong></p>
<p>You can't force change on people. Instead, show them how the future
might be and help them participate in creating it.</p>
<p><strong>Remember the Big Picture</strong></p>
<p>Don't get so engrossed in the details that you forget to check what's
happening around you.</p>
<p><strong>Make Quality a Requirements Issue</strong></p>
<p>Involve your users in determining the project's real quality
requirements.</p>
<p><strong>Invest Regularly in Your Knowledge Portfolio</strong> Make learning a habit.</p>
<p><strong>Critically Analyze What You Read and Hear</strong></p>
<p>Don't be swayed by vendors, media hype, or dogma. Analyze information
in terms of you and your project.</p>
<p><strong>It's Both What You Say and the Way You Say It</strong></p>
<p>There's no point in having great ideas if you don't communicate them
effectively.</p>
<p><strong>DRY--Don't Repeat Yourself</strong></p>
<p>Every piece of knowledge must have a single, unambiguous, authoritative
representation within a system.</p>
<p><strong>Make It Easy to Reuse</strong></p>
<p>If it's easy to reuse, people will. Create an environment that supports
reuse.</p>
<p><strong>Eliminate Effects Between Unrelated Things</strong></p>
<p>Design components that are self-contained. independent, and have a
single, well-defined purpose.</p>
<p><strong>There Are No Final Decisions</strong></p>
<p>No decision is cast in stone. Instead, consider each as being written in
the sand at the beach, and plan for change.</p>
<p><strong>Use Tracer Bullets to Find the Target</strong></p>
<p>Tracer bullets let you home in on your target by trying things and
seeing how close they land.</p>
<p><strong>Prototype to Learn</strong></p>
<p>Prototyping is a learning experience. Its value lies not in the code you
produce, but in the lessons you learn.</p>
<p><strong>Program Close to the Problem Domain</strong> Design and code in your user's
language.</p>
<p><strong>Estimate to Avoid Surprises</strong></p>
<p>Estimate before you start. You'll spot potential problems up front.</p>
<p><strong>Iterate the Schedule with the Code</strong></p>
<p>Use experience you gain as you implement to refine the project time
scales.</p>
<p><strong>Keep Knowledge in Plain Text</strong></p>
<p>Plain text won't become obsolete. It helps leverage your work and
simplifies debugging and testing.</p>
<p><strong>Use the Power of Command Shells</strong></p>
<p>Use the shell when graphical user interfaces don't cut it.</p>
<p><strong>Use a Single Editor Well</strong></p>
<p>The editor should be an extension of your hand; make sure your editor is
configurable, extensible, and programmable.</p>
<p><strong>Always Use Source Code Control</strong></p>
<p>Source code control is a time machine for your work---you can go back.</p>
<p><strong>Fix the Problem, Not the Blame</strong></p>
<p>It doesn't really matter whether the bug is your fault or someone
else's---it is still your problem, and it still needs to be fixed.</p>
<p><strong>Don't Panic When Debugging</strong></p>
<p>Take a deep breath and THINK! about what could be causing the bug.</p>
<p><strong>&quot;select&quot; Isn't Broken.</strong></p>
<p>It is rare to find a bug in the OS or the compiler, or even a
third-party product or library. The bug is most likely in the
application.</p>
<p><strong>Don't Assume It---Prove It</strong></p>
<p>Prove your assumptions in the actual environment-- with real data and
boundary conditions.</p>
<p><strong>Learn a Text Manipulation Language.</strong></p>
<p>You spend a large part of each day working with text. Why not have the
computer do some of it for you?</p>
<p><strong>Write Code That Writes Code</strong></p>
<p>Code generators increase your productivity and help avoid duplication.</p>
<p><strong>You Can't Write Perfect Software</strong></p>
<p>Software can't be perfect. Protect your code and users from the
inevitable errors.</p>
<p><strong>Design with Contracts</strong></p>
<p>Use contracts to document and verify that code does no more and no less
than it claims to do.</p>
<p><strong>Crash Early</strong></p>
<p>A dead program normally does a lot less damage than a crippled one.</p>
<p><strong>Use Assertions to Prevent the Impossible</strong></p>
<p>Assertions validate your assumptions. Use them to protect your code from
an uncertain world.</p>
<p><strong>Use Exceptions for Exceptional Problems</strong></p>
<p>Exceptions can suffer from all the readability and maintainability
problems of classic spaghetti code. Reserve exceptions for exceptional
things.</p>
<p><strong>Finish What You Start</strong></p>
<p>Where possible, the routine or object that allocates a resource should
be responsible for deallocating it.</p>
<p><strong>Minimize Coupling Between Modules</strong></p>
<p>Avoid coupling by writing &quot;shy&quot; code and applying the Law of Demeter.</p>
<p><strong>Configure, Don't Integrate</strong></p>
<p>Implement technology choices for an application as configuration
options, not through integration or engineering.</p>
<p><strong>Put Abstractions in Code, Details in Metadata</strong></p>
<p>Program for the general case, and put the specifics outside the compiled
code base.</p>
<p><strong>Analyze Workflow to Improve Concurrency</strong> Exploit concurrency in your
user's workflow.</p>
<p><strong>Design Using Services</strong></p>
<p>Design in terms of services---independent, concurrent objects behind
well-defined, consistent interfaces.</p>
<p><strong>Always Design for Concurrency</strong></p>
<p>Allow for concurrency, and you'll design cleaner interfaces with fewer
assumptions.</p>
<p><strong>Separate Views from Models</strong></p>
<p>Gain flexibility at low cost by designing your application in terms of
models and views.</p>
<p><strong>Use Blackboards to Coordinate Workflow</strong></p>
<p>Use blackboards to coordinate disparate facts and agents, while
maintaining independence and isolation among participants.</p>
<p><strong>Don't Program by Coincidence</strong></p>
<p>Rely only on reliable things. Beware of accidental complexity, and
don't confuse a happy coincidence with a purposeful plan.</p>
<p><strong>Estimate the Order of Your Algorithms</strong></p>
<p>Get a feel for how long things are likely to take before you write code.</p>
<p><strong>Test Your Estimates</strong></p>
<p>Mathematical analysis of algorithms doesn't tell you everything. Try
timing your code in its target environment.</p>
<p><strong>Refactor Early, Refactor Often</strong></p>
<p>Just as you might weed and rearrange a garden, rewrite, rework, and
re-architect code when it needs it. Fix the root of the problem.</p>
<p><strong>Design to Test</strong></p>
<p>Start thinking about testing before you write a line of code.</p>
<p><strong>Test Your Software, or Your Users Will</strong></p>
<p>Test ruthlessly. Don't make your users find bugs for you.</p>
<p><strong>Don't Use Wizard Code You Don't Understand</strong></p>
<p>Wizards can generate reams of code. Make sure you understand all of it
before you incorporate it into your project.</p>
<p><strong>Don't Gather Requirements--Dig for Them</strong></p>
<p>Requirements rarely lie on the surface. They're buried deep beneath
layers of assumptions, misconceptions, and politics.</p>
<p><strong>Workwith a User to Think Like a User</strong></p>
<p>It's the best way to gain insight into how the system will really be
used.</p>
<p><strong>Abstractions Live Longer than Details</strong></p>
<p>Invest in the abstraction, not the implementation. Abstractions can
survive the barrage of changes from different implementations and new
technologies.</p>
<p><strong>Use a Project Glossary</strong></p>
<p>Create and maintain a single source of all the specific terms and
vocabulary for a project.</p>
<p><strong>Don't Think Outside the Box--Find the Box</strong></p>
<p>When faced with an impossible problem, identify the real constraints.
Ask yourself: &quot;Does it have to be done this way? Does it have to be
done at all?&quot;</p>
<p><strong>Start When You're Ready.</strong></p>
<p>You've been building experience all your life. Don't ignore niggling
doubts.</p>
<p><strong>Some Things Are Better Done than Described</strong></p>
<p>Don't fall into the specification spiral---at some point you need to
start coding.</p>
<p><strong>Don't Be a Slave to Formal Methods.</strong></p>
<p>Don't blindly adopt any technique without putting it into the context
of your development practices and capabilities.</p>
<p><strong>Costly Tools Don't Produce Better Designs</strong></p>
<p>Beware of vendor hype, industry dogma, and the aura of the price tag.
Judge tools on their merits.</p>
<p><strong>Organize Teams Around Functionality</strong></p>
<p>Don't separate designers from coders, testers from data modelers. Build
teams the way you build code.</p>
<p><strong>Don't Use Manual Procedures</strong></p>
<p>A shell script or batch file will execute the same instructions, in the
same order, time after time.</p>
<p><strong>Test Early. Test Often. Test Automatically</strong></p>
<p>Tests that run with every build are much more effective than test plans
that sit on a shelf.</p>
<p><strong>Coding Ain't Done 'Til All the Tests Run</strong> 'Nuff said.</p>
<p><strong>Use Saboteurs to Test Your Testing</strong></p>
<p>Introduce bugs on purpose in a separate copy of the source to verify
that testing will catch them.</p>
<p><strong>Test State Coverage, Not Code Coverage</strong></p>
<p>Identify and test significant program states. Just testing lines of code
isn't enough.</p>
<p><strong>Find Bugs Once</strong></p>
<p>Once a human tester finds a bug, it should be the last time a human
tester finds that bug. Automatic tests should check for it from then on.</p>
<p><strong>English is Just a Programming Language</strong></p>
<p>Write documents as you would write code: honor the DRY principle, use
metadata, MVC, automatic generation, and so on.</p>
<p><strong>Build Documentation In, Don't Bolt It On</strong></p>
<p>Documentation created separately from code is less likely to be correct
and up to date.</p>
<p><strong>Gently Exceed Your Users' Expectations</strong></p>
<p>Come to understand your users' expectations, then deliver just that
little bit more.</p>
<p><strong>Sign Your Work</strong></p>
<p>Craftsmen of an earlier age were proud to sign their work. You should
be, too.</p>
<p><strong>Languages To Learn</strong></p>
<p>Tired of C, C++, and Java? Try CLOS, Dylan, Eiffel, Objective C, Prolog,
Smalltalk, or TOM. Each of these languages has different capabilities
and a different &quot;flavor.&quot; Try a small project at home using one or
more of them.</p>
<p><strong>The WISDOM Acrostic</strong></p>
<p><strong>W</strong>hat do you want them to learn?</p>
<p>What <strong>i</strong>s their interest in what you've got to say?</p>
<p>How <strong>s</strong>ophisticated are they?</p>
<p>How much <strong>d</strong>etail do they want?</p>
<p>Whom do you want to <strong>o</strong>wn the information?</p>
<p>How can you <strong>m</strong>otivate them to listen to you?</p>
<p><strong>How to Maintain Orthogonality</strong></p>
<blockquote>
<p>Design independent, well-defined components.</p>
<p>Keep your code decoupled.</p>
<p>Avoid global data.</p>
<p>Refactor similar functions.</p>
</blockquote>
<p><strong>Things to prototype</strong></p>
<blockquote>
<p>Architecture</p>
<p>New functionality in an existing system</p>
<p>Structure or contents of external data</p>
<p>Third-party tools or components Performance issues</p>
<p>User interface design</p>
</blockquote>
<p><strong>Architectural Questions</strong></p>
<blockquote>
<p>Are responsibilities well defined?</p>
<p>Are the collaborations well defined?</p>
<p>Is coupling minimized?</p>
<p>Can you identify potential duplication?</p>
<p>Are interface definitions and constraints acceptable? Can modules
access needed data---when needed?</p>
</blockquote>
<p><strong>Debugging Checklist</strong></p>
<blockquote>
<p>Is the problem being reported a direct result of the underlying bug,
or merely a symptom?</p>
<p>Is the bug really in the compiler? Is it in the OS? Or is it in your
code?</p>
<p>If you explained this problem in detail to a coworker, what would you
say?</p>
<p>If the suspect code passes its unit tests, are the tests complete
enough? What happens if you run the unit test with this data? Do the
conditions that caused this bug exist anywhere else in the system?</p>
</blockquote>
<p><strong>Law of Demeter for Functions</strong></p>
<p>An object's method should call only methods belonging to:</p>
<blockquote>
<p>Itself</p>
<p>Any parameters passed in</p>
<p>Objects it creates</p>
<p>Component objects</p>
</blockquote>
<p><strong>How to Program Deliberately</strong></p>
<blockquote>
<p>Stay aware of what you're doing.</p>
<p>Don't code blindfolded.</p>
<p>Proceed from a plan.</p>
<p>Rely only on reliable things.</p>
<p>Document your assumptions.</p>
<p>Test assumptions as well as code.</p>
<p>Prioritize your effort.</p>
<p>Don't be a slave to history.</p>
</blockquote>
<p><strong>When to Refactor</strong></p>
<blockquote>
<p>You discover a violation of the DRY principle.</p>
<p>You find things that could be more orthogonal.</p>
<p>Your knowledge improves.</p>
<p>The requirements evolve.</p>
<p>You need to improve performance.</p>
</blockquote>
<p><strong>Cutting the Gordian Knot</strong></p>
<p>When solving <em>impossible</em> problems, ask yourself:</p>
<blockquote>
<p>Is there an easier way?</p>
<p>Am I solving the right problem?</p>
<p>Why is this a problem?</p>
<p>What makes it hard?</p>
<p>Do I have to do it this way?</p>
<p>Does it have to be done at all?</p>
</blockquote>
<p><strong>Aspects of Testing</strong></p>
<blockquote>
<p>Unit testing</p>
<p>Integration testing</p>
<p>Validation and verification</p>
<p>Resource exhaustion, errors, and recovery</p>
<p>Performance testing</p>
<p>Usability testing</p>
<p>Testing the tests themselves</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="throughput--latency"><a class="header" href="#throughput--latency">Throughput &amp; Latency</a></h1>
<h2 id="𝗧𝗵𝗿𝗼𝘂𝗴𝗵𝗽𝘂𝘁-is-the-amount-of-data-a-system-processes-within-a-given-period"><a class="header" href="#𝗧𝗵𝗿𝗼𝘂𝗴𝗵𝗽𝘂𝘁-is-the-amount-of-data-a-system-processes-within-a-given-period">𝗧𝗵𝗿𝗼𝘂𝗴𝗵𝗽𝘂𝘁 is the amount of data a system processes within a given period</a></h2>
<p>It's measured in transactions per second (TPS), requests per second (RPS), or data units per second.</p>
<p>High throughput means the system can handle more requests in less time.</p>
<p>𝗧𝗵𝗶𝗻𝗴𝘀 𝘁𝗵𝗮𝘁 𝘄𝗶𝗹𝗹 𝗵𝗲𝗹𝗽 𝘆𝗼𝘂 𝘁𝗼 𝗶𝗻𝗰𝗿𝗲𝗮𝘀𝗲 𝗧𝗵𝗿𝗼𝘂𝗴𝗵𝗽𝘂𝘁:</p>
<p>- Horizontal Scaling (Adding More Machines)<br />
- Load Balancing<br />
- Asynchronous Processing or message queues</p>
<h2 id="𝗟𝗮𝘁𝗲𝗻𝗰𝘆-is-the-time-taken-to-process-a-single-operation-or-request"><a class="header" href="#𝗟𝗮𝘁𝗲𝗻𝗰𝘆-is-the-time-taken-to-process-a-single-operation-or-request">𝗟𝗮𝘁𝗲𝗻𝗰𝘆 is the time taken to process a single operation or request</a></h2>
<p>It's usually measured in milliseconds or microseconds.</p>
<p>Low latency is essential in systems with critical response time, like high-frequency trading systems.</p>
<p>𝗧𝗵𝗶𝗻𝗴𝘀 𝘁𝗵𝗮𝘁 𝘄𝗶𝗹𝗹 𝗵𝗲𝗹𝗽 𝘆𝗼𝘂 𝗿𝗲𝗱𝘂𝗰𝗲 𝗟𝗮𝘁𝗲𝗻𝗰𝘆:</p>
<p>- Optimizing Code<br />
- Using Faster Storage<br />
- Database Performance Tuning<br />
- Caching</p>
<h2 id="𝗕𝗮𝗹𝗮𝗻𝗰𝗶𝗻𝗴-𝘁𝗵𝗲𝘀𝗲-𝘁𝘄𝗼-𝗼𝗳𝘁𝗲𝗻-𝗶𝗻𝘃𝗼𝗹𝘃𝗲𝘀-𝘁𝗿𝗮𝗱𝗲-𝗼𝗳𝗳𝘀"><a class="header" href="#𝗕𝗮𝗹𝗮𝗻𝗰𝗶𝗻𝗴-𝘁𝗵𝗲𝘀𝗲-𝘁𝘄𝗼-𝗼𝗳𝘁𝗲𝗻-𝗶𝗻𝘃𝗼𝗹𝘃𝗲𝘀-𝘁𝗿𝗮𝗱𝗲-𝗼𝗳𝗳𝘀">𝗕𝗮𝗹𝗮𝗻𝗰𝗶𝗻𝗴 𝘁𝗵𝗲𝘀𝗲 𝘁𝘄𝗼 𝗼𝗳𝘁𝗲𝗻 𝗶𝗻𝘃𝗼𝗹𝘃𝗲𝘀 𝘁𝗿𝗮𝗱𝗲-𝗼𝗳𝗳𝘀</a></h2>
<p>Asynchronous processing can increase throughput but might add to latency for individual tasks.</p>
<p>Extensive caching can reduce latency but requires more memory resources if not managed.</p>
<p>There's often a trade-off between maximizing throughput and minimizing latency.</p>
<p><img src="architecture%5CReference/image-25.png" alt="Alt text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-wild-world-of-unique-identifiers-uuid-ulid-etc"><a class="header" href="#the-wild-world-of-unique-identifiers-uuid-ulid-etc">The Wild World of Unique Identifiers (UUID, ULID, etc)</a></h1>
<p>Every once in a while as a developer you find yourself stepping, and falling, into a much deeper rabbit hole than you would expect. I recently had one of these experiences as I have dug into the world of unique identifiers. It is this rabbit hole that I would like to take you down for a bit as well. Unique identifiers are everywhere in our code and our data storage and through better understanding what they are and the trade-offs between them we can make more educated decisions in our day-to-day work.</p>
<h2 id="where-we-began"><a class="header" href="#where-we-began">Where we began:</a></h2>
<p>Historically a lot of software has used incrementing numbers to represent the identifier of a particular piece of data. They can be auto-generated by many data stores, they are easy to reason about, are efficient to store and sort, are naturally time ordered, and can be easy to say (ex: “Hey Marsha, can you take a look at record 3162?”). It is for many of these reasons that the industry used these identifiers for so long.</p>
<p>That being said, there are also downsides to using incrementing numbers as identifiers especially as we start working in “web-scale” applications. Due to the sequential nature of data you often aren’t able to generate these identifiers concurrently. You could use techniques like skipping so many values for each generation and having different starting points for each generator or starting at different numbers but these all have various shortcomings as well versus a system that could generate identifiers without any coordination. If you separate the work of ID generation to another system that system could become a single point of failure and/or slow down the performance of your application as you need to make round trips between the requesting application and the ID generation system.</p>
<p>Incrementing IDs also can lead to data leakage in that you now have easily guessable identifiers in URLs or other locations that people can exploit to test out your defenses. They can also divulge the size of your dataset. For example, if I sign up for an account with a website and the profile page’s URL ends with <code>user/515</code>I can make the educated guess that there are 515 accounts on the service. The less information you can give an adversary the better. I have actually stumbled upon production systems that were easily exploitable via lacking authorization and using incrementable identifiers. This particular system included personal information about employees of another company and thankfully after disclosing this vulnerability to the company they were able to patch the issue. That is not to say if you were using a non-guessable identifier you don’t need authorization checks but it does add another layer to get through.</p>
<h2 id="uuids-to-the-rescue"><a class="header" href="#uuids-to-the-rescue">UUIDs to the rescue?</a></h2>
<p>For all the above reasons many different applications needed to find another way to generate unique identifiers while allowing data hiding and scalability. Enter <a href="https://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a> UUIDs. UUID are identifiers backed by a 128-bit value typically expressed as a 32 hexadecimal characters generated via random or time-based means. They look something like: <code>93f9a654-7467-46de-9964-f30a66104dd9.</code>These identifiers have numerous benefits:</p>
<ul>
<li>Many different processes can generate identifiers concurrently without coordination with an extremely low chance of collisions.</li>
<li>They are less guessable than sequential IDs.</li>
<li>They don’t give you a sense of the size of the dataset.</li>
<li>They are still reasonably small when compared to a 32 random character identifier. They are also much easier for a database engine to compare than 32 characters of text.</li>
</ul>
<p>Given the definition of a UUID as a 128-bit number generated via time and randomness-based methods you may think there could be many ways of going about this and you would be correct. There are several official versions of UUID:</p>
<ul>
<li>Type 1 — ID is based on the generating host’s MAC address and a timestamp. Reasonable choice for concurrent generation but falls flat on the low guessability spectrum.</li>
<li>Type 2 — The often ignored version as there isn’t a formal definition of it in the RFC and thus is ignored by many UUID tools but there is a definition provided by the <a href="https://pubs.opengroup.org/onlinepubs/9696989899/chap5.htm#tagcjh_08_02_01_01">DCE 1.1 Authentication and Security Services specification</a>. It uses a host’s MAC address, timestamp, a “local domain” number, and “integer identifier meaningful within the specified local domain”</li>
<li>Type 3 — Generated via an MD5 hash of a provided input data. This allows the generation of the same UUID based on the same input.</li>
<li>Type 4 — Entirely random data is used to generate the bits of the changing part of the UUID</li>
<li>Type 5 — Like type 3 it is based on an input value but in this case it is SHA-1 hashed which is a better hashing algorithm for this use case than MD5 so it should be preferred over Type 3.</li>
</ul>
<p>Basically any modern language has built-in functionality to generate one or multiple of these types of UUIDs or there are readily available libraries to facilitate their generation. We also have first-class support for UUID in many database platforms.</p>
<p>There are downsides to UUIDs though. Although they are reasonably small they still take up much more space than many other identifiers. Their random nature also makes them particularly troublesome for relational databases to handle as, especially if they are used in a clustered index, they can force the reordering in its internal data structures to put in new entries. In general this lack of built-in sortability based on time becomes the root of a lot of issues. In a lot of circumstances you may not already have another piece of data to sort based on and you are forced to add one because your identifier can’t also facilitate the process even though it feels like it could.</p>
<h2 id="a-world-beyond-uuids"><a class="header" href="#a-world-beyond-uuids">A World Beyond UUIDs</a></h2>
<p>For the reasons above and many others, UUIDs aren’t a one-size-meets-all solution. Thus, unsurprisingly, many other implementations of identifier generation have been created and there is an <a href="https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format#ref-LexicalUUID">IETF RFC</a> that details that a UUID version more appropriate to be used as a database key with an ordering component should be decided upon (update: they have a <a href="https://kylec32.medium.com/analyzing-new-unique-identifier-formats-uuidv6-uuidv7-and-uuidv8-d6cc5cd7391a">draft specification</a>). As part of this RFC, it refers to a number of existing implementations as prior art. Let’s consider a few of them:</p>
<h2 id="ulid-reference"><a class="header" href="#ulid-reference">ULID (<a href="https://github.com/ulid/spec">reference</a>)</a></h2>
<p>Unique Lexicographically IDentifiers (<a href="https://github.com/ulid/spec">ULID</a>) are one such attempt at solving some of the above UUID issues. They are made up of two components, a Unix millisecond-level timestamp and a random portion put together like below.</p>
<pre><code class="language-bash">01AN4Z07BY      79KA1307SR9X4MV3  
  
|----------|    |----------------|  
 Timestamp          Randomness  
   48bits             80bits
</code></pre>
<p>Benefits:</p>
<ul>
<li>Lexicographical (Alphabetical) sorting.</li>
<li>Commonly encoded in 26 characters vs the 36 characters of UUID</li>
<li>Monotonic sort order. (The code handles the case of multiple generations per millisecond and making sure they sort in that particular order)</li>
<li>Being 128 bits they are compatible with UUIDs 128 bits.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>They are required to be compared case insensitively. This could be a potential gotcha for implementing developers.</li>
<li>They still weigh in at 128 bits making them no smaller than UUIDs.</li>
</ul>
<h2 id="snowflake-twitters-now-defunct-solution"><a class="header" href="#snowflake-twitters-now-defunct-solution"><a href="https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake">Snowflake</a> (Twitter’s now <a href="https://github.com/twitter-archive/snowflake">defunct</a> solution)</a></h2>
<p>Although it’s no longer supported I think it’s intriguing to look at Twitter’s Snowflake service that they historically used for the generation of tweet IDs. Twitter seemed to be a trend setter with this solution as you will see below a lot of other solutions built on top of the ideas of Snowflake. Snowflake worked as a Thrift service that used Zookeeper to facilitate a cluster of services that could be used for quickly retrieving new identifiers.</p>
<p>Benefits:</p>
<ul>
<li>The identifiers were 64 bits, half the size of UUIDs, allowing for more efficient storage.</li>
<li>Fairly strong ordering guarantees.</li>
<li>Distributed in a way that allows survival of losing a node.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>It introduces the complexity of monitoring and maintaining a Zookeeper cluster which if a particular company didn’t already have could be a large burden.</li>
<li>You also need to maintain a cluster of identifier generation services (the actual Snowflake servers)</li>
<li>The complexity and requirements of a distributed system are now part of your identitifer generation solution with cross cluster communication and other complexities.</li>
</ul>
<p>Although no longer supported, you can see the original code <a href="https://github.com/twitter-archive/snowflake/tree/snowflake-2010">here</a>.</p>
<h2 id="flickrs-ticket-server-blog-post"><a class="header" href="#flickrs-ticket-server-blog-post">Flickr’s Ticket Server (<a href="https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/">blog post</a>)</a></h2>
<p>This is much more of a pattern than a particular tool or library. The basic idea of the ticket server is to have a service that is backed by a database that has an auto incrementing column maintained by the database engine that gets meted out to requesters. Now you can focus exclusively on optimizing this very specific use case and put off much of the heavy lifting to the database engine. In Flickr’s case, they load-balanced between two different service instances, one that did odd numbers and one that did even numbers to allow some resilience and load balancing.</p>
<p>Benefits:</p>
<ul>
<li>You can set how big you want your identifier to be. (In Flickr’s blog post they set it to 20 bits)</li>
<li>There are minimal moving parts.</li>
<li>It allows for some resilience if you break up the keyspace.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>If you want to add more backing services it could be difficult as you need to change them all together so they don’t clash.</li>
<li>Strong ordering is only guarenteed only within a single keyspace so if you split it in half like Flickr did you can end up with half your key space quite divered from the other half of your keyspace.</li>
<li>This is still the maintenance overhead of maintaining the ticket servers and DBs. Although less than something like Snowflake it is more than a lot of the other solutions that will be discussed.</li>
</ul>
<h2 id="lexicaluuid-part-of-cassie-from-twitter"><a class="header" href="#lexicaluuid-part-of-cassie-from-twitter">LexicalUUID (Part of <a href="https://github.com/twitter-archive/cassie">Cassie</a> from Twitter)</a></h2>
<p>Twitter has put a lot of thought and work into unique ID generation as we see another reference to Twitter’s tooling here in this list. This time as part of its client library for Cassandra. Unlike Snowflake, these are 128 bits like traditional UUIDs. The most significant 64 bits are a timestamp retrieved from Cassie’s built-in internal clock implementation and the least significant 64 bits are based on the worker ID.</p>
<p>Benefits:</p>
<ul>
<li>It does not seem to require any additional infrastructure like Snowflake.</li>
<li>128 bits makes it compatible with other UUID implementations.</li>
<li>Gives you a strong time ordering guarantee within the same worker and weak ordering guarantees across works.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>Just as many bits as UUID</li>
<li>Not strict ordering guarantees.</li>
<li>Seems tightly coupled with the Cassie library.</li>
</ul>
<h2 id="flake-reference"><a class="header" href="#flake-reference">Flake (<a href="https://web.archive.org/web/20150425090303/http://www.boundary.com/blog/2012/01/flake-a-decentralized-k-ordered-unique-id-generator-in-erlang/">reference</a>)</a></h2>
<p>Another defunct tool/company but always something new to learn from these tools. As the name suggests this particular implementation takes its origins from Twitter’s Snowflake discussed above. It however makes some changes. It moves back up to 128 bits and with that trade-off it can avoid any coordination between nodes. The results are still roughly time ordered. It is formatted as follows: 64 bit Unix timestamp, 48-bit worker ID (based on MAC address), and 16-bit sequence. It was also implemented in Erlang so that’s another fun piece of information.</p>
<p>Benefits:</p>
<ul>
<li>No coordination is needed between generation nodes.</li>
<li>128 bit compatible with UUID</li>
<li>Roughly time ordered.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>Predictable by design (very much built like a UUIDv1 but done so that it can be roughly time sorted)</li>
<li>Still 128 bits.</li>
<li>Not exactly time ordered.</li>
</ul>
<h2 id="instagrams-shardingid-blog-post"><a class="header" href="#instagrams-shardingid-blog-post">Instagram’s ShardingID (<a href="https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c">blog post</a>)</a></h2>
<p>To make sense of Instagram’s system you have to understand somewhat how they shard their databases. They have created thousands of “logical” shards of their data that each represents part of their data. These logical shards end up being schema’s in their databases so they could have from 1 — # of shards physical database engines behind their data to split between. It’s a fairly simple concept but a powerful one I would say. Instagram wanted to optimize for simplicity so they wanted to stay away from bringing in new tools and services to support. What they ended up with was a 64-bit identifier. The first 41 bits represent a timestamp in milliseconds (which gives them 41 years of IDs because they use a custom epoch), 13 bits as the logical shard id, and the final 10 bits serve as a sequence number for the value within the millisecond. They then wrote a custom PL/PGSQL function that generates these values within their database.</p>
<p>Benefits:</p>
<ul>
<li>No coordination is needed between servers.</li>
<li>Uses existing infrastructure</li>
<li>64-bit identifier.</li>
<li>Extremely simple to use.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>Strongly relies on their logical sharding system.</li>
<li>41 years doesn’t seem like a whole lot of time to be acceptable.</li>
</ul>
<h2 id="ksuid-reference"><a class="header" href="#ksuid-reference">KSUID (r<a href="https://github.com/segmentio/ksuid">eference</a>)</a></h2>
<p>Another generally sortable unique identifier generation tool. It uses 160 bits. A 32-bit timestamp and then 128 bits of random-based payload. It uses a modified epoch for its timestamp, giving it over 100 years of life. The text representation is 27 characters with the bits being encoded with base62 which makes it also generically time sortable via its string representation as well.</p>
<p>Benefits:</p>
<ul>
<li>Coordination free</li>
<li>Long life</li>
</ul>
<p>Downsides:</p>
<ul>
<li>At 160 bits it’s larger than UUID’s 128</li>
</ul>
<h2 id="elasticflake-reference"><a class="header" href="#elasticflake-reference">ElasticFlake (<a href="https://github.com/ppearcy/elasticflake">reference</a>)</a></h2>
<p>This library is an extraction of the identifier generation code from ElasticSearch. It ends up being 120 bits with 48 bits of timestamp, a 48 bit MAC address, and 24 bits for a sequence at the end.</p>
<p>Benefits:</p>
<ul>
<li>Slightly smaller than UUID</li>
<li>Battle-hardened inside of ElasticSearch.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>MAC addresses give predictability to identifiers.</li>
</ul>
<h2 id="flake-idgen-reference"><a class="header" href="#flake-idgen-reference">Flake IDGen (<a href="https://github.com/T-PWK/flake-idgen">reference</a>)</a></h2>
<p>This identifier generation method brings in the concept of data centers as part of the identifier. The only reason I would think you would want this would be to be able to determine where an identifier was generated although I’m not sure why that would be useful. This can be useful internally but also perpetuate one of the downsides of some of the UUID versions in that they expose information. These are generated as 64-bit identifiers with a 42-bit timestamp, a 5-bit datacenter identifier, a 5-bit worker identifier, and a 12 bit counter.</p>
<p>Benefits:</p>
<ul>
<li>Only 64 bits.</li>
<li>Allows tracking back to which data center generated an identifier.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>Less room for workers and sequence counts.</li>
<li>Exposes more information than a lot of the other methods.</li>
</ul>
<h2 id="sonyflake-reference"><a class="header" href="#sonyflake-reference"><a href="https://github.com/sony/sonyflake">Sonyflake (reference)</a></a></h2>
<p>Next, we get Sony’s take on Twitter’s Snowflake pattern. This time we have 63 bits which is intriguing. Another interesting piece to this one is that the timestamp is scoped down to 10-millisecond buckets rather than down to the millisecond like most of the other systems discussed here. This gives it a longer life (174 years). The bit layout is as follows: 39 bits of timestamp, 8 bits for sequence numbers, 16 bits as a worker ID.</p>
<p>Benefits:</p>
<ul>
<li>Quite small.</li>
<li>Coordination free.</li>
<li>Long life (174 years)</li>
<li>Can handle more workers than Snowflake.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>Timestamp can only be scoped to 10-millisecond buckets.</li>
<li>Fewer identifiers can be generated in a particular 10 millisecond period due to smaller sequence.</li>
</ul>
<h2 id="ordereduuid-reference"><a class="header" href="#ordereduuid-reference">OrderedUUID (<a href="https://itnext.io/laravel-the-mysterious-ordered-uuid-29e7500b4f8">reference</a>)</a></h2>
<p>We now look at Laravel’s OrderedUUID. This one takes the unique goal of wanting to look and act like a UUIDv4 that just so happens to have time-based higher-order bits. This being the goal its String representation looks exactly like a UUIDv4 and it includes the version and variant identifiers required by the UUID specification. The way it is built however is different. The first 48 bits are the timestamp, it has 72 bits of randomness, and then the UUIDv4 required pieces take up the remaining 8 bits.</p>
<p>Benefits:</p>
<ul>
<li>No coordination is needed.</li>
<li>Identical to UUIDs, thus support is not needed for a new scheme for consumers of the IDs.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>Still 128 bits.</li>
<li>Being so identical to UUIDv4 I think it could be easy to mix up and not be able to tell what you were looking at.</li>
<li>Exposes generation time if that is a concern (it does not expose a sequence though)</li>
</ul>
<h2 id="combguid-reference"><a class="header" href="#combguid-reference">COMBGUID (<a href="https://github.com/richardtallent/RT.Comb">reference</a>)</a></h2>
<p>These identifiers come from the SQL Server world. Presented with the problems of clustered indexes as well as the shortcomings of <code>newsequentialid</code> with not having true ordering, this identifier was born. This identifier devotes 76 bits to randomness and 48 bits to the timestamp, the last 4 bits are for the UUID identifier.</p>
<p>Benefits:</p>
<ul>
<li>Generally ordered IDs.</li>
<li>Looks like and validates like a UUID</li>
</ul>
<p>Downsides</p>
<ul>
<li>Timestamp goes down to the 1/300th of a second which isn’t millisecond precision that others provide.</li>
</ul>
<h2 id="pushid-reference"><a class="header" href="#pushid-reference">pushID (<a href="https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html">reference</a>)</a></h2>
<p>This one comes to us courtesy of Google, specifically Firebase. These IDs are used to allow extremely concurrent interactions with a data structure by many remote clients. These identifiers are generated client-side and are 120 bits. The first 48 bits represent a millisecond precision timestamp and the following 72 bits are random bits. They also can handle generation within the same millisecond by simply incrementing the random bits. With clients creating the timestamps I think the ordering guarantees in this system are probably weaker than environments where the timestamp generation is more tightly controlled but it is still likely generally in the right direction.</p>
<p>Benefits:</p>
<ul>
<li>Only 120 bits.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>Client-side generation of this particular implementation brings its own troubles.</li>
</ul>
<h2 id="objectid-reference"><a class="header" href="#objectid-reference">ObjectId (<a href="https://docs.mongodb.com/manual/reference/method/ObjectId/">reference</a>)</a></h2>
<p>Now we have an identifier generation from MongoDB. This one weighs in at 96 bits. We have 32 bits of timestamp, 40 bits of randomness, and 24 bits of an incrementing value initialized to a random value. All of this is represented in a 24 character hexadecimal string.</p>
<p>Benefits:</p>
<ul>
<li>96 bits is smaller than many options.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>On the lower side of random bits.</li>
</ul>
<h2 id="xid-reference"><a class="header" href="#xid-reference">xid (<a href="https://github.com/rs/xid">reference</a>)</a></h2>
<p>This claims to be an iteration on Mongo’s ObjectId discussed above and simply changes the encoding scheme to String to instead use Base32 hex to take the string representation from 24 to 20 characters long. That being said, it does describe its bit structure differently than ObjectId does. Its bits are laid out as follows: 32-bit timestamp, 24-bit machine identifier, 16-bit process id, and 24-bits as an incrementing value starting at a random value.</p>
<p>Benefits:</p>
<ul>
<li>Smaller string representation than ObjectId and smaller than most.</li>
<li>96 bits is smaller than many options</li>
<li>Claims to be bit compatible with ObjectId</li>
</ul>
<p>Downsides:</p>
<ul>
<li>No randomness thus it is very predictable.</li>
</ul>
<h2 id="cuid-reference"><a class="header" href="#cuid-reference">cuid (<a href="https://github.com/ericelliott/cuid">reference</a>)</a></h2>
<p>This identifier generation process seems to be focused on the text representation along with order. It comes out with a 25 character identifier with the following structure. Always starts with the character <code>c</code> , eight characters of timestamp, a four-digit counter that rolls over, four characters for a client fingerprint, and 8 characters of randomness.</p>
<p>Benefits:</p>
<ul>
<li>Seems to have first-class support for generation via client-side Javascript.</li>
<li>Less focus on the actual bits makes it a little easier to reason about.</li>
</ul>
<p>Downsides:</p>
<ul>
<li>Seems to be more of a wild west of what all the pieces mean and how they are encoded. (ex: How do you create a client fingerprint, etc)</li>
</ul>
<h2 id="so-which-one-do-we-choose"><a class="header" href="#so-which-one-do-we-choose">So which one do we choose?</a></h2>
<p>There are a ton of options to choose from. Some are extremely different in their implementations and some are only different in the slightest of ways. What is clear is you need to know what you are optimizing for in your environment before choosing a identifier generation algorithm. Are you looking for the absolute smallest space-taking identifier possible? Are you trying to use the same tools you are already using or are you open to bringing in new tools? How many identifiers will be generated in a second? How in order should they attempt to be? All important questions and the answers will be different for each environment. I love how much sharing of ideas there is in the world and how we can learn from all of these uses cases and we all can build on the shoulders of those that went before us.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="globally-unique-identifier-a-fair-comparison"><a class="header" href="#globally-unique-identifier-a-fair-comparison">Globally Unique Identifier a fair comparison</a></h1>
<p><img src="architecture%5CReference/image-56.png" alt="Alt text" /></p>
<p>The idea behind this article is to share the little I learned about GUID implementations and provide education to others.</p>
<p><em>Disclaimer: Although I carry good security foundations, I am not a cryptography expert, please take this data with a grain of salt and build your own opinions.</em></p>
<h1 id="why-do-you-need-a-guid"><a class="header" href="#why-do-you-need-a-guid">Why do you need a GUID?</a></h1>
<p>GUID (Globally Unique Identifier) are generators for identifiers typically used as primary keys in databases. GUID solve problems typically inherent to three tiers architectures, more precisely:</p>
<ol>
<li><strong>Scalability</strong> — growing hardware vertically has its limits, soon or later multiple instances are required to sustain the load. Centralized id generators have a significant (negative) impact on performance. GUID typically allow distributing generators across multiple instances.</li>
<li><strong>Resilience</strong> — the ability to run multiple instances of a generator is a great way to improve its availablity and avoid a single point of failure.</li>
<li><strong>Security</strong> — sequences are trivial to predict, in a distributed world different sources of entropy are used to guarantee uniqueness via a random, difficult to predict (long) string.</li>
</ol>
<h1 id="how-are-guid-different-from-db-sequences"><a class="header" href="#how-are-guid-different-from-db-sequences">How are GUID different from DB SEQUENCES?</a></h1>
<p><em>Sequences is a RDBMS centric solution to ease primary key generation.</em></p>
<p><img src="architecture%5CReference/image-57.png" alt="Alt text" /></p>
<p>Sequences vs GUID</p>
<p>Sequence were great for a single database supporting an internal application to local users. Nowadays, OLTP data is secured, distributed, scalable and exposed to the world. These is still place for them in a DWH or other data OLAP storages.</p>
<p><em>Since this article is about GUID I wont’ extend more on this topic, I added a great article —</em> <a href="https://infosecwriteups.com/how-this-easy-vulnerability-resulted-in-a-20-000-bug-bounty-from-gitlab-d9dc9312c10a"><em>The hidden dangers of numerical IDs</em></a></p>
<h1 id="what-are-the-categories-of-guid"><a class="header" href="#what-are-the-categories-of-guid">What are the categories of GUID?</a></h1>
<p>There are mainly two categories of GUIDs: <strong>Opaque</strong> and <strong>time-based</strong>. Time based GUID trade a few bits of entropy to encode a date, they are therefore more efficient to index at the cost of a shorter randomness range.</p>
<p><img src="architecture%5CReference/image-58.png" alt="Alt text" /></p>
<p>Opaque vs Time-based GUID</p>
<h1 id="features-benefits--shortcomings"><a class="header" href="#features-benefits--shortcomings">Features, Benefits &amp; Shortcomings</a></h1>
<p>The table below provides a comprehensive comparison between the major GUID implementations.</p>
<p><img src="architecture%5CReference/image-55.png" alt="Alt text" /></p>
<p>GUID Comparison table, <em>Please</em> [<em>click on this link for the full version</em>](.\GUID Comaprison.oda)</p>
<h1 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h1>
<p><em>Disclaimer, these benchmark are performed against a given architecture (JavaScript/Arm), different implementations/runtimes will likely give different results.</em></p>
<pre><code>Platform info:  
\==============  
  Darwin 22.2.0 arm64  
  Node.JS: 18.12.1  
  V8: 10.2.154.15\-node.12  
  CPU: Apple M1 Pro × 8  
  Memory: 16 GB  
​  
Running &quot;GUID Benchmark&quot; suite...  
Progress: 100%  
​  
uuid v1:  
  4 460 889 ops/s, ±0.57%   | 63.99% slower  
​  
uuid v4:  
  8 870 032 ops/s, ±0.54%   | 28.41% slower  
​  
uuid v7:  
  443 205 ops/s, ±0.82%     | 96.42% slower  
​  
nanoid:  
  5 300 343 ops/s, ±0.48%   | 57.22% slower  
​  
cuid:  
  347 037 ops/s, ±1.15%     | 97.2% slower  
​  
cuid2:  
  60 490 ops/s, ±0.52%       | slowest, 99.51% slower  
​  
ulid (monotonic):  
  12 389 427 ops/s, ±0.64%   | fastest  
​  
xid:  
  3 417 174 ops/s, ±0.41%   | 72.42% slower  
​  
ksuid:  
  532 223 ops/s, ±1.02%     | 95.7% slower  
​  
Finished 9 cases!  
Fastest: ulid (monotonic)  
Slowest: cuid2
</code></pre>
<p><img src="architecture%5CReference/image-54.png" alt="Alt text" /></p>
<h1 id="thoughts-beyond-theory"><a class="header" href="#thoughts-beyond-theory">Thoughts beyond theory</a></h1>
<p><em>At this point you should have a pretty good idea of the different implementations and how they compare. Let us add some context...</em></p>
<h2 id="are-csprng-implementations-broken"><a class="header" href="#are-csprng-implementations-broken">Are CSPRNG implementations broken?</a></h2>
<p>Some were, others are, mostly in (old) browsers.</p>
<p>Remember that, even if ID generation takes place <strong>server side,</strong> where implementations are more stable and uniform: <strong>you must be vigilant</strong>. <a href="https://v8.dev/blog/math-random">Here</a> is a security post on the topic regarding NodeJS (2015).</p>
<h2 id="is-randomness-a-pledge-for-security"><a class="header" href="#is-randomness-a-pledge-for-security">Is Randomness a pledge for security?</a></h2>
<p>Machines run algorithms that approximate randomness by selecting algorithms and trusted entropy sources. A cryptographically secure pseudo-random number generator (CSPRNG) is a algorithm with properties that make it suitable for use in cryptography. On Linux for instance, the kernel gathers noisy data from various devices and transfers them to an internal pool of entropy.</p>
<p>Unfortunate, not all cryptography stacks are equal. For instance, old versions of CSPRNG are famous for their poor implementations in JavaScript or PHP. Algorithms such as SHA1 also proved to be unsecured but are still used today in some GUID generators.</p>
<p>While ensuring that a GUID generator is cryptography certified is important, <strong>an ID is nothing in view of a proper security architecture.</strong></p>
<h2 id="what-are-the-odds-of-a-collisions"><a class="header" href="#what-are-the-odds-of-a-collisions">What are the odds of a collisions?</a></h2>
<p>The answer depends on the use case and the specifics of a GUID implementation</p>
<p>With that said, the advertised Math is probably not a good reflection of reality: In an application, a GUID is used to create a multitude of different entities. These entities by definition do not overlap with one another and are therefore in their own <em>space</em>, further reducing the chances of collisions.</p>
<h2 id="is-there-a-risk-to-leak-the-id-generation-date"><a class="header" href="#is-there-a-risk-to-leak-the-id-generation-date">Is there a risk to leak the id generation date?</a></h2>
<p>It all depends on <em>requirements</em>.</p>
<p><strong>From a legal standpoint</strong>, some will argue that the ID generation date is PII data. While this classification could not be validated, a lawyer friend of mine found the argument difficult to defend in a court without considering the complete architecture.</p>
<p><strong>From a security standpoint</strong>, very unlikely but it depends on your use case. Zendesk recently wrote <a href="https://zendesk.engineering/how-probable-are-collisions-with-ulids-monotonic-option-d604d3ed2de">an article on the topic</a>, recommended.</p>
<h2 id="is-there-a-way-to-mitigate-security-and-performance"><a class="header" href="#is-there-a-way-to-mitigate-security-and-performance">Is there a way to mitigate security and performance?</a></h2>
<p>There are designs which leverage different GUID implementations where they best fit. For instance, it is common in cloud database nowadays to provide an out of the box time-based guid. if this implementation is not sufficient to satisfy security requirements, the notion of internal and external id can be implemented on entities.</p>
<p><img src="architecture%5CReference/image-59.png" alt="Alt text" /></p>
<h2 id="is-generation-performance-a-key-factor"><a class="header" href="#is-generation-performance-a-key-factor">Is generation performance a key factor?</a></h2>
<p>In complete honesty, it’s probably not. The fact is, in terms of pseudo-random generation, <strong>velocity is generally not a factor of security.</strong> Besides even the slowest implementation still generates ids at 60000 ops/s on a single machine.</p>
<h1 id="how-to-choose"><a class="header" href="#how-to-choose">How to choose?</a></h1>
<p>With so many dimensions, what are the points to consider?</p>
<ol>
<li><strong>entropy length</strong> — this has direct impact on collisions and predictability, I would recommend avoiding anything with an entropy length &lt; 62 bits unless you understand what you are doing.</li>
<li><strong>random generator quality</strong> — not all random generators are made equal, ensure the implementation uses a cryptography secure random. <a href="https://thenextweb.com/news/google-chromes-javascript-engine-finally-returns-actual-random-numbers">Do not trust!</a> <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=552749">again DO NOT trust!</a></li>
<li><strong>scalability</strong> — with so many options available, I would recommend an implementation which can scale horizontally.</li>
</ol>
<p>The remaining decision points are specific to your requirements.</p>
<p>When ids are stored in a RDBMS database, I had successes with ULID and UUIDv7, for transient ids typically stored in memory or in the browser, I would recommend nanoid.</p>
<h1 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h1>
<p>We reached the end of this article. We learned that picking the right GUID flavor depends entirely on your requirements. You should be vigilent to the constraints of your specific use case, the data being leaked (if any), the CSPRNG implementation it uses or if you plan to store it as a primary key.</p>
<p>If you are still stuck on the UUID vs Sequence as primary key, I added an excellent article in the appendix sections below. In the end it’s (Security, Scalability &amp; Resilience) vs Performance.</p>
<h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<h2 id="articles-of-interests"><a class="header" href="#articles-of-interests">Articles of interests</a></h2>
<ul>
<li><a href="https://darkghosthunter.medium.com/laravel-you-can-now-use-uuid-and-ulid-4ce9d3792fcb#:~:text=While%20an%20ULID%20compatible%20with,for%20your%20database%2C%20be%20prepared.">From UUID to ULID, be prepared</a></li>
<li><a href="https://www.ietf.org/archive/id/draft-peabody-dispatch-new-uuid-format-04.html#name-uuid-version-6">New UUID formats</a></li>
<li><a href="https://github.com/paralleldrive/cuid2">CUID2</a></li>
<li><a href="https://brandur.org/nanoglyphs/026-ids">Identity Crisis: Sequence v. UUID as Primary Key</a></li>
<li><a href="https://infosecwriteups.com/how-this-easy-vulnerability-resulted-in-a-20-000-bug-bounty-from-gitlab-d9dc9312c10a">The hidden dangers of numerical IDs</a></li>
</ul>
<h2 id="definitions"><a class="header" href="#definitions"><em>Definitions</em></a></h2>
<p><em>This section helps clarify some of the terms used in this document.</em></p>
<p>Collisions</p>
<p>A hash collision is a random match in hash values that occurs when a hashing algorithm produces the same hash value for two distinct pieces of data.</p>
<p>Coordination</p>
<p>The communication between the different elements of a complex activity so as to enable them to work together effectively.</p>
<p>Entropy</p>
<p>In Cryptography, refers to the randomness collected by a system for use in algorithms that require random seeds. (jargon word for “randomness”)</p>
<p>Monotonic</p>
<p>A monotonic generator ensures ids are always sorted in order. This term is particularly relevant to date based guid generators which are based on time. For a given instance, at instant T, the next id should always be sorted.</p>
<p>Opaque</p>
<p>An opaque identifier is one that doesn’t expose its inner details or structure.</p>
<p>Pagination</p>
<p>Pagination is a process that is used to divide a large data into smaller discrete pages. Commonly used in customer facing applications, pagination requires the notion of pointers on the dataset.</p>
<p>Predictable</p>
<p>A random number generator is predictable if, after observing some of its “random” output, we can make accurate predictions about what “random values” are coming up next.</p>
<p>Randomness</p>
<p>Randomness (entropy) is the cornerstone of cryptography. The more random the numbers, the more secure the cryptographic system. The challenge then, becomes one of generating true randomness.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-comprehensive-guide-to-mach-architecture-in-2023"><a class="header" href="#a-comprehensive-guide-to-mach-architecture-in-2023">A Comprehensive Guide to MACH Architecture in 2023</a></h1>
<h2 id="mach-microservices-based-api-first-cloud-native-and-headless"><a class="header" href="#mach-microservices-based-api-first-cloud-native-and-headless"><strong>MACH: M</strong>icroservices-Based, <strong>A</strong>PI-First, <strong>C</strong>loud-Native, and <strong>H</strong>eadless</a></h2>
<p><img src="architecture%5CReference/image-41.png" alt="Alt text" /></p>
<p>In the tech world, change is constant.</p>
<p>Technologies come and go, and what was once cutting-edge is replaced by the new and improved. It’s no secret that the technology landscape is constantly evolving, so it’s important for organizations to plan ahead and stay ahead of the curve.</p>
<p>Then the question is, <em>how do you stay ahead of the curve when new technologies are introduced daily?</em></p>
<p>This is where the <strong>MACH Architecture</strong> comes into the picture. MACH architecture is</p>
<ul>
<li>agile</li>
<li>flexible</li>
<li>future-proof</li>
<li>scalable</li>
</ul>
<p>For all these reasons, it’s no secret that MACH architecture is on the rise. With its growing popularity, many people are curious about MACH architecture and how it works.</p>
<p>In this comprehensive guide, we’ll look at <strong>MACH architecture</strong>, how it works, and what benefits it can offer your business in 2023.</p>
<p>Whether you’re just starting out with MACH architecture or you’re looking to expand your knowledge base, this guide has everything you need to get up to speed.</p>
<h1 id="what-is-mach-technology"><a class="header" href="#what-is-mach-technology">What Is MACH Technology?</a></h1>
<p><img src="architecture%5CReference/image-42.png" alt="Alt text" /></p>
<p>If you’re not familiar with composable digital experience space, you might ask yourself, ‘what does MACH mean?’ <strong>MACH</strong> is an acronym that stands for:</p>
<ul>
<li><strong>M</strong>icroservices-Based</li>
<li><strong>A</strong>PI-First</li>
<li><strong>C</strong>loud-Native</li>
<li><strong>H</strong>eadless</li>
</ul>
<p>The <strong>MACH technology</strong> is a powerful approach to software development that focuses on developing microservices-based, API-first, cloud-native applications that are headless. This innovative approach allows developers to create highly scalable, efficient, and flexible applications that can easily adapt to changing business needs.</p>
<p>The MACH technology stems from the principles of agile development, which emphasizes rapid delivery and continuous improvement. By breaking down large applications into smaller modular units called microservices, MACH enables teams to iterate quickly and respond effectively to new requirements or changes in the market.</p>
<h2 id="microservices-based"><a class="header" href="#microservices-based">Microservices-Based</a></h2>
<p>Microservices is an approach to software development whereby an application is decomposed into a number of small, independently developed, and deployable services.</p>
<p>This approach has a number of benefits over traditional, monolithic development techniques.</p>
<p>Firstly, it enables much greater flexibility in terms of deployment and scalability. Secondly, it allows for greater reuse of code and easier maintenance. Finally, it facilitates a more rapid development cycle as features can be developed and deployed independently of one another.</p>
<p>As a result, microservices-based applications are becoming increasingly popular, particularly in the cloud computing domain.</p>
<h2 id="api-first"><a class="header" href="#api-first">API-First</a></h2>
<p>An API-First approach is a strategy for designing and developing software applications in which the application’s programming interface (API) is given priority over other components.</p>
<p>The advantage of this approach is that it allows developers to create an API that can be easily integrated into other software applications, making it easier to share data and functionality between different systems.</p>
<p>In addition, using an API-first approach can also help to ensure that the application’s UI is consistent with the underlying API, making it easier for users to understand and use the application.</p>
<h2 id="cloud-native"><a class="header" href="#cloud-native">Cloud-Native</a></h2>
<p>The term “Cloud-Native” is used to describe applications that are designed specifically for deployment in the cloud.</p>
<p>Cloud-Native apps are typically built using microservices, which are small, self-contained components that can be deployed and scaled independently. This approach differs from traditional monolithic applications, which are large and complex, with tightly coupled dependencies.</p>
<p>Cloud-native apps are also designed to be highly resilient, with each microservice being independently scalable and replaceable. This approach enables organizations to quickly adapt to changing conditions and ensure that their apps remain available even in the event of an outage.</p>
<p>As the demand for cloud-based applications continues to grow, the need for cloud-native solutions will become increasingly important.</p>
<h2 id="headless"><a class="header" href="#headless">Headless</a></h2>
<p>Headless architecture is a type of software architecture that decouples the front-end user interface from the back-end logic enabling a framework-agnostic technology structure.</p>
<p>In a headless system, the backend provides an API that delivers content to the frontend. This separation of concerns allows for greater flexibility and scalability.</p>
<p>By decoupling the frontend and backend, developers can more easily make changes to either one without affecting the other. This approach also makes it easier to scale individual components of the system as needed.</p>
<h1 id="mach-alliance"><a class="header" href="#mach-alliance">MACH Alliance</a></h1>
<p>The <strong>MACH Alliance</strong> is a global industry consortium of forward-thinking organizations that are committed to driving innovation in the rapidly evolving digital landscape and promoting the development of enterprise technology ecosystems that are open and of the best of the breed.</p>
<p>At its core, MACH Alliance is about educating the industry as a whole on what to watch out for while shifting away from legacy infrastructure and turning composable, and helping businesses stay competitive in an increasingly digital world. By embracing emerging technologies like microservices, MACH members gain a significant edge over their competitors by being able to quickly develop and deliver new products and services to customers at scale.</p>
<p>Overall, MACH Alliance is at the forefront of innovation in the digital space, empowering businesses all around the world to thrive in the age of digital transformation. Whether you’re an established enterprise looking for new ways to build competitive advantage or a startup looking for support and guidance as you navigate the rapidly changing digital landscape.</p>
<h1 id="mach-architecture"><a class="header" href="#mach-architecture">MACH Architecture</a></h1>
<h2 id="what-is-mach-architecture"><a class="header" href="#what-is-mach-architecture">What Is MACH Architecture?</a></h2>
<p>The <strong>MACH architecture</strong> is a software architecture that is composed of independent components, meaning it is built from smaller components that can be combined to form a complete system.</p>
<p>This composability allows software systems to be built from interchangeable parts that can be composed into various configurations. The advantage of this approach is that it allows different parts of the system to be continuously improved and optimized for specific purposes, which can lead to better performance and experience overall.</p>
<h2 id="what-are-the-benefits-and-advantages-of-mach-architecture"><a class="header" href="#what-are-the-benefits-and-advantages-of-mach-architecture">What Are the Benefits and Advantages of MACH Architecture?</a></h2>
<p>The advantages and benefits of MACH architecture include the following:</p>
<p><strong>Scalability</strong></p>
<p>MACH architecture is a type of software architecture that is designed to be scalable. One of the benefits of this design is that it can easily be adapted to meet the changing needs of an organization.</p>
<p>For example, if an organization needs to grow, the MACH technologies can be scaled up to accommodate the additional load.</p>
<p><strong>Flexibility and Composability (Tailor-Made Architecture )</strong></p>
<p>Additionally, MACH architecture is also designed to be flexible, meaning that it can be easily modified with the best-of-breed solutions to fit an organization’s specific requirements.</p>
<p>This flexibility makes MACH solutions ideal for organizations that need to respond to changes in their business environment rapidly.</p>
<p>As a result, the MACH technology stack provides organizations with a high degree of scalable and flexible enterprise technologies, making it a popular choice for many businesses.</p>
<p><strong>Future-Proof</strong></p>
<p>The need for faster and more efficient data and content processing will only grow as the world becomes increasingly digitized.</p>
<p>MACH ecosystem technologies are designed to meet this demand by providing a scalable and flexible architecture that can be easily adapted to changing needs.</p>
<p>Additionally, the MACH technology stack is also highly future-proof, meaning that it can be used for years to come without becoming outdated. This is due to its modular design, which allows new components to be added as needed.</p>
<p>As a result, businesses investing in MACH-first software can be confident that they are making a sound investment that will pay off for years.</p>
<p><strong>Faster Time to Market</strong></p>
<p>MACH architecture is a microservices-based approach that enables organizations to develop and deploy software faster.</p>
<p>By breaking down applications into small, independent services that can be developed and deployed independently, MACH reduces the time it takes to get new features and functionality to market.</p>
<p>In addition, because MACH services are loosely coupled, they are easier to change and update, reducing the risk of errors and making it easier to roll out new features and functionality quickly and efficiently.</p>
<p>As a result, MACH can help organizations to achieve faster time-to-market, increased agility, and better overall software quality.</p>
<h2 id="challenges-about-mach-architecture"><a class="header" href="#challenges-about-mach-architecture">Challenges About MACH Architecture</a></h2>
<p>The MACH architecture has been widely increasing its adoption in recent years as a future-proof, high-performance alternative to traditional architectures. However, MACH architectures are not without their challenges:</p>
<ul>
<li><strong>What you see is NOT what you get.</strong></li>
<li><strong>Coordination problems between software providers.</strong></li>
<li><strong>Lack of collaboration between business and development teams.</strong></li>
</ul>
<h2 id="traditional-monolith-architecture-vs-mach-architecture"><a class="header" href="#traditional-monolith-architecture-vs-mach-architecture">Traditional (Monolith) Architecture vs. MACH Architecture</a></h2>
<p>Digital experience platforms are powerful tools to create, manage, and organize customer expectations. However, monolith architectures have some serious limitations in meeting evolving business requirements.</p>
<p>The problem is that most monolith architectures don’t offer the flexibility or features for the upcoming needs of business functionality. MACH architecture is a perfect solution for businesses looking to get the most out of their digital experience efforts.</p>
<p><img src="architecture%5CReference/image-43.png" alt="Alt text" /></p>
<h2 id="adoption-of-mach-architecture-and-mach-technologies"><a class="header" href="#adoption-of-mach-architecture-and-mach-technologies">Adoption of MACH Architecture and MACH Technologies</a></h2>
<p>The <a href="https://machalliance.org/insights/our-2022-research-shows-mach-adoption-is-high-on-the-agenda-for-tech-leaders">study</a>, published in March 2022, surveyed over 200 senior-level technology decision-makers from companies around the world to gauge awareness and adoption of MACH technology.</p>
<p>The findings of the ‘Enterprise MACHified’ are a strong indication that MACH is gaining momentum in the market and is poised to have a significant impact on the enterprise software landscape.</p>
<ul>
<li>Decision makers put a high value on offering superior CX quickly in the face of rapidly growing expectations.</li>
<li>The move to MACH is being driven by CX, market developments, and privacy/security concerns.</li>
<li>MACH’s motivations are closely connected to those who believe they are ahead of their competitors.</li>
</ul>
<p>Let’s deep dive into this research to explore how top decision-makers for corporate organizations see MACH architecture:</p>
<p><strong>Decision makers see MACH as the future of architecture.</strong></p>
<p><img src="architecture%5CReference/image-44.png" alt="Alt text" /></p>
<p><strong>MACH intentions are strongly correlated with perceptions of outpacing competitors.</strong></p>
<p>75% of respondents think that they’re ahead of the competition — one-third believe their organization is significantly ahead of the competition, while two-fifths say they are slightly ahead of their competitors.</p>
<p><strong>Increased customer experience, faster adaptation, and improved privacy/security are driving reasons for the transition to MACH.</strong></p>
<p>The customer experience is the backbone of most businesses. Providing a great customer experience increases your customers’ likelihood to interact positively with you. For this reason, it’s a leading factor why increasing customer experience is one of the top reasons for switching to a MACH platform, with 60% ranking it as a number one priority.</p>
<p><img src="architecture%5CReference/image-45.png" alt="Alt text" /></p>
<p>In today’s business world, change is the only constant. Markets shift and evolve at an ever-increasing pace, and businesses must be able to adapt just as quickly to stay competitive. That’s why responding to changes in the market faster (59%) and building and implementing new functionality quicker (54%) are other significant reasons for the transition to MACH.</p>
<p>Last but not least, improved privacy (56%) is another major reason for choosing MACH solutions over traditional ones.</p>
<p><strong>Barriers to MACH are more likely to be around implementation.</strong></p>
<ul>
<li>Two-fifths (39%) of decision-makers said resistance to change from their development team is their main barrier to moving to a MACH-based infrastructure.</li>
<li>35% of companies rely more on their current vendors for business continuity, suggesting that existing B2B relationships impact business function.</li>
<li>A third (33%) are unclear about the trade-off between initial investment and long-term benefits.</li>
</ul>
<h1 id="how-to-evaluate-mach-architecture-and-mach-technologies"><a class="header" href="#how-to-evaluate-mach-architecture-and-mach-technologies">How to Evaluate MACH Architecture and MACH Technologies</a></h1>
<p>The MACH architecture provides a number of benefits that make it an attractive option for businesses. Perhaps most importantly, it is designed to be scalable, making it easy to add new applications without needing to reconfigure the entire system. This highly modular architecture allows businesses to customize their deployment to meet their specific needs.</p>
<p>When evaluating the MACH architecture, businesses should consider their specific needs and requirements. Here are a couple of questions you can ask when evaluating a potential MACH tool:</p>
<ol>
<li>Can you add and replace services gradually over time?</li>
<li>Does it support adding or replacing best-of-breed systems and services independently?</li>
<li>Is it created using APIs from the ground up, or is an API built later?</li>
<li>Can you access technical documentation (demonstrating platform capabilities and resources) easily?</li>
<li>In terms of cloud infrastructure, does it have infinite scalability?</li>
<li>Do updates and upgrades take place through continuous delivery without causing any disruptions?</li>
<li>Can you freely and flexibly design and deploy the user experience?</li>
</ol>
<p>With MACH architecture, businesses can digitally transform and evolve with the future. This is an essential technology for any company that wants their business in line with new trends as they come about.</p>
<h1 id="is-mach-architecture-the-future-of-digital-customer-experience"><a class="header" href="#is-mach-architecture-the-future-of-digital-customer-experience">Is MACH Architecture the Future of Digital Customer Experience</a></h1>
<p>MACH is a new approach to digital customer experience that is gaining popularity among businesses.</p>
<p>Unlike traditional monolithic architectures, MACH separates each component of the customer experience into its own microservice that enables to use of full capabilities. This allows businesses to update their customer experience more quickly and easily without having to redeploy the entire system.</p>
<p>Additionally, MACH provides greater flexibility, capabilities, and scalability than monolithic architectures, making it well-suited for businesses that are growing quickly.</p>
<p>While MACH is still relatively new, it has already been adopted by some of the world’s leading companies and is widely considered to be the future of digital customer experience. As a result, it is not surprising that MACH architecture is quickly becoming the new standard for digital customer experience.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-method--c4-model"><a class="header" href="#architecture-method--c4-model">Architecture Method : C4 Model</a></h1>
<h1 id="what-is-the-c4-model"><a class="header" href="#what-is-the-c4-model">What is the C4 Model?</a></h1>
<p>The C4 model is a framework used in software engineering to visualize and describe the architecture of software systems. Developed by Simon Brown, it stands for “Context, Containers, Components, and Code,” which represent different levels of granularity for depicting a system’s architecture.</p>
<h2 id="context-8"><a class="header" href="#context-8">Context</a></h2>
<p>The purpose of this section is to offer a global perspective of the system, highlighting its interactions and connections with external entities such as users, emailing system and other external systems. Here are some keypoints :</p>
<p><strong>Stakeholders:</strong> Business and system analysts, product owners, team leads, and new team members.</p>
<p><strong>Strategic Overview:</strong> The context provides a strategic view of the system, highlighting how it fits into and interacts with the broader business environment. This perspective is vital for stakeholders to see the system not as an isolated entity but as a part of a larger business process or ecosystem.</p>
<p><strong>Clarification of Boundaries:</strong> By outlining the system’s interactions with external entities, the context clarifies the system’s boundaries. This understanding is crucial for identifying potential areas of risk, dependencies, and integration points.</p>
<p><strong>Guidance for Design and Development:</strong> Understanding the context guides both the design and development of the system. It ensures that the system is aligned with business goals and user needs, making it more effective and user-centric.</p>
<p><strong>Facilitates Stakeholder Communication:</strong> The context provides a common language and understanding for diverse stakeholders, including business executives, users, and technical teams, fostering better communication and alignment on the system’s objectives. It is a moment when the approach of Domain Driven Design becomes very useful.</p>
<p><img src="architecture%5CReference/image-26.png" alt="Alt text" /></p>
<p>Example of a context schema</p>
<h2 id="containers"><a class="header" href="#containers">Containers</a></h2>
<p>This section aims to depict the high-level technological decisions made for the system, detailing key components such as web servers, databases, file systems, and other integral elements that constitute the system’s architecture. Here are some keypoints :</p>
<p><strong>Stakeholders:</strong> Developers, architects, tech leads and operations teams.</p>
<p><strong>Architecture Overview:</strong> Containers offer a high-level view of the system architecture, presenting the main technologies and platforms used. This is vital for new team members, external partners, or anyone needing a quick understanding of the system’s technical makeup.</p>
<p><strong>Decision-Making Framework:</strong> Understanding the containers helps in making informed decisions about scaling, security, and resource allocation. It also aids in evaluating the impact of potential changes or additions to the technology stack.</p>
<p><strong>Risk Assessment:</strong> By identifying the key technologies and their interactions, it becomes easier to assess and manage risks associated with technology choices, such as vendor lock-in, scalability issues, or security vulnerabilities.</p>
<p><strong>Optimization Opportunities:</strong> This understanding enables identifying optimization opportunities, such as improving performance, reducing costs, or simplifying the technology stack.</p>
<p><img src="architecture%5CReference/image-28.png" alt="Alt text" /></p>
<p>Example of a container schema</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>This section is designed to provide a deeper understanding of the system’s fundamental components, illustrating the main elements within each container and how they interact with one another. Here are some keypoints :</p>
<p><strong>Stakeholders:</strong> Development teams (including developers <em>and</em> software architects).</p>
<p><strong>Detailed Architectural Insight:</strong> Provides a detailed insight into the architectural layout of the system, illustrating how different parts of the system work together. This is critical for both maintaining existing features and planning new development. Here are some keypoints :</p>
<p><strong>Facilitates Modular Development:</strong> Understanding components aids in modularizing development, allowing teams to work on different parts of the system simultaneously without causing conflicts or dependencies.</p>
<p><strong>Improves Quality and Maintainability:</strong> A clear view of components allows for better quality control, easier bug tracking, and more efficient maintenance. It also aids in identifying redundant or outdated parts of the system that need refactoring.</p>
<p><strong>Foundation for Scalability:</strong> A detailed understanding of components is essential for scaling the system effectively, ensuring that each component can handle increased load and complexity.</p>
<p><img src="architecture%5CReference/image-27.png" alt="Alt text" /></p>
<p>Example of a component schema for the Back for Frontend component</p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p>This section presents the most detailed layer of the system, focusing on the actual implementation. It typically includes UML diagrams or similar representations to illustrate how the various components of the system are implemented. Here are some keypoints :</p>
<p><strong>Stakeholders:</strong> Development teams (including developers <em>and</em> software architects).</p>
<p><strong>Ground-Level Understanding:</strong> Provides the most granular level of understanding, essential for day-to-day development work. It helps developers understand exactly how functionalities are implemented and interact at the code level.</p>
<p><strong>Enhances Problem-Solving:</strong> With a detailed view of the code, developers can more effectively troubleshoot issues, optimize performance, and ensure code quality.</p>
<p><strong>Facilitates Onboarding and Knowledge Transfer:</strong> Detailed code documentation is crucial for onboarding new team members, helping them to quickly understand how the system works at a practical, hands-on level.</p>
<p><strong>Enables Continuous Improvement:</strong> Understanding the code is key to continuous improvement practices like refactoring, as it allows developers to identify areas for enhancement and implement changes without unintended side-effects.</p>
<h1 id="benefits-1"><a class="header" href="#benefits-1">Benefits</a></h1>
<h2 id="clarity"><a class="header" href="#clarity">Clarity</a></h2>
<p><strong>Comprehensive View:</strong> Offers a multi-level understanding of the system, aiding in strategic planning and reducing errors by highlighting potential design issues early.</p>
<p><strong>Decision-Making Support:</strong> Enhances informed decision-making regarding design, technology, and resource allocation.</p>
<h2 id="communication"><a class="header" href="#communication">Communication</a></h2>
<p><strong>Unified Framework:</strong> Creates a common language for discussions among diverse stakeholders, enhancing collaboration and engagement across teams.</p>
<p><strong>Stakeholder Alignment:</strong> Improves alignment on project goals and expectations, crucial for project success.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p><strong>Systematic Record:</strong> Provides structured, standardized documentation, essential for reference, compliance, and future enhancements. Tools such as ADR (<em>Architecture Decision Record</em>) could be very usefull to maintain documentation up to date using a detailed methodology.</p>
<p><strong>Knowledge Base:</strong> Acts as a valuable knowledge repository for training and guiding new team members. This is a very important point. This kind of knowledge could be a great time saver and also prevent some technical debt from arising.</p>
<h1 id="trade-offs"><a class="header" href="#trade-offs">Trade-offs</a></h1>
<h2 id="complexity"><a class="header" href="#complexity">Complexity</a></h2>
<p><strong>Detail Overload:</strong> For large systems, capturing every detail can be overwhelming and may obscure the overall understanding. It can also be overkill for small systems.</p>
<p><strong>Strategic Clarity Risk:</strong> Excessive focus on details can risk losing sight of the high-level strategic view. We all know the tendency we ( developers and architects ) have to over-engineer just because it is fun and satisfying.</p>
<h2 id="effort"><a class="header" href="#effort">Effort</a></h2>
<p><strong>Resource Demands:</strong> Requires significant time and effort to create and regularly update, demanding resources that could be allocated elsewhere. So the ROI has to be calculated, a project that is only short term or transitional should not require this kind of investment.</p>
<p><strong>Maintenance Challenge:</strong> Keeping documentation current with system changes is a continuous and often resource-intensive task, so again focus on the ROI.</p>
<h2 id="detail-management"><a class="header" href="#detail-management">Detail Management</a></h2>
<p><strong>Balance Difficulty:</strong> Achieving the right level of detail without overcomplicating or oversimplifying is challenging. You need experienced resources, especially in architecture.</p>
<p><strong>Varied Needs:</strong> Tailoring documentation to meet different stakeholder needs without redundancy or confusion requires careful consideration. Again, you need to rely on an experienced architect who can guarantee this.</p>
<h1 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h1>
<p>In conclusion, the structured approach of documenting and understanding software systems through Context, Containers, Components, and Code offers significant benefits. This multi-level perspective is crucial for a thorough understanding of the system, aiding in decision-making, stakeholder engagement and effective project management. It serves as a vital knowledge base and a standardized framework for discussions and alignment among various stakeholders.</p>
<p>However, these benefits come with trade-offs. The complexity of maintaining such detailed documentation can be overwhelming, especially for large or rapidly evolving systems. The effort required to create and update these models is substantial and demands significant resources. Additionally, managing the level of detail in documentation to cater to varied stakeholder needs without causing information overload or confusion presents an ongoing challenge.</p>
<p>Therefore, while this approach is highly beneficial for understanding and communicating the architecture of software systems, it requires careful consideration and management to ensure that the documentation remains effective, relevant, and accessible to all stakeholders. Balancing the depth of detail with the high-level overview, and allocating resources efficiently for ongoing maintenance, are key to leveraging the full potential of this structured architectural approach.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-solution-architecture-1"><a class="header" href="#what-is-solution-architecture-1">What is Solution Architecture</a></h1>
<p>An informal introduction to Solution Architecture</p>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>The term Solution Architecture refers to a high-level blueprint of a solution that was developed to solve one or more business problems within an enterprise using a technological approach. Building a proper solution architecture requires</p>
<ul>
<li>A good understanding of the business problem or problems (domain knowledge)</li>
<li>Comprehensive knowledge of the technologies used in the enterprise world (technical knowledge)</li>
<li>Experience in building similar solutions in the past (experience)</li>
</ul>
<p>A good solution architecture can be used to perform critical tasks such as</p>
<ul>
<li>Designing and implementing innovative solutions for the consumers of the business</li>
<li>Maintain excellent user experience with higher degrees of service availability</li>
<li>Perform calculations on return on investment (ROI) and total cost of ownership (TCO)</li>
</ul>
<p>Solution architecture tries to compact a gigantic set of details into a set of diagrams so that different stakeholders understand what is actually going on inside the enterprise software systems. It is helpful for highly technical people such as software developers, software architects, and CTOs as well we moderately technical people such as project managers, business analysts, and citizen developers.</p>
<h2 id="types-of-architectures-in-solution-architecture-1"><a class="header" href="#types-of-architectures-in-solution-architecture-1">Types of architectures in solution architecture</a></h2>
<p>The first step in solving any problem is understanding the business requirements of the client. To include all the critical information related to the business use case, we can come up with something called a “business architecture” which contains different types of applications, users, and their interactions at a very high level. We sometimes call this architecture “Level 0” architecture.</p>
<h3 id="business-architecture-level-0-architecture-1"><a class="header" href="#business-architecture-level-0-architecture-1">Business architecture (Level-0 architecture)</a></h3>
<p>The idea of business architecture is to come up with a possible solution to a real-world problem or problems and depict that in the form of a diagram or a document using the systems, applications, and users that are considered in the scenario with minimum technical details. This component is mainly useful for business executives and other non-technical stakeholders so that they can understand what technical solution is going to be built using this architecture. Given below is a “business architecture” diagram that we came up with for a mobile banking application.</p>
<p><img src="architecture%5CReference/image-7.png" alt="Alt text" /></p>
<p>Figure: The business architecture of a mobile banking application</p>
<p>The preceding figure depicts the various components associated with the solution in which we are building a mobile banking application for a given bank. It showcases the components such as gateway, integration, and security component as high-level building blocks to design a solution for this problem.</p>
<p>The next step in designing the solution architecture is to use this and design a technical architecture with the finer details about products and tools.</p>
<h3 id="technical-architecture-level-1-architecture-1"><a class="header" href="#technical-architecture-level-1-architecture-1">Technical architecture (Level-1 architecture)</a></h3>
<p>This is the type of diagram that includes details of specific vendors, products, and tools required to build a real-world software system using the business architecture blueprint. Coming up with a technical architecture requires the proper analysis of vendors and tools as well as the current and future business requirements and TCO/ROI calculations. The below diagram depicts a simplified version of a technical architecture for the business architecture we discussed before.</p>
<p><img src="architecture%5CReference/image-6.png" alt="Alt text" /></p>
<p>Figure: Technical architecture of a mobile banking solution</p>
<p>In this diagram, we have mentioned the specific vendors that we are going to use to fulfill the certain functionalities that we identified during the business architecture design phase. As an example, the diagram depicts that we are going to use the WSO2 API Manager solution as the API gateway which exposes the services to the mobile application. Similarly, it shows that we are going to use Mulesoft and Auth0 for respective functionalities. In addition to that, we can also depict information about which cloud platforms and container technologies we are going to use if we decided to go with a container-based solution.</p>
<p>Once the product vendors and tools are identified, the next step is to go further down into the actual deployment details and showcase the infrastructure level details that can be used by the developers as well as the operations teams to build the actual infrastructure for the solution.</p>
<h3 id="deployment-architecture-level-2-architecture-1"><a class="header" href="#deployment-architecture-level-2-architecture-1">Deployment architecture (Level-2 architecture)</a></h3>
<p>This architecture diagram showcases how the technical architecture looks like in a real computing infrastructure such as a data center or a cloud platform. It contains details on network-level segmentation, the number of replicas (instances), traffic routing components such as load balancers or firewalls, and many other details related to the actual deployment of the solution. The figure below depicts a simplified version of a deployment architecture that we can come up with for the mobile banking solution that we discussed before.</p>
<p><img src="architecture%5CReference/image-5.png" alt="Alt text" /></p>
<p>Figure: Deployment architecture for mobile banking solution</p>
<p>The preceding figure depicts the product versions, the number of replicas, and the deployment model of each component along with the traffic routing components (load balancers).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decision-record-template-by-michael-nygard"><a class="header" href="#decision-record-template-by-michael-nygard">Decision record template by Michael Nygard</a></h1>
<p>This is the template in <a href="http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions">Documenting architecture decisions - Michael Nygard</a> with some minor changes.
You can use <a href="https://github.com/npryce/adr-tools">adr-tools</a> for managing the ADR files (note, may not work with the customisations).</p>
<p>In each ADR file, write these sections:</p>
<p>Delete everything above Title when using this template.</p>
<h1 id="title"><a class="header" href="#title">Title</a></h1>
<ul>
<li>Status: [proposed | rejected | accepted | deprecated | … | superseded by <a href="architecture%5Cadr/0005-example.html">ADR-0005</a>] <!-- optional --></li>
<li>Deciders: [list everyone involved in the decision] <!-- optional --></li>
<li>Date: [YYYY-MM-DD when the decision was last updated] <!-- optional --></li>
</ul>
<p>Technical Story: [description | ticket/issue URL] <!-- optional --></p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>[Proposed | Accepted | Deprecated | Superseded] If deprecated, indicate why. If superseded, include a link to the new ADR.</p>
<h2 id="context-9"><a class="header" href="#context-9">Context</a></h2>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
<h2 id="considered-options"><a class="header" href="#considered-options">Considered Options</a></h2>
<ul>
<li>option 1</li>
<li>option 2</li>
<li>option 3</li>
<li>…</li>
</ul>
<h2 id="decision"><a class="header" href="#decision">Decision</a></h2>
<p>What is the change that we're proposing and/or doing?</p>
<p>Describe here our response to these forces, that is, the design decision that was made. State the decision in full sentences, with active voice (&quot;We will...&quot;).</p>
<h2 id="consequences"><a class="header" href="#consequences">Consequences</a></h2>
<p>What becomes easier or more difficult to do because of this change? All consequences should be listed, not just the &quot;positive&quot; ones.</p>
<h3 id="positive-consequences"><a class="header" href="#positive-consequences">Positive Consequences</a></h3>
<ul>
<li>e.g., improvement of quality attribute satisfaction, follow-up decisions required, …</li>
<li>…</li>
</ul>
<h3 id="negative-consequences"><a class="header" href="#negative-consequences">Negative Consequences</a></h3>
<ul>
<li>e.g., compromising quality attribute, follow-up decisions required, …</li>
<li>…</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="solid"><a class="header" href="#solid">SOLID</a></h1>
<img src="architecture\architectural_principles/image.png" width=40%>
<p>The acronym 𝗦𝗢𝗟𝗜𝗗 stands for:</p>
<ul>
<li>Single responsibility principle</li>
<li>Open/closed principle</li>
<li>Liskov substitution principle</li>
<li>Interface segregation principle</li>
<li>Dependency inversion principle</li>
</ul>
<h2 id="the-principles"><a class="header" href="#the-principles">The principles</a></h2>
<ol>
<li>𝗦𝗶𝗻𝗴𝗹𝗲 𝗥𝗲𝘀𝗽𝗼𝗻𝘀𝗶𝗯𝗶𝗹𝗶𝘁𝘆 𝗣𝗿𝗶𝗻𝗰𝗶𝗽𝗹𝗲 (𝗦𝗥𝗣)</li>
</ol>
<p>A class should have only one reason to change. In other words, a class should have a single, well-defined responsibility. That class should entirely encapsulate responsibility.</p>
<ol start="2">
<li>𝗢𝗽𝗲𝗻/𝗖𝗹𝗼𝘀𝗲𝗱 𝗣𝗿𝗶𝗻𝗰𝗶𝗽𝗹𝗲 (𝗢𝗖𝗣)</li>
</ol>
<p>Software entities (classes, functions, etc.) should be open for extension but closed for modification. You should be able to add new functionality to a class without changing its existing code, but you should not need to modify the class itself to do so.</p>
<ol start="3">
<li>𝗟𝗶𝘀𝗸𝗼𝘃 𝗦𝘂𝗯𝘀𝘁𝗶𝘁𝘂𝘁𝗶𝗼𝗻 𝗣𝗿𝗶𝗻𝗰𝗶𝗽𝗹𝗲 (𝗟𝗦𝗣)</li>
</ol>
<p>Subtypes must be substitutable for their base types. In other words, if a class is derived from another class, you should be able to use the derived class in the same way as the base class without any issues.</p>
<ol start="4">
<li>𝗜𝗻𝘁𝗲𝗿𝗳𝗮𝗰𝗲 𝗦𝗲𝗴𝗿𝗲𝗴𝗮𝘁𝗶𝗼𝗻 𝗣𝗿𝗶𝗻𝗰𝗶𝗽𝗹𝗲 (𝗜𝗦𝗣)</li>
</ol>
<p>Clients should not depend on interfaces they do not use. This means you should design your interfaces as specific and focused as possible.</p>
<ol start="5">
<li>𝗗𝗲𝗽𝗲𝗻𝗱𝗲𝗻𝗰𝘆 𝗜𝗻𝘃𝗲𝗿𝘀𝗶𝗼𝗻 𝗣𝗿𝗶𝗻𝗰𝗶𝗽𝗹𝗲 (𝗗𝗜𝗣)</li>
</ol>
<p>High-level modules should not depend on low-level modules. Both should depend on abstractions. Design your software so high-level modules depend on abstractions rather than concrete implementations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-docs"><a class="header" href="#design-docs">Design docs</a></h1>
<p>One of the key elements of Google's software engineering culture is the use of design docs for defining software designs. These are relatively informal documents that the primary author or authors of a software system or application create before they embark on the coding project. The design doc documents the high level implementation strategy and key design decisions with emphasis on the trade-offs that were considered during those decisions.</p>
<p>As software engineers our job is not to produce code per se, but rather to solve problems. Unstructured text, like in the form of a design doc, may be the better tool for solving problems early in a project lifecycle, as it may be more concise and easier to comprehend, and communicates the problems and solutions at a higher level than code.</p>
<p>Besides the original documentation of a software design, design docs fulfill the following functions in the software development lifecycle:</p>
<ul>
<li>Early identification of design issues when making changes is still cheap.</li>
<li>Achieving consensus around a design in the organization.</li>
<li>Ensuring consideration of cross-cutting concerns.</li>
<li>Scaling knowledge of senior engineers into the organization.</li>
<li>Form the basis of an organizational memory around design decisions.</li>
<li>Acts as a summary artifact in the technical portfolio of the software designer(s).</li>
</ul>
<h1 id="anatomy-of-a-design-doc"><a class="header" href="#anatomy-of-a-design-doc">Anatomy of a design doc</a></h1>
<p>Design docs are informal documents and thus don’t follow a strict guideline for their content. Rule #1 is: Write them in whatever form makes the most sense for the particular project.</p>
<p>Having said that, a certain structure has established itself as really useful.</p>
<h1 id="context-and-scope"><a class="header" href="#context-and-scope">Context and scope</a></h1>
<p>This section gives the reader a very rough overview of the landscape in which the new system is being built and what is actually being built. This isn’t a requirements doc. Keep it succinct! The goal is that readers are brought up to speed but some previous knowledge can be assumed and detailed info can be linked to. This section should be entirely focused on objective background facts.</p>
<h1 id="goals-and-non-goals"><a class="header" href="#goals-and-non-goals">Goals and non-goals</a></h1>
<p>A short list of bullet points of what the goals of the system are, and, sometimes more importantly, what non-goals are. Note, that non-goals aren’t negated goals like “The system shouldn’t crash”, but rather things that could reasonably be goals, but are explicitly chosen not to be goals. A good example would be “ACID compliance”; when designing a database, you’d certainly want to know whether that is a goal or non-goal. And if it is a non-goal you might still select a solution that provides it, if it doesn’t introduce trade-offs that prevent achieving the goals.</p>
<h1 id="the-actual-design"><a class="header" href="#the-actual-design">The actual design</a></h1>
<p>This section should start with an overview and then go into details.
<img src="architecture%5Carchitectural_principles/image-2.png" alt="Alt text" />
Visualization of how to draw an owl. First picture: two circles labeled &quot;1. Draw some circles&quot;. Second picture: Picture of an own labeled &quot;2. Draw the rest of the fucking owl&quot;</p>
<p>The design doc is the place to write down the trade-offs you made in designing your software. Focus on those trade-offs to produce a useful document with long-term value. That is, given the context (facts), goals and non-goals (requirements), the design doc is the place to suggest solutions and show why a particular solution best satisfies those goals.</p>
<p>The point of writing a document over a more formal medium is to provide the flexibility to express the problem set at hand in an appropriate manner. Because of this, there is no explicit guidance for how to actually describe the design.</p>
<p>Having said that, a few best practices and repeating topics have emerged that make sense for a large percentage of design docs:</p>
<h1 id="system-context-diagram"><a class="header" href="#system-context-diagram">System-context-diagram</a></h1>
<p>In many docs a system-context-diagram can be very useful. Such a diagram shows the system as part of the larger technical landscape and allows readers to contextualize the new design given its environment that they are already familiar with.</p>
<p>Block diagram showing how various systems are related to each other. The actual text is just examples and not needed to be seen to understand the example.
<img src="architecture%5Carchitectural_principles/image-1.png" alt="Alt text" />
Example of a system-context-diagram.</p>
<h1 id="apis"><a class="header" href="#apis">APIs</a></h1>
<p>If the system under design exposes an API, then sketching out that API is usually a good idea. In most cases, however, one should withstand the temptation to copy-paste formal interface or data definitions into the doc as these are often verbose, contain unnecessary detail and quickly get out of date. Instead focus on the parts that are relevant to the design and its trade-offs.</p>
<h1 id="data-storage"><a class="header" href="#data-storage">Data storage</a></h1>
<p>Systems that store data should likely discuss how and in what rough form this happens. Similar to the advice on APIs, and for the same reasons, copy-pasting complete schema definitions should be avoided. Instead focus on the parts that are relevant to the design and its trade-offs.</p>
<h1 id="code-and-pseudo-code"><a class="header" href="#code-and-pseudo-code">Code and pseudo-code</a></h1>
<p>Design docs should rarely contain code, or pseudo-code except in situations where novel algorithms are described. As appropriate, link to prototypes that show the implementability of the design.</p>
<h1 id="degree-of-constraint"><a class="header" href="#degree-of-constraint">Degree of constraint</a></h1>
<p>One of the primary factors that would influence the shape of a software design and hence the design doc, is the degree of constraint of the solution space.</p>
<p>On one end of the extreme is the “greenfield software project”, where all we know are the goals, and the solution can be whatever makes the most sense. Such a document may be wide-ranging, but it also needs to quickly define a set of rules that allow zooming in on a manageable set of solutions.</p>
<p>On the other end are systems where the possible solutions are very well defined, but it isn’t at all obvious how they could even be combined to achieve the goals. This may be a legacy system that is difficult to change and wasn’t designed to do what you want it to do or a library design that needs to operate within the constraints of the host programming language.</p>
<p>In this situation you may be able to enumerate all the things you can do relatively easily, but you need to creatively put those things together to achieve the goals. There may be multiple solutions, and none of them are really great, and hence such a document should focus on selecting the best way given all identified trade-offs.</p>
<h1 id="alternatives-considered-1"><a class="header" href="#alternatives-considered-1">Alternatives considered</a></h1>
<p>This section lists alternative designs that would have reasonably achieved similar outcomes. The focus should be on the trade-offs that each respective design makes and how those trade-offs led to the decision to select the design that is the primary topic of the document.</p>
<p>While it is fine to be succinct about solution that ended up not being selected, this section is one of the most important ones as it shows very explicitly why the selected solution is the best given the project goals and how other solutions, that the reader may be wondering about, introduce trade-offs that are less desirable given the goals.</p>
<h1 id="cross-cutting-concerns"><a class="header" href="#cross-cutting-concerns">Cross-cutting concerns</a></h1>
<p>This is where your organization can ensure that certain cross-cutting concerns such as security, privacy, and observability are always taken into consideration. These are often relatively short sections that explain how the design impacts the concern and how the concern is addressed. Teams should standardize what these concerns are in their case.</p>
<p>Due to their importance, Google projects are required to have a dedicated privacy design doc, and there are dedicated reviews for privacy and security. While the reviews are only required to be completed by the time a project launches, it is best practice to engage with privacy and security teams as early as possible to ensure that designs take them into account from the ground up. In case of dedicated docs for these topics, the central design doc can, of course, reference them instead of going into detail.</p>
<h1 id="the-length-of-a-design-doc"><a class="header" href="#the-length-of-a-design-doc">The length of a design doc</a></h1>
<p>Design docs should be sufficiently detailed but short enough to actually be read by busy people. The sweet spot for a larger project seems to be around 10-20ish pages. If you get way beyond that, it might make sense to split up the problem into more manageable sub problems. It should also be noted that it is absolutely possible to write a 1-3 page “mini design doc”. This is especially helpful for incremental improvements or sub tasks in an agile project–you still do all the same steps as for a longer doc, just keep things more terse and focused on a limited problem set.</p>
<h1 id="when-not-to-write-a-design-doc"><a class="header" href="#when-not-to-write-a-design-doc">When not to write a design doc</a></h1>
<p>Writing design docs is overhead. The decision whether to write a design doc comes down to the core trade-off of deciding whether the benefits in organizational consensus around design, documentation, senior review, etc. outweigh the extra work of creating the doc. At the center of that decision lies whether the solution to the design problem is ambiguous–because of problem complexity or solution complexity, or both. If it is not, then there is little value in going through the process of writing a doc.</p>
<p>A clear indicator that a doc might not be necessary are design docs that are really implementation manuals. If a doc basically says “This is how we are going to implement it” without going into trade-offs, alternatives, and explaining decision making (or if the solution is so obvious as to mean there were no trade-offs), then it would probably have been a better idea to write the actual program right away.</p>
<p>Finally, the overhead of creating and reviewing a design doc may not be compatible with prototyping and rapid iteration. However, most software projects do have a set of actually known problems. Subscribing to agile methodologies is not an excuse for not taking the time to get solutions to actually known problems right. Additionally, prototyping itself may be part of the design doc creation. “I tried it out and it works” is one of the best arguments for choosing a design.</p>
<h1 id="the-design-doc-lifecycle"><a class="header" href="#the-design-doc-lifecycle">The design doc lifecycle</a></h1>
<p>The steps in the lifecycle of a design document are:</p>
<ol>
<li>Creation and rapid iteration</li>
<li>Review (may be in multiple rounds)</li>
<li>Implementation and iteration</li>
<li>Maintenance and learning</li>
</ol>
<h1 id="creation-and-rapid-iteration"><a class="header" href="#creation-and-rapid-iteration">Creation and rapid iteration</a></h1>
<p>You write the doc. Sometimes together with a set of co-authors.</p>
<p>This phase quickly evolves into a time of rapid iteration where the doc is shared with colleagues who have the most knowledge about the problem space (often belonging to the same team) and through their clarifying questions and suggestions drive the doc to a first relatively stable version.</p>
<p>While you certainly find engineers and even teams who prefer version control and code review tools for document creation, the vast majority of design docs at Google are created in Google Docs and make heavy use of its collaboration features.</p>
<h1 id="review"><a class="header" href="#review">Review</a></h1>
<p>In the review phase a design doc gets shared with a wider audience than the original set of authors and close collaborators. Reviews can add a lot of value, but they are also a dangerous trap of overhead, so treat them wisely.</p>
<p>A review can take many shapes: The more lightweight version is simply sending out the doc to the (wider) team-list to give folks a chance to take a look. Discussion then primarily happens in comment threads in the document. On the heavy side of reviews, are formal design review meetings in which the author presents the doc (often via a dedicated presentation) to an often very senior engineering audience. Many teams at Google have recurring meetings scheduled for this purpose to which engineers can sign up to for a review. Naturally waiting for such meetings to happen can significantly slow down the development process. Engineers can mitigate this by seeking the most crucial feedback directly and not blocking progress on wider review.</p>
<p>When Google was a smaller company, it was customary to send designs to a single central mailing list, where senior engineers would review them at their own leisure. This may very well be a great way to handle things for your company. One benefit was that it did establish a relatively uniform software design culture across the company. But as the company scaled to a much larger engineering team, it became infeasible to maintain the centralized approach.</p>
<p>The primary value that such reviews add is that they form an opportunity for the combined experience of the organization to be incorporated into a design. Most consistently, ensuring that designs take cross-cutting concerns such as observability, security and privacy into account is something that can be ensured in a review stage. The primary value of the review isn’t that issues get discovered per-se, but rather that this happens relatively early in the development lifecycle when it is still relatively cheap to make changes.</p>
<h1 id="implementation-and-iteration"><a class="header" href="#implementation-and-iteration">Implementation and iteration</a></h1>
<p>When things have progressed sufficiently to have confidence that further reviews are unlikely to require major changes to the design, it is time to begin implementation. As plans collide with reality, it is inevitable that shortcomings, unaddressed requirements, or educated guesses that turned out to be wrong surface, and require changing the design. It is strongly recommended to update the design doc in this case. As a rule of thumb: If the designed system hasn’t shipped yet, then definitely update the doc. In practice we humans are bad at updating documents, and for other practical reasons changes are often isolated into new documents. This leads to an eventual state more akin to the US constitution with a bunch of amendments rather than one consistent piece of documentation. Links to such amendments from the original doc can be immensely helpful for the poor future maintenance programmer trying to understand their target system through design doc archaeology.</p>
<h1 id="maintenance-and-learning"><a class="header" href="#maintenance-and-learning">Maintenance and learning</a></h1>
<p>When Google engineers get confronted with a system that they hadn’t previously touched their first question often is “Where is the design doc?”. While design docs, like all documentation, tend to get out of sync with reality over time, they still often present the most accessible entry point to learn about the thinking that guided the creation of the system.</p>
<p>As the author, do yourself a favor and re-read your own design docs a year or 2 later. What did you get right? What did you get wrong? What would you do to decide differently today? Answering these questions is a great way to advance as an engineer and improve software design skills over time.</p>
<h1 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h1>
<p>Design docs are a great way to gain clarity and achieve consensus around solving the hardest problems in a software project. They save money, because they avoid going down coding rabbit holes that fail to achieve project goals and could have been avoided using upfront investigation; and they cost money, because creation and review take time. So, choose wisely for your project!</p>
<p>When considering writing a design doc, think about these points:</p>
<ul>
<li>Are you unsure about the right software design, and would it make sense to spend upfront time to gain certainty?</li>
<li>Relatedly, would it help to involve senior engineers, who might not be able to review every code-change, in the design?</li>
<li>Is the software design ambiguous or even contentious such that achieving organizational consensus around it would be valuable?</li>
<li>Does my team sometimes forget to consider privacy, security, logging or other cross-cutting concerns in the design?</li>
<li>Is there a strong need for documents that provide high-level insights into the design of legacy systems in the organization?</li>
</ul>
<p>If you answer yes to 3 or more of these questions, then a design doc is probably a great method to start your next software project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="john-lewis-software-engineering-principles"><a class="header" href="#john-lewis-software-engineering-principles">John Lewis Software Engineering Principles</a></h1>
<p>We have created a set of Software Engineering principles that we use internally that form a common belief in how software should be built within John Lewis IT Delivery. They can be found here <a href="http://engineering-principles.jl-engineering.net/">http://engineering-principles.jl-engineering.net/</a></p>
<h2 id="why-create-a-set-of-principles"><a class="header" href="#why-create-a-set-of-principles">Why create a set of Principles?</a></h2>
<p>The success of our organisation is dependent on implementing outstanding software solutions in a sustainable way. Rather than simply declaring that “Engineering Excellence” is important to us, we embarked on creating a set of principles that describe what that means to us in practice.</p>
<h2 id="principles-instead-of-policy-or-standards"><a class="header" href="#principles-instead-of-policy-or-standards">Principles instead of policy or standards</a></h2>
<p>When creating the principles we didn’t want to dictate how each engineering team should build their product by creating another policy document as we want teams to feel empowered. We also didn’t want this to become another document that was quietly ignored. On that basis we created the principles as a set of <em>beliefs</em> that are important to us as an organisation.</p>
<p>We wanted to create principles that are actionable rather than create a set of truisms that are easy to agree with but of no real value in practice. For each of the principles we describe why we believe it to hold true and the implications of actually working to the principle.</p>
<p>When we created the principles some of them were controversial. For example we created <strong>Cloud Native</strong> as a principle when almost all new projects were still hosting solutions on traditional infrastructure. As an organisation we now host most new solutions on cloud infrastructure. Maybe most controversially we created and then removed <strong>Reusable Components</strong> as a principle. Through experience we learned that the principles <strong>Design For Pace of Change</strong> and <strong>Evolutionary Systems</strong> set out our real intent, which is that while reuse is often valuable, inappropriate reuse inhibits change and should emerge through evolution rather than being designed up front.</p>
<h2 id="how-did-we-create-the-principles"><a class="header" href="#how-did-we-create-the-principles">How did we create the principles?</a></h2>
<p>Inside John Lewis IT we have a serious sounding body we call the Tech Council which is a bunch of experienced developers that meet up once a week to discuss anything about our organisation’s engineering approach. The Tech Council created the initial principles, hosting them in Git and setting up a CD pipeline to publish them to a website whenever they are changed. The principles are “open sourced” internally so anybody can suggest improvements by making a merge request.</p>
<p><img src="architecture%5Carchitectural_principles/image-3.png" alt="Alt text" /></p>
<p>We always share the principles with any new Partners or suppliers we use. We have had valuable contributions from some very well known figures from the world of agile software development that have worked with us recently, some of whom have shared our principles with their other clients (which we are very happy about).</p>
<h2 id="how-have-the-principles-impacted-our-organisation"><a class="header" href="#how-have-the-principles-impacted-our-organisation">How have the principles impacted our organisation?</a></h2>
<p>We never wanted them to be another document that gathered dust in the filing cabinet. They are used as part of the training for anybody up-skilling to be a software engineer within our organisation, which on its own is great.</p>
<p>But they have also been used to resolve the inevitable disagreements about engineering approach that crop up in a large organisation. The principles are a simple way to evaluate how differing opinions align themselves to our organisational beliefs, and if our beliefs are not shared we would rather resolve that first.</p>
<p>Engineering teams often create their own charters about how they will approach the engineering problem in their particular context. They have found it useful to validated their charters against the principles instead of creating their own value system.</p>
<h2 id="what-next-for-our-principles"><a class="header" href="#what-next-for-our-principles">What next for our principles?</a></h2>
<p>We have recently started a process of evaluating how well engineering teams are aligned with the principles. I say <em>aligned</em> rather than <em>comply with</em> as the intent is to help teams rather than judge them. This will also help us as an organisation to understand how well we are performing and where we may need to make investment choices to improve our engineering performance.</p>
<p>A member of the Tech Council helps each team to evaluate itself and we have a guide to help with the evaluation process which includes things such as positive and negative indicators for each principle. Rather than give each team a total score out of 100 we use a red/amber/green traffic light against each principle.</p>
<p>We expect the evaluation process and the principles themselves to improve as we gain more experience with this.</p>
<h2 id="the-principles-1"><a class="header" href="#the-principles-1">The Principles</a></h2>
<h3 id="build-differentiators"><a class="header" href="#build-differentiators">Build Differentiators</a></h3>
<ul>
<li>Do you consider this when choosing the technology?</li>
<li>Google Cloud Datastore or Elasticsearch are examples of “buy”</li>
<li>Do you reinvent the wheel, building systems already out there?</li>
</ul>
<h3 id="design-for-emergent-reuse"><a class="header" href="#design-for-emergent-reuse">Design for Emergent Reuse</a></h3>
<ul>
<li>If there are lots of different components do you take into account the pace of change of the components?</li>
<li>Do you over-engineer your solutions?</li>
<li>Do you reuse for the sake of it?</li>
<li>Is your system going to be around for a long time?</li>
</ul>
<h3 id="evolutionary-systems"><a class="header" href="#evolutionary-systems">Evolutionary Systems</a></h3>
<ul>
<li>If you change your system is it an isolated change with regard to other systems?</li>
<li>How many people does it take to release?</li>
<li>How often can you release?</li>
<li>Can Ops release during the day?</li>
<li>How many requirements do you put into one iteration?</li>
<li>How future proof is it for requirements that may not exist?</li>
</ul>
<h3 id="scale-horizontally"><a class="header" href="#scale-horizontally">Scale Horizontally</a></h3>
<ul>
<li>State cannot be stored in-memory but rather must be persisted to the client or a shared datastore.</li>
<li>It is not always possible to scale horizontally e.g. for traditional relational databases, increased performance is often achieved through better hardware or higher specifications</li>
<li>Services should strive to be idempotent</li>
</ul>
<h3 id="small-and-simple"><a class="header" href="#small-and-simple">Small and Simple</a></h3>
<ul>
<li>How long do your tests take?</li>
<li>Can you describe your components?</li>
<li>Can you test your components independently?</li>
<li>Can you deploy components independently?</li>
</ul>
<h3 id="smarts-in-the-nodes-not-the-network"><a class="header" href="#smarts-in-the-nodes-not-the-network">Smarts in the Nodes, not the Network</a></h3>
<ul>
<li>Do you have business logic in your integration layer?</li>
<li>Do you apply business rules in your data transformations?</li>
<li>If there is business logic is it for your own system’s consumption?</li>
</ul>
<h3 id="cloud-native-1"><a class="header" href="#cloud-native-1">Cloud Native</a></h3>
<ul>
<li>Are you leveraging the services in the cloud?</li>
<li>Did you intend it to be in the cloud from the start?</li>
</ul>
<h3 id="production-ready"><a class="header" href="#production-ready">Production Ready</a></h3>
<ul>
<li>Do you understand your failure modes?</li>
<li>Do you understand how monitoring helps you understand your failure modes?</li>
<li>How close is the system to its limit?</li>
<li>Are there circuit breakers?</li>
<li>Are there rolling deployments, eg kubernetes?</li>
<li>Do you have dashboards, golden signals, engineering metrics for traffic and resilience?</li>
</ul>
<h3 id="keep-pace-with-technological-change"><a class="header" href="#keep-pace-with-technological-change">Keep Pace with Technological Change</a></h3>
<ul>
<li>What technology is the team using?</li>
<li>Is it up to date?</li>
<li>Is it well supported?</li>
<li>Is it current?</li>
<li>How often is it upgraded and patched?</li>
<li>Are the team interested in this area?</li>
<li>Is the software on its way out?</li>
</ul>
<h3 id="model-the-business-domain"><a class="header" href="#model-the-business-domain">Model the Business Domain</a></h3>
<ul>
<li>Does it use DDD (Domain driven design)?</li>
<li>Could a business person understand the language used in your code?</li>
<li>How well do you own your domain?</li>
<li>Are there changes not owned by your team?</li>
</ul>
<h3 id="secure-by-design"><a class="header" href="#secure-by-design">Secure by Design</a></h3>
<ul>
<li>Have you considered access control?</li>
</ul>
<h3 id="consistent-environments"><a class="header" href="#consistent-environments">Consistent Environments</a></h3>
<ul>
<li>Are you using infrastructure as code? Examples are terraform or puppet.</li>
<li>Have you got any processes in keeping data up to date?</li>
<li>Are there lots of manual processes?</li>
</ul>
<h3 id="continuous-delivery"><a class="header" href="#continuous-delivery">Continuous Delivery</a></h3>
<ul>
<li>Are you doing it? Are you using a CI tool?</li>
<li>What manual gates are in place?</li>
<li>Can you release straight to Production?</li>
<li>Are you using trunk based development with feature flags as necessary?</li>
<li>Are branches short-lived?</li>
</ul>
<h3 id="get-feedback-early-and-often"><a class="header" href="#get-feedback-early-and-often">Get Feedback Early and Often</a></h3>
<ul>
<li>Could you do daily releases?</li>
</ul>
<h3 id="understandability-1"><a class="header" href="#understandability-1">Understandability</a></h3>
<ul>
<li>If a new person joins, can they get up to speed quickly?</li>
<li>Can code be safely refactored due to good test coverage?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>𝗛𝗼𝘄 𝘁𝗼 𝗱𝗿𝗶𝘃𝗲 𝘆𝗼𝘂𝗿 𝗮𝗿𝗰𝗵𝗶𝘁𝗲𝗰𝘁𝘂𝗿𝗲 𝗱𝗲𝗰𝗶𝘀𝗶𝗼𝗻𝘀 𝘄𝗶𝘁𝗵 𝗮 𝘀𝗶𝗺𝗽𝗹𝗲 𝗳𝗿𝗮𝗺𝗲𝘄𝗼𝗿𝗸</p>
<p>I held a talk at the Heapcon conference on how to communicate your software architecture efficiently. 𝗔𝗿𝗰𝗵𝗶𝘁𝗲𝗰𝘁𝘂𝗿𝗮𝗹 𝗱𝗲𝗰𝗶𝘀𝗶𝗼𝗻𝘀 shape our projects, embodying the technical vision and laying the groundwork for the long-term sustainability and adaptability of systems.</p>
<p>Those decisions can be as simple as choosing a code style to more important ones, such as which architectural style we select or which database type. After months of engineering, remembering the 𝗿𝗮𝘁𝗶𝗼𝗻𝗮𝗹𝗲 𝗯𝗲𝗵𝗶𝗻𝗱 𝗮 𝗱𝗲𝗰𝗶𝘀𝗶𝗼𝗻 can be tricky because you need more context that influenced it.</p>
<p>Here is our 𝘀𝗶𝗺𝗽𝗹𝗲 𝗳𝗿𝗮𝗺𝗲𝘄𝗼𝗿𝗸 𝗳𝗼𝗿 𝗮𝗿𝗰𝗵𝗶𝘁𝗲𝗰𝘁𝘂𝗿𝗮𝗹 𝗱𝗲𝗰𝗶𝘀𝗶𝗼𝗻𝘀:</p>
<p>𝟭. 𝗗𝗶𝘀𝗰𝘂𝘀𝘀𝗶𝗼𝗻</p>
<p>When requirements came for some of them, we needed to discuss them first. We have weekly recurring places for conversation, where we discuss spikes, challenges, and decisions.</p>
<p>Some discussions led to the Request for Comments (RFC) process.</p>
<p>𝟮. 𝗥𝗲𝗾𝘂𝗲𝘀𝘁 𝗳𝗼𝗿 𝗖𝗼𝗺𝗺𝗲𝗻𝘁𝘀 (𝗥𝗙𝗖)</p>
<p>In this process, we create RFC documents, which are a formalized approach to proposing changes, improvements, or the introduction of new features within a project. These documents have the following structure:</p>
<p>🔹 Summary - what is it about<br />
🔹 Scope - what is our scope<br />
🔹 Participants - who work on this<br />
🔹 Status - in which status it is<br />
🔹 Proposal - the central part, what we propose as a solution<br />
🔹 Pros/Cons - what are the pros/cons of our approach<br />
🔹 Alternatives - what are alternatives to our proposal<br />
🔹 Questions - if we have some open questions<br />
🔹 Conclusion - what we conclude in the end</p>
<p>The RFC process usually goes in three steps:</p>
<p>1. Creation of the RFC<br />
2. Comments<br />
3. Conclusion</p>
<p>When working on RFC, we also include two things:</p>
<p>🔹 Our internal 𝗧𝗲𝗰𝗵 𝗥𝗮𝗱𝗮𝗿 (you can also use Thougthworks radar or some other)<br />
🔹 Our internal 𝗧𝗲𝗰𝗵 𝘀𝘁𝗮𝗻𝗱𝗮𝗿𝗱𝘀 (e.g., how do we do logging, exception handling, etc.)</p>
<p>𝟯. 𝗔𝗿𝗰𝗵𝗶𝘁𝗲𝗰𝘁𝘂𝗿𝗮𝗹 𝗗𝗲𝗰𝗶𝘀𝗶𝗼𝗻 𝗥𝗲𝗰𝗼𝗿𝗱𝘀 (𝗔𝗗𝗥)</p>
<p>When we have a conclusion from the RFC document, we use those to create ADRs. ADRs are documents that capture essential decisions about a software system's architecture. Usually, we store it in the codebase, close to the issues they describe. They record the decision itself, the context in which it was made, the factors considered, and the expected impact. By providing a historical record, ADRs help communicate decisions to stakeholders, ensure consistency in decision-making, and promote transparency and accountability.</p>
<p>ADRs usually have the following 𝘀𝘁𝗿𝘂𝗰𝘁𝘂𝗿𝗲:</p>
<p>🔹 Title<br />
🔹 Status<br />
🔹 Context<br />
🔹 Decision<br />
🔹 Consequences</p>
<p>When we finish the process, we can continue implementing our requirements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scaling-the-practice-of-architecture-conversationally"><a class="header" href="#scaling-the-practice-of-architecture-conversationally">Scaling the Practice of Architecture, Conversationally</a></h1>
<p><em>Architecture need not be a monologue; delivered top-down from the minds and mouths of a centralised few. This article describes another way to do architecture; as a series of conversations, driven by a decentralised and empowering decision-making technique, and supported by four learning and alignment mechanisms: Decision Records, Advisory Forum, Team-sourced Principles, and a Technology Radar</em></p>
<hr />
<h2 id="when-traditional-approaches-to-architecture-break-down"><a class="header" href="#when-traditional-approaches-to-architecture-break-down">When &quot;traditional&quot; approaches to architecture break down</a></h2>
<p>I'll be honest, “traditional” approaches to software architecture (i.e. non-coding, decision-taking, diagram-drawing) are hard for me to make work at the best of times. But while using them in the world of continuously delivering autonomous teams I’ve repeatedly found myself faced with an impossible task: to be everywhere, tolerating significant contextual variance, and blocking no-one.</p>
<p>It made me wonder. Was there an alternative?</p>
<p>There was: I stopped taking architectural decisions. Completely.</p>
<p>In this article I’ll introduce this alternative mindset and the associated set of tools and practices which allow me to upend the traditional role of a “Software Architect” while simultaneously bringing the practice of software architecture to the fore across development teams. More importantly, I’ll explain how, within this alternative approach, everyone can do the architecting they need, safely and efficiently, without everything descending into chaos. <a href="https://martinfowler.com/articles/scaling-architecture-conversationally.html#footnote-anarchy">[1]</a></p>
<p><strong>We need more ways to “do” architecture, not less.</strong></p>
<p>The moves in software delivery towards ever-increasing team autonomy have, in my mind at least, heightened the need for more architectural thinking combined with alternative approaches to architectural decision-making.</p>
<p>Ensuring our software teams experience true autonomy raises a key problem: how might a small group of architects feed a significant number of hungry, value-stream-aligned teams? Why? Because in this environment Architects <a href="https://martinfowler.com/articles/scaling-architecture-conversationally.html#footnote-inc-me">[2]</a> now need to be in many, many more places at once, doing all that traditional &quot;architecture&quot;.</p>
<p>What we need is a workable way to approach the human-scaling challenges of team autonomy and the architectures which manifest as a result.</p>
<p>In the remainder of this article I’ll introduce an alternative way of doing and governing architecture. I’ll explain in detail what it is, how it works, and how you might adopt it yourself. Most importantly, I’ll highlight how to fail, in order that you might succeed.</p>
<h2 id="the-most-fundamental-element-decision-making-via-the-advice-process"><a class="header" href="#the-most-fundamental-element-decision-making-via-the-advice-process">The most fundamental element: decision-making via the “Advice Process”</a></h2>
<p>Let’s take as our starting point a team which we aim to make maximally independent. Clearly this team will need somehow to engage in architectural thinking and decision-taking, but how?</p>
<p>These “many centres of decision making” are precisely what we need, yet straight away it’s clear that traditional, top-down architecture, with a select group of all-powerful architects taking all the decisions, runs contrary to such a decentralised model. “And yet”, the challenge is voiced “decisions still need to be made - that’s what architecture is”, and these skeptics are right.</p>
<p>These architectural decisions must still be made deliberately - otherwise we’ll be back where we started, or worse. Therefore, the first aspect in this alternative approach, it’s core element in fact, must describe how it delivers on decision-making. It’s called the “Advice Process”.</p>
<p>The Advice Process is the core element of this anarchist, decentralised approach to architecture. It’s greatest quality is it’s remarkably simplicity. It comprises one rule, and one qualifier:</p>
<p><strong>The Rule:</strong> anyone can make an architectural decision.</p>
<p><strong>The Qualifier:</strong> before making the decision, the decision-taker must consult two groups: The first is everyone who will be meaningfully affected by the decision. The second is people with expertise in the area the decision is being taken.</p>
<p>That’s it. That’s the Advice Process in its entirety.</p>
<p>This apparent straightforwardness hides however a key concept which it’s worth making explicit; while decision-takers are in no way obliged to agree with the advice the folks in these two consulted groups give them, they must seek it out, and they must listen to and record it. We are not looking for consensus here, but we are looking for a broad range of inputs and voices.</p>
<p>A challenge frequently raised against this concerns just how many people must be consulted. It is a valid concern, but a mitigatable one. When deploying this technique we create a checklist to help those in the decision-making seat identify who to speak to, and in which regard. InfoSec impacted? Talk to the CISO. Getting close to PII? Engage Mary in the data team and Vanessa in legal. A potential change to the user onboarding flow? Talk to your UX lead. About to adopt a new cloud service? Chat to Kris the cloud architect. Thinking about a change to your API? Speak to all the leads of the teams who are your consumers.</p>
<p>Sometimes this list of consultees can be a long one. That’s fine. Some decisions are large ones, and the advice-scope is a clear indication of both size and import. Sometimes decisions can be made smaller in scope and many consequently are. Other times the sheer number of folks impacted makes the decide-ee think again. Is this thing which might make their life a little bit easier really worth the effort of consulting all those people? Or, can they split this large decision into multiple, smaller decisions? When decisions do proceed, they are frequently right-sized purely as a matter of expediency. <a href="https://martinfowler.com/articles/scaling-architecture-conversationally.html#footnote-econ-decisions">[3]</a></p>
<p>Can we push the Advice Process further? Yes we can, and we ought. I always encourage those following it to specifically seek out those who will disagree with them. Freed from the need to agree with what they hear, they inevitably engage far more seriously. Consequently the depth and breadth of advice received is greater. Decisions don’t tend to suffer as a consequence either. Neither does their learning.</p>
<p>Which brings us to the broader topic of benefits of the Advice Process. When deployed, I have always seen better, faster, more accountable decisions, and most importantly decisions which are understood and owned by those who implement them, precisely because the decidee is the one with the need as well as the one who is accountable.</p>
<p>As a side-effect, the pool of available decision-takers also grows, each of whom will soon be on the look-out for decisions which need to be made, and, given the feeling of empowered safety that the Advice Process gives them, flag them up and drive them to conclusion. The fact that a team's need for a decision to be taken can be met by themselves also leads to appropriate levels of bias-to-action, with accountability acting as a brake when it's required.</p>
<p>By working in this way we remove both the need for a fixed and permanent hierarchy and an abiding master decision-taker. It is for these two reasons that the Advice Process is the most fundamental element of this approach to architecture, because decentralised decision-making is the core element of anything which aspires to call itself “anarchistic”.</p>
<p>But wait, did we just remove in one fell swoop all need for we “traditional” architects? Not at all, but clearly our role has changed. In the following sections of this article - which introduces the supporting elements of this approach - we will see a set of rejuvenated practices and tools which allow us to get the teams, and the businesses they underpin, where they need to be.</p>
<p>Before we proceed to these supporting elements it is useful to take a short detour to highlight and discuss the one thing that all the remaining elements to this decentralised approach share, and also have in common with the core element: their focus on conversation, and it’s role in efficiently arriving at, and spreading, shared understanding.</p>
<h3 id="the-fundamental-role-of-conversations"><a class="header" href="#the-fundamental-role-of-conversations">The fundamental role of conversations</a></h3>
<p>Alberto Brandolini, inventor of Event Storming famously quipped “it is the developer’s assumptions which get shipped to production” and he’s right; it’s primarily what a developer understands about a target architecture that matters, not what is in the head or diagrams of a lead architect. This problem is age-old. Eric Evans tackled it in “<a href="https://www.amazon.com/gp/product/0321125215/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321125215&amp;linkCode=as2&amp;tag=martinfowlerc-20">Domain Driven Design: Tackling Complexity in the Heart of Software</a>” and more recently my colleague Erik Dörnenberg has spoken about it in his presentation “<a href="https://www.youtube.com/watch?v=qVyt3qQ_7TA">Architecture without Architects</a>”.</p>
<p>To me, it is this architecture, the one which is in the heads of those writing the code, that is the most important. In adopting this decentralised approach, where the practice of architectural decision-making is much more dispersed, this problem is in many ways, mitigated.</p>
<p>That’s something which helps me sleep at night.</p>
<p>However this decentralised, anarchistic approach then places front and centre another problem which all architectures must address: the delivery of a coherent whole. Here, we would seem to be at a disadvantage with our alternative approach. If everyone is empowered to make a decision, how do we, the “traditional” architects and ones who perhaps care most about the overall end result, ensure that the sum of all the individual decisions combine to form a coherent whole? How might we incorporate a longer-term perspective into those same decisions? And how might we support those who suddenly find themselves taking on levels of responsibility for which they might not feel comfortable?</p>
<p>Fortunately, another practitioner, and thinker in this space, Ruth Malan, has seen this before and shares the answer in her article “Do we still need architects?”:</p>
<blockquote>
<p>[In order for an architecture to be successful] it is very much about ensuring that conversations that are needed to be happening are happening - not always initiating them, nor always helping to focus or navigate them, but ensuring they do happen […] and guiding when needed</p>
<p>-- <a href="https://web.archive.org/web/20201222143814/https://www.ruthmalan.com/Journal/2016/2016JournalFebruary.htm#Still_Need_Architects">Ruth Malan</a></p>
</blockquote>
<p>Our adoption of the Advice Process opened up the space for anyone to make decisions, but it has also put conversations, the responsibility to seek out expertise, and think about impact at the core. The remainder of the elements of this approach, each of which supports the core element focus specifically on ensuring those conversations are as timely, focused and effective as possible. There are four of them:</p>
<ol>
<li>a thinking and recording tool</li>
<li>a time and place for conversations;</li>
<li>a light to illuminate and guide towards a unified direction;</li>
<li>a means to sense the current technical landscape and climate.</li>
</ol>
<p>We'll cover each of these in turn in a few seconds, but first I need to clarify two things.</p>
<h3 id="what-about-strategy-and-cross-functional-requirements"><a class="header" href="#what-about-strategy-and-cross-functional-requirements">What about strategy and cross-functional requirements?</a></h3>
<p>It's worth a few sentences on what isn't covered in this approach: technical strategy and cross-functional requirements (CFRs).</p>
<p>Clearly both are essential for all software endeavors of any meaningful size:</p>
<p>A well evangelized strategy can help the organization advance by having decentralized teams prioritize technical activities which are best aligned with the org's maturity and needs. Clearly the best technical decisions are those which support the strategy, and when this is the case this can be called out clearly.</p>
<p>A clear set of testable CFRs also helps a decentralised set of teams ensure that they look beyond their immediate, local delivery, and meet the minimum requirements for playing coherently in the shared ecosystem.</p>
<p>However, technical governance refers to both these rather than encompassing them - they contribute to the context within which it operates - and so I've not gone into any detail on them here. But what does governance include beyond a means to ensure good technical decisions? Let's take a look.</p>
<h2 id="the-four-supporting-elements"><a class="header" href="#the-four-supporting-elements">The Four Supporting Elements</a></h2>
<h3 id="1-a-thinking-and-recording-tool-decision-records"><a class="header" href="#1-a-thinking-and-recording-tool-decision-records">1. A thinking and recording tool: Decision Records</a></h3>
<p>The first supporting element is <a href="https://www.thoughtworks.com/radar/techniques/lightweight-architecture-decision-records">Architectural Decision Records</a> or ADRs. These are lightweight documents, frequently stored in source code repositories alongside the artefacts they describe. Now, there are a variety of formats which various adopters have chosen to champion, but the key elements which I insist on are as follows: <a href="https://martinfowler.com/articles/scaling-architecture-conversationally.html#footnote-two-more">[4]</a></p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>title</td><td>which includes a unique identifier, and the decision itself (e.g. “ADR001 - Use AKS for Kubernetes Pods”)</td></tr>
<tr><td>status</td><td>typically “Draft”, “Proposed”, “Adopted”, “Superseded” and “Retired”</td></tr>
<tr><td>decision</td><td>the decision that has been taken in a few sentences (frequently bold or italicized so it stands out)</td></tr>
<tr><td>context</td><td>the forces and current contextual circumstances which have necessitated this decision</td></tr>
<tr><td>options considered</td><td>each option considered, described briefly, with pros and cons. (Typically the option proposed / adopted comes first in this list)</td></tr>
<tr><td>consequences</td><td>the ramifications of this decision, both positive and negative</td></tr>
<tr><td>advice</td><td>this reflects the raw outputs from following the Advice Process. It is here that all advice given is recorded. This ought to include the name of the advice giver, and the date the advice was given. This can frequently take the forms of comments, and if these are provided directly by the advice-giver, then recording the meta-data is automatic.</td></tr>
</tbody></table>
</div>
<p>I’ve found in practice that having such a lightweight ADR template structure is not only a great way to record architectural decisions - it also helps teams learn to make architectural decisions. These key elements operate like a thinking checklist, and prompt the decide-ee regarding what they need to think about, and more importantly have conversations about.</p>
<p>What’s more, ADRs serve to reinforce the Advice Process by making it a requirement on ADR authors to capture and record all advice they get. I also encourage authors to engage with this advice directly in their ADR options section, whether they choose to follow it or not. It is one thing to seek advice and write it down. It is quite another to actively wrestle with it. The fruits get sweeter the more you engage.</p>
<p>It will come as no surprise to learn that consequently, a series of ADRs, and their surrounding conversations provide an excellent learning ground for people wanting to begin to take on the task of decision-taking; everything is out in the open, including the dissent and compromise-making. Less experienced practitioners of architecture can peruse the history of what went before them quickly and easily, see good (and quite likely less-good) examples, and see decisions being taken (and perhaps also being revoked when circumstances change / the team learned more). They are almost a thinking and decision lore for a set of software, written in the hand of those who contributed most to it.</p>
<p>While sadly I can’t share with you examples of these conversations I’ve had with my clients, there are some <a href="https://web.archive.org/web/20210506014629/https://upmo.com/dev/decisions/0010-som-synthetic-monitoring.html">great examples</a> of ADRs out on the public internet, courtesy of Thoughtworks-alumni Wisen Tanasa and his startup <a href="https://upmo.com/">Upmo</a>. I’d encourage you to take a look. They come <a href="https://twitter.com/mtnygard/status/1315647651854135297?lang=en">blessed by none other than Michael Nygard himself</a>.</p>
<h3 id="2-a-time-and-place-for-conversations-the-architecture-advisory-forum"><a class="header" href="#2-a-time-and-place-for-conversations-the-architecture-advisory-forum">2. A time and place for conversations: The Architecture Advisory Forum</a></h3>
<p>The second supporting element in this alternative approach exists to make all the conversations supporting this advice-seeking easier: a weekly, hour-long Architecture Advisory Forum (“AAF”).</p>
<p>Fundamentally, this is a regular and recurring place and time for conversations. Your ideal attendees are delegates from each team as well as your key representatives from your Advice Process checklist. However, the invite should remain completely open to encourage transparency and openness. The timeliness and quality of the conversations which take place is a key indicator of success, but equally important is the breadth and diversity of views shared, and the same goes for the contributors. If architecture is being “done” here, and lessons shared and learned, then you’re winning.</p>
<p>The standing agenda typically begins as follows:</p>
<ul>
<li>team representatives quickly share new <a href="http://www.extremeprogramming.org/rules/spike.html">spikes</a> (giving early warning of probable future decisions and allow the attendees to share existing knowledge and experience)</li>
<li>discussions about each new “proposed” decision (presented by those making the decision, captured ahead of time in the form of an ADR)</li>
<li>a re-visit of other decision-statuses (we timebox these, both to limit the window for incoming advice, and also to allow us to revisit a decision which we made with imperfect information)</li>
<li>a look at our collective four key metrics, our cloud spend trends, and finally</li>
<li>any other business (aka “AOB”)</li>
</ul>
<p>A cursory glance might give the impression that an AAF is just a new title for a standard meeting. The one typically known as a “Tech Advisory Board”, “Architecture Decision Forum” or “Architecture Review Board”. There are however several key differences.</p>
<p>Firstly, the Advice Process reigns. Decisions taken to the AAF are still owned and made by the originators. The only thing other attendees can do is offer advice, or suggest additional people to seek advice from. Hence the name.</p>
<p>This brings us to the second key difference. Given the Advice Process qualifiers, the invitees to the AAF are those typically affected / possessing relevant expertise. This means those typically present include representatives from each feature team (and not just the lead; BAs/POs and QAs are frequently present), people from other programmes of work, UX, Product, Operations, and occasionally senior execs.</p>
<p>The combination of these two differences leads us to the third, and most important key difference: the conversations. The Advice Process is great, but it’s conversations can frequently be 1-1. When they take place in an AAF there is an audience, so many people can listen and everyone can learn. The amount of organisational, domain, legacy, and experiential information and architectural skill-deployment shared at these sessions is unlike anything I have ever seen, and despite being a potentially dry meeting, it is the most well-attended, and most broadly participated hour of our week. It is one of the most significant contributors to the quest for a learning organisation that there is. AAFs encourage disagreement, and celebrate failure / changes of decision based on lessons learned. This all combines to broaden and deepen the general understanding of an architecture, virtually guaranteeing it ends up in the running software.</p>
<h3 id="3-a-light-to-illuminate-a-unified-goal-team-sourced-architectural-principles"><a class="header" href="#3-a-light-to-illuminate-a-unified-goal-team-sourced-architectural-principles">3. A light to illuminate a unified goal: Team-sourced Architectural Principles</a></h3>
<p>Having architectural principles is not new, though sadly I rarely encounter serviceable ones. Always important, in a world of highly-autonomous-teams they become essential because they are the means by which an aligned delivery direction is achieved without the need for control.</p>
<p>So what makes a good architectural principle? Firstly, it must provide a criteria with which to evaluate our architectural decisions (which in practice means it must be specific, measurable, achievable, realistic and testable, aka “S.M.A.R.T”). Secondly, it must support the business’s strategic goals. Thirdly, it must articulate the consequences / implications it necessarily contains within it. Finally, taken together as a set, they should number neither too few to cover the key needs which architectural principles meet, nor too many that teams cannot remember them all.</p>
<p>There is a great deal I could write here about bad architectural principles but I’ll stick to the key aspects. Firstly, they are not practices. Practices are how you go about something, such as following TDD, or Trunk Based Delivery, or Pair Programming. This is not to say that practices are bad (indeed Dr Forsgren’s “Accelerate” is full of recommendations regarding for their set of circumstances) they’re just not architectural principles.</p>
<p>Watch out for slipping into the other end of the scale too - general principles. “Keep it simple” and “Don’t repeat yourself” are principles, but they’re not architectural. Nor are the various principles you’ll see around project planning, and software quality management. What we need are means to direct and evaluate our architectural practice and decisions. What we need is something which helps me pick between <a href="https://martinfowler.com/articles/micro-frontends.html#IntegrationApproaches">various approaches to implementing micro-frontends</a>, or helps me decide if it really makes sense to <a href="https://frontend.turing.edu/lessons/module-4/oauth/index.html#OSP">hand-roll my own OAuth 2.0 implementation</a>, or guides me in evaluating self-hosted <a href="https://lucene.apache.org/">Lucene</a> on AWS vs <a href="https://aws.amazon.com/elasticsearch-service/">Amazon Elastic Search Service</a>.</p>
<p>Given all this, now let’s share a good principle, based around the <a href="https://martinfowler.com/bliki/TeamTopologies.html">Team Topologies</a> “Stream-Aligned Team” organisation model:</p>
<p><strong>Title:</strong> Value independence of teams most highly</p>
<p><strong>Subtitle:</strong> Split solutions along team lines</p>
<p><strong>Rationale:</strong> The strength of our approach to building and running our products relies fundamentally on the independence of our teams. The downsides to this are acknowledged, but the upsides are felt to outweigh it, especially when the difficulty of predicting future needs is taken into consideration.</p>
<p><strong>Implications:</strong></p>
<ul>
<li>Duplication of both function, and data, will inevitably arise. Rather then fight this, we embrace it, acknowledging the need, in certain circumstances, for noticeable eventual consistency and data replication</li>
<li>The combined licencing, runtime and support costs of multiple third-party solutions may be higher than the costs of a single, shared, cross-product-team solution</li>
<li>Solutions can be designed for the needs of the team which owns and runs them. They need not concern themselves the needs of other teams</li>
<li>Both systems and the third-party services / solutions they are build on will tend to be smaller, and more specific-task-focussed</li>
<li>Teams who go their own way need to self-support any third-party services / solutions which they adopt independently</li>
</ul>
<p>If you want to see more examples, please have a look at the publicly-available <a href="http://engineering-principles.onejl.uk/">John Lewis “Software Engineering Principles”</a>. <a href="https://martinfowler.com/articles/scaling-architecture-conversationally.html#footnote-jl-non-principles">[5]</a></p>
<p>So far, so general. Nothing I have said so far in this section would be controversial in any approach to architecture. Why then am I stressing these points so much? Not only is the importance of architectural principles heightened in this decentralised approach, but also everyone concerned needs to know how to structure them and what good looks like because they will be sourced from, and maintained by, the teams themselves.</p>
<p>Our approach is, to a great extent, taken directly from the excellent <a href="http://theartofscalability.com/">“The Art of Scalability”</a> by Abbot and Fisher. While their book assumes a slightly more top-down, hierarchical approach to architecture than presented here, the authors very much recognise the impact of the human element on their topic. In fact, the edition I read had been significantly re-written to give more weight to this perspective. One key aspect of this is their argument that for any architectural principle to be successful, teams which deliver against them need to feel a sense of ownership over it.</p>
<p>I’d encourage you to take a look at their book for a wealth of detail on how to source these from the collective. Suffice it to say, when presented with the business’s strategic goals, the “S.M.A.R.T.” criteria from earlier, and a broad set of invitees from across technology and beyond (yet again your AAF invitee list will prove invaluable here) you will rapidly and collectively arrive at 8-15 principles which will serve you well. <a href="https://martinfowler.com/articles/scaling-architecture-conversationally.html#footnote-jad-arb">[6]</a> It’s well worth capturing the adoption of a principle as an ADR. These will be very lightweight (don’t fall into the trap of repeating the principle itself) offering a great opportunity to articulate why this principle is important.</p>
<p>There is one final point to make on the principles. Remember that this approach is aimed at supporting team autonomy, so one key role played by our principles is as a minimal viable set of understandings and agreements between everyone. This raises a key point, because one thing we ask teams to explicitly flag in their ADRs is not just the principles which apply, but also when their decision conflicts with one or more principles. This becomes a great point to engage the Advice Process and the power of the collective at the AAF to really get all the best minds and varied perspectives on the problem, and then record all this in the ADR. Yet again, the various elements support each other, amplifying their benefits, and helping us get to successful architectures. Remember, if, as a consequence of this a principle changes, call that out as a separate ADR that supersedes the original.</p>
<p>That’s architectural principles covered, which play the role of a guiding light for everyone to aim for, but how do we also take note of our surrounding landscape and climate? Architectural decisions are also frequently based on what everyone else is doing, who has which skills, and what the general trends in the tech industry are. Enter the fourth and final supporting element: your own Technology Radar.</p>
<h3 id="4-a-tech-landscape-and-current-climate-sensing-tool---your-own-tech-radar"><a class="header" href="#4-a-tech-landscape-and-current-climate-sensing-tool---your-own-tech-radar">4. A tech landscape and current climate sensing tool - Your own Tech Radar</a></h3>
<p>Many people have heard of the ThoughtWorks <a href="https://www.thoughtworks.com/radar">Technology Radar</a> - an opinionated guide to current trends (predicted, current, and receding) in software languages and frameworks, tools, platforms, and techniques. It’s strengths lie in how it visually represents both the current landscape and the movements of various “blips” across it, allowing viewers to very rapidly see (for example) what is up and coming in the world of front-end frameworks, what’s current flavour of the month, and what’s beginning to fade.</p>
<p>Sadly, far fewer know about the fact you can <a href="https://www.thoughtworks.com/radar/byor">build your own radar</a>. The “BYOR” allows you, as a collective, to capture and map out your local version of the technology trends you see across your organisation. It’s very configurable too. In my most recent usage we kept the quadrants (Techniques, Tools, Platforms and Languages &amp; Frameworks) but changed the rings to reflect the transit of technologies through our programme of work (they became “experiment”, “adopt”, “hold” and finally “retire”).</p>
<p>As with the architectural principles, these radar blips need to be crowd-sourced in a workshop. The first run of this will capture everything you have now in your organisation - a baseline sweep or scan if you will. Prior to this you need to figure out how wide you will go (org-wide? just your project? Will you include disciplines such as Ops and UX? etc.) and what your quadrants will be. It’s also possible to add extra fields for data capture, but I typically try to keep it simple. The first time you do this it can take a fair time (we’ve taken four hours and more before) but this is because it is essential that you involve all team members, not just architects, and the end result will give a great overview of the landscape and prevailing climate, and brings many discussions about where effort should be directed, and where it should be reduced. And just as with the principles, give rise to a general aligning of team understanding.</p>
<p>What about the usage of your radar? As with the principles, there is also a place in our ADRs for “Relevant Radar Blips”. This is where we flag both adherence to the existing landscape as reflected in the current radar, but also, and more importantly, potential changes to the existing radar which this decision will introduce. Perhaps it’s the spiking of a new framework, or a move from “experiment” to “adopt” for a specific practice.</p>
<p>Again, this is great grist for the AAF discussion forum, and great content to capture in the ADR itself. You can even go so far as linking specific types of blip appearances and movements to the need to submit ADRs, though in my experience this happens anyway without anyone having to push it explicitly. Remember, your goals here are the broadest engagement with your evolving architecture as possible, as well as a growing architectural mindset across all team members.</p>
<p>How about keeping your radar up to date? I've seen quarterly cadences work, and half-yearly too. The key is to pay attention to how the radar is being consumed (or not) at the AAF and elsewhere. That should give you a good idea when it's worth investing in a refresh.</p>
<h2 id="how-this-typically-works-in-practice"><a class="header" href="#how-this-typically-works-in-practice">How this typically works in practice</a></h2>
<p>Given all this, how might you see it all working in practice? Let’s take a look…</p>
<p>When the need for an architectural decision first arises it will most likely be vague and possibly poorly understood. It’s therefore great to open up a new ADR template right away and start trying to fill it in.</p>
<p>First to be tackled is the “context” section. To attempt this we need to understand the “why” of our decision as well as surrounding forces which we need to balance. We’ll probably rapidly realise we need to do some research to be able to complete even this short section.</p>
<p>Early ports of call in this research ought to be the architectural principles and radar. The principles, you’ll recall, give us an idea of the direction of travel which our ideal solution will ideally manifest. Not all will be relevant, but some principles ought to help our decision-making. Recall that it’s an architectural principal’s primary goal to assist in the evaluation of multiple technical possibilities, and highlight the one which fits best.</p>
<p>Sometimes, the experience will be a little different. One alternative is that a relevant principle cannot help you pick between two options, then there is either very little difference to choose between, or potentially, your principle isn’t S.M.A.R.T. enough. This is a good reason to revisit the principle and re-define it.</p>
<p>The other alternative also may end, perhaps a little later, in a re-evaluated set of principles. These arise when in order to make your decision you feel inclined to contravene one or more principles. That’s ok; good decisions can go against the principles, but to do so you’ll need to state clearly why this course of action was the right step to take. Overriding a principle is a significant step because it means we are effectively diverging from the general direction of travel. Consequently, the decision, and resulting ADR must be clearly argued and strongly justified. It might also signal the time to revisit the principle in light of this development.</p>
<p>The radar in comparison is a lot more advisory in nature. It will give an idea of what, if anything, is the current de-facto standard in our problem space, what’s been done in the past, and what other teams might be experimenting with. Going a different way is a lot less likely to raise eyebrows, but it is again a definite reason to address the deviation in the ADR.</p>
<p>Given all this, we can start to come up with our key criteria to evaluate options against, as well as a list of alternatives. Perhaps we’ve realised we really need to do some homework and in which case we might spin off a timeboxed Spike to learn more about something. Our ADR thinking will help write super-clear acceptance criteria here. If we don’t need to do a Spike, we will think instead about seeking advice.</p>
<p>Having these inputs from the context (which will include, for example, a technical strategy), applicable principles, radar blips, and key criteria / alternatives will in turn help us think about who to speak to for advice. In my experience it is helpful to engage in this when you are relatively confident you understand the problem space / need, but before you become too attached to a specific solution. When you go and seek advice, spend most time and effort speaking to people who will disagree with you; those who you know think along different lines and where you know you will have blind spots. Not only this, challenge yourself. Consider “what’s bad about this alternative? What are its shortcomings?” Spend the most time thinking about the alternatives which challenge your decision most directly and fundamentally.</p>
<p>Before you have the discussion, it helps to have the ADR ready in a rough form, and share it with them in advance. This will give them thinking time. Then when you do meet, go through every element of the ADR template. Have you missed something from the context? From the principles / blips? From the evaluation criteria? Solicit and capture their advice on all these things. More importantly, ask them why they are making these suggestions. It is the answers to these questions that the keys to learning to make better architectural decisions lie. Your advisors will help you understand how they see problems, what they’ve encountered that was similar in the past, and even entire aspects which you don’t even think about. <a href="https://martinfowler.com/articles/scaling-architecture-conversationally.html#footnote-hiring-pain">[7]</a></p>
<p>What about the AAF? Isn’t that the place to gather advice? Yes, and everything I’ve shared above should guide you wherever you have the conversation, but for the first few decisions a team or individual takes it really helps to have these in a more targeted way with the key advisors. The ADR you present before the AAF will then be really solid and focused before it is shared widely, meaning that the resulting AAF conversations will be richer and more focused. Sometimes a quick conversation in the AAF will lead to a subsequent, more in depth, 1-1 conversation.</p>
<p>Remember, once you have advice, wherever it came from, you must roll it into your ADR. You need not take the advice given, but you have to record it. An excellent practice here is to prioritise things in your writing which people would find non-intuitive or surprising. If you disagree with key advice, state how and why. If you are doing something new, make it clear why the current way doesn’t work for you. Remember to use the principles. Sometimes they will support your decision. Make it clear how. Sometimes you will have to contravent them. Make it clear why. Your goal is to make the reader understand why you took the decision you took. If you meet this goal, then you will not just have a solid decision, you’ll most likely have learned a great deal in the process. <a href="https://martinfowler.com/articles/scaling-architecture-conversationally.html#footnote-adr-equiv-blogs">[8]</a></p>
<p>Before I close this section, remember, all decisions are point-in-time, and no-one can ever foresee every eventuality, but you want to be able to go back later and still feel good about a decision, given what you knew / understood at the time. In this, the context and criteria you capture are key. This re-visiting of decisions is another great learning tool. With the benefit of hindsight you can now ask questions such as: “did we understand the context well enough?” and “were we honest enough with ourselves about what we knew and what we didn’t?”</p>
<h2 id="how-to-fail"><a class="header" href="#how-to-fail">How to fail</a></h2>
<p>So that’s the extent of our alternative, decentralised, anarchistic approach to architecture, and an idea of how it typically all fits together. But before we conclude, we ought to address one final aspect - the key ways in which you can fail. Let’s enumerate them.</p>
<p>The majority of failures you will see will actually be good ones - mini failures as decisions are taken by those who are less experienced. These are good because the process facilitates quick decisions, by those who need them, and more importantly, it facilitates transparency and rapid identification of failures (as those who took the decision will be aware of the issues as they code it) and a safe means to re-visit, and share the learnings. Embrace these, calling them out specifically and celebrating them in the AAF. This is a key aspect of building a learning culture.</p>
<p>To learn most effectively you need to feel safe, and when learning collectively everyone benefits from the broadest, most diverse range of inputs contributing to discussions. Remember, in this approach, we are explicitly not looking for consensus, but we are looking for a broad range of inputs and voices. It is here that the next failure mode lies, and it is far more insidious and damaging than the first. This second failure mode arises when you, in your job as a conversation-starter and space-holder, fail to include all who ought to be contributing and deciding and learning. For a great part early adoption stages of this style of architecture can feel like great successes. “It’s working! More and more people are taking decisions, writing them up in ADRs, giving advice and discussing them in the AAF! I’ve never seen such engagement with principles before!”. Only later, on reflection, will you realise the gains could have been far greater. It is precisely when this first flush of satisfaction strikes that you must be most on your guard. Are you really observing mass participation and learning, or is it a core group of usual suspects? You mitigate this problem actively. Watch out for who contributes. Amplify voices and ensure others listen to the quieter contributors. Make sure influence is balanced and not based on reputation, tenure or place in the hierarchy. Actively encourage many viewpoints and highlight the value it brings so that it becomes self-sustaining.</p>
<p>The third failure mode is an early warning that you are encountering the preceding failure mode, however, this one lives more in the grey area between desired and unwelcome. As you proceed along this journey you will uncover off-the-grid decisions. Decisions which never came up at the AAF, and which never made it into an ADR. There are two ways to approach them. The first, correct way, is to treat the discovery as what you hope it is - an honest mistake, and an opportunity to learn and teach others. Perhaps the decide-ees weren’t even aware of the fact it was a key decision they were taking. Perhaps they were under pressure from elsewhere. Perhaps they thought it wasn’t as significant as it turned out to be. Perhaps they felt they would be shouted down in the AAF. Whatever the reason, treat it as a way for both them, and you, to learn. To improve the process. The other, wrong way to treat these, is to fall back to old ways, and take back control. Which takes us nicely to the failure mode which completely destroys this approach and all that it promises.</p>
<p>It’s easy to slip into this fourth and most dangerous failure mode, and so it needs constant vigilance on your part. The only thing which needs to happen to trigger this is for “capital-A” architects such as yourself to fail to trust people; it is to not practice what you preach; it is to not clear enough space for the mini failures and consequent learning opportunities just mentioned; it is to continue to perform “shadow architecture” behind the scenes to make sure things still go how you think they ought to, despite all the signals from elsewhere. The sole benefit of this failure mode is that it becomes evident very rapidly as all the benefits I’ve listed above fail to materialize.</p>
<p>If you’re wondering if it’s this key failure mode which makes this approach to architecture hard to pull off you’d be right. I have been lucky in the past. Colleagues have called me out when I’ve made decisions for others, and I’ve caught myself getting frustrated that folks don’t know what I know. But then I realise I’m failing in my real task as a practitioner of architecture - I’m failing to get the right conversations happening, with the right people, at the right time. Remember that (perhaps even task others with calling you out when you fail to stick to the process) and you’ll be surprised how easy (and satisfying) it is to succeed.</p>
<h2 id="the-five-elements-again-and-possible-further-steps"><a class="header" href="#the-five-elements-again-and-possible-further-steps">The five elements again, and possible further steps</a></h2>
<p>Given we now have both the good and the (potentially) bad, as well as a collection of failure modes to look out for, let’s conclude. We recall we have the five elements of our alternative approach to architecture:</p>
<p>One core element: Advice Process</p>
<p>Four supporting elements:</p>
<ul>
<li>Architecture Advisory Forum</li>
<li>Lightweight ADRs</li>
<li>Team-sourced Principles</li>
<li>Your own Tech Radar</li>
</ul>
<p>Hopefully I’ve made it clear that while none of the elements may be new to you (aside from perhaps the Advice Process) there is something very different. This difference lies in the interplay/mutual reinforcement between all of these against a backdrop of conversations, learning and safety. What is hopefully enticing is the fact that, in my experience at least, this is far more likely to provide successfully deployed architectures, now, and into the future. It is my go-to for scaling myself, and making sure that the teams I work with deliver on the promises we have made to our users, which is, after all, the goal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-record-architecture-decisions"><a class="header" href="#1-record-architecture-decisions">1. Record architecture decisions</a></h1>
<p>Date: 2023-11-01</p>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<p>Accepted</p>
<h2 id="context-10"><a class="header" href="#context-10">Context</a></h2>
<p>We need to record the architectural decisions made on this project.</p>
<h2 id="decision-1"><a class="header" href="#decision-1">Decision</a></h2>
<p>We will use Architecture Decision Records, as described by Michael Nygard in this article: http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions</p>
<h2 id="consequences-1"><a class="header" href="#consequences-1">Consequences</a></h2>
<p>See Michael Nygard's article, linked above.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functional-overview"><a class="header" href="#functional-overview">Functional Overview</a></h2>
<p>The high-level functional requirements for the new Risk System are as follows.</p>
<p><img src="architecture%5Cstructurizr%5Cdocs/images/functional-overview.png" alt="Functional overview" /></p>
<ol>
<li>Import trade data from the Trade Data System.</li>
<li>Import counterparty data from the Reference Data System.</li>
<li>Join the two sets of data together, enriching the trade data with information about the counterparty.</li>
<li>For each counterparty, calculate the risk that the bank is exposed to.</li>
<li>Generate a report that can be imported into Microsoft Excel containing the risk figures for all counterparties known by the bank.</li>
<li>Distribute the report to the business users before the start of the next trading day (9am) in Singapore.</li>
<li>Provide a way for a subset of the business users to configure and maintain the external parameters used by the risk calculations.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-checklist"><a class="header" href="#architecture-checklist">Architecture Checklist</a></h1>
<h2 id="general-1"><a class="header" href="#general-1">General</a></h2>
<ul>
<li>ARC-1      Does the architecture communicate an adequate vision of the system that will direct further design activities?</li>
<li>ARC-2      Is the architecture well organized and provide a concise system overview, background information, constraints, and a clear organizational structure for all downstream designs?</li>
<li>ARC-3      Is the architecture designed to accommodate likely changes?</li>
<li>ARC-4      Does the architecture stay above detailed design and user interface design activities?</li>
<li>ARC-5      Do the dependencies between different architectural views hold together?</li>
</ul>
<h2 id="architecture-design"><a class="header" href="#architecture-design">Architecture Design</a></h2>
<ul>
<li>ARC-6      Is the system architecture, including the data flows, control flows, high-level elements, and interfaces, clearly represented?</li>
<li>ARC-7      Are fine grain element details omitted and left to subsequent design artifacts?</li>
<li>ARC-8    Does the architecture cleanly decompose the top-level elements of the system?</li>
<li>ARC-9    To the extent possible, is the architecture independent of the technology that will use used to implement it?</li>
<li>ARC-10    Does the architecture take into account technology or other constraints that cannot be avoided, i.e., can the architecture be implemented for the target environment?</li>
<li>ARC-11    Have you used round-trip design, selecting the best of several attempts?  Are reasons listed for the discounted alternatives?</li>
<li>ARC-12    Does the architecture differentiate between the problem-domain, the user-interface, task-management, and data-management? If not, is the lack explained and justified?</li>
</ul>
<h2 id="architectural-features"><a class="header" href="#architectural-features">Architectural Features</a></h2>
<ul>
<li>ARC-13    Are external interfaces, including user interfaces, defined and justified?</li>
<li>ARC-14    Is a level of robustness specified and justified?</li>
<li>ARC-15    Is the architecture appropriately layered?</li>
<li>ARC-16    Is the architecture loosely coupled and have good cohesion?</li>
<li>ARC-17    Does the architecture set resource budgets for each element?</li>
</ul>
<h2 id="strategies"><a class="header" href="#strategies">Strategies</a></h2>
<ul>
<li>ARC-18    Is an I/O strategy described and justified?</li>
<li>ARC-19    Is an error-handling strategy described and justified?</li>
<li>Project Level Support</li>
<li>ARC-20    Does the architecture support the lifecycle selected by the project?</li>
<li>ARC-21    Are the major system goals clearly stated?</li>
<li>ARC-22    Is the system environment defined, including hardware, software, and external systems?</li>
<li>ARC-23    Are necessary buy vs. build decisions included and justified?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-checklist"><a class="header" href="#design-checklist">Design Checklist</a></h1>
<h2 id="general-2"><a class="header" href="#general-2">General</a></h2>
<ul>
<li>SD-1 Do individual elements of the design (e.g., a diagram) conform to appropriate checklists?</li>
<li>SD-2 Does the design support both product and project goals?</li>
<li>SD-3 Is the design feasible from a technology, cost, and schedule standpoint?</li>
<li>SD-4 Have known design risks been identified, analyzed, and planned for or mitigated?</li>
<li>SD-5 Are the methodologies, notations, etc. used to create and capture the design appropriate?</li>
<li>SD-6 Does the level of formality match the project size, project goals, and engineer expertise?</li>
<li>SD-7 Has the design been refined based on prototyping or implementation feedback?</li>
<li>SD-8 If possible, were proven past designs reused?</li>
<li>SD-9 Does the design support proceeding to the next development step?</li>
</ul>
<h2 id="design-considerations"><a class="header" href="#design-considerations">Design Considerations</a></h2>
<ul>
<li>SD-10 Does the design have conceptual integrity? (i.e., does the whole thing hang together?)</li>
<li>SD-11 Can the design be implemented within technology and environmental constraints?</li>
<li>SD-12 Does the design use standard techniques and avoid exotic, hard-to-understand elements?</li>
<li>SD-13 Does the design emphasizes simplicity over cleverness?</li>
<li>SD-14 Is the design “as simple as possible, but no simpler”?</li>
<li>SD-15 Is the design lean? (i.e., are all of its parts strictly necessary?)</li>
<li>SD-16 If part of an evolutionary lifecycle or if change is expected in maintenance, do expected volatile areas of the design support expected changes or refactoring of the design? (e.g., have design for change principles been followed?)</li>
<li>SD-17 Does the design create reusable components if appropriate?</li>
<li>SD-18 Will the design be easy to port to another environment if appropriate?</li>
<li>SD-19 Does the design have low complexity?</li>
<li>SD-20 Is the design intellectually manageable?</li>
<li>SD-21 Is the design robust?</li>
</ul>
<h2 id="requirements-traceability"><a class="header" href="#requirements-traceability">Requirements Traceability</a></h2>
<ul>
<li>SD-22 Does the design address all issues from the requirements?</li>
<li>SD-23 Does the design add features or functionality, which was not specified by the requirements? (i.e., are all parts of the design traceable back to requirements?)</li>
<li>SD-24 If appropriate has requirements coverage been documented with a completed requirements traceability matrix?</li>
</ul>
<h2 id="level-of-detail"><a class="header" href="#level-of-detail">Level of Detail</a></h2>
<ul>
<li>SD-25 Is the level of detail appropriate for this design artifact?</li>
<li>SD-26 Has sufficient detail been included to allow the downstream consumer of the design to produce their artifacts (design, databases, code, test plan, etc.)?</li>
</ul>
<h2 id="completeness"><a class="header" href="#completeness">Completeness</a></h2>
<ul>
<li>SD-27 Are all of the assumptions, constraints, design decisions, and dependencies documented?</li>
<li>SD-28 Has a risk plan been made for the parts of the design that may not be feasible?</li>
<li>SD-29 Are assumptions made due to missing information been documented?</li>
<li>SD-30 Have all reasonable alternative designs been considered, including not automating some processes in software?</li>
<li>SD-31 Have all goals, tradeoffs, and decisions been described?</li>
</ul>
<h2 id="consistency"><a class="header" href="#consistency">Consistency</a></h2>
<ul>
<li>SD-32 Is the design consistent with its upstream and downstream artifacts?</li>
<li>SD-33 Does the design adequately address issues that were identified and deferred at previous upstream levels?</li>
<li>SD-34 Have the impacts of all ‘To-Be-Determined’ (TBD) issues in the upstream artifacts been assessed and addressed?</li>
<li>SD-35 Does the design make sense both from the top down and the bottom up?  SD-36       Is the design consistent with related artifacts? (i.e. other modules, designs, etc.)  SD-37       Is the design consistent with the development and operating environments?</li>
</ul>
<h2 id="performance-1"><a class="header" href="#performance-1">Performance</a></h2>
<ul>
<li>SD-38 Are all performance attributes, assumptions, and constraints clearly defined?</li>
<li>SD-39 If appropriate are there justifications for design performance? (e.g., prototyping critical areas or reusing an existing design proven in the same context)</li>
</ul>
<h2 id="maintainability"><a class="header" href="#maintainability">Maintainability</a></h2>
<ul>
<li>SD-40 Does the design allow for ease of maintenance?</li>
<li>SD-41 If reusable parts of other designs are being used, has their effect on design and integration been stated?</li>
<li>SD-42 Does the design account for future extensions to the program?</li>
<li>SD-43 Does the design resists erosion in the correctness of its content over time?</li>
</ul>
<h2 id="compliance"><a class="header" href="#compliance">Compliance</a></h2>
<ul>
<li>SD-44 Does the design follow all standards necessary for the system? (e.g., date standards)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
